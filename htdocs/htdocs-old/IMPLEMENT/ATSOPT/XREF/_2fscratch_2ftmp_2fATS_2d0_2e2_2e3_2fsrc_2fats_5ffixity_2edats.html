<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: July 2007
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* ats_fixity: for handing prefix, infix and postfix operators *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Loc <span class="keyword">=</span> "ats_location.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Sym <span class="keyword">=</span> "ats_symbol.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_fixity.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">assume</span> <span class="staexp">prec_t<span class="keyword">:</span> t@ype <span class="keyword">=</span> int</span>

<span class="keyword">implement</span> prec_make_int <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> i

<span class="comment">//
</span>
<span class="keyword">datatype</span> <span class="staexp"><a name="1848"><span class="stacstdec">fxty</span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> FXTYnon
  <span class="keyword">|</span> FXTYinf <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>prec_t<span class="keyword">,</span> assoc<span class="keyword">)</span></span>
  <span class="keyword">|</span> FXTYpre <span class="keyword">of</span> <span class="staexp">prec_t</span>
  <span class="keyword">|</span> FXTYpos <span class="keyword">of</span> <span class="staexp">prec_t</span>
<span class="comment">// end of [fxty]
</span>
<span class="keyword">assume</span> <span class="staexp">fxty_t <span class="keyword">=</span> fxty</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> fprint_fxty
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> fxty<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> fxty <span class="keyword">of</span>
  <span class="keyword">|</span> FXTYnon <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "FXTYnon()"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [FXTYnon]
</span>  <span class="keyword">|</span> FXTYinf <span class="keyword">(</span>p<span class="keyword">,</span> a<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "FXTYinf("<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_int <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> p<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ")"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [FXTYinf]
</span>  <span class="keyword">|</span> FXTYpre <span class="keyword">(</span>p<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "FXTYpre("<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_int <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> p<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ")"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [FXTYpre]
</span>  <span class="keyword">|</span> FXTYpos <span class="keyword">(</span>p<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "FXTYpos("<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_int <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> p<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ")"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [FXTYpos]
</span><span class="keyword">end</span> <span class="comment">// end of [fprint_fxty]
</span>
<span class="keyword">implement</span> print_fxty <span class="keyword">(</span>fxty<span class="keyword">)</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_fxty<span class="keyword">,</span> fxty<span class="keyword">)</span>
<span class="keyword">implement</span> prerr_fxty <span class="keyword">(</span>fxty<span class="keyword">)</span> <span class="keyword">=</span> prerr_mac <span class="keyword">(</span>fprint_fxty<span class="keyword">,</span> fxty<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> precedence_inc <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> p + i
<span class="keyword">implement</span> precedence_dec <span class="keyword">(</span>p<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> p - i

<span class="keyword">implement</span>
fixity_get_prec
  <span class="keyword">(</span>fxty<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> fxty <span class="keyword">of</span>
  <span class="keyword">|</span> FXTYnon <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> FXTYinf <span class="keyword">(</span>p<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>p<span class="keyword">)</span>
  <span class="keyword">|</span> FXTYpre p <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>p<span class="keyword">)</span>
  <span class="keyword">|</span> FXTYpos p <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>p<span class="keyword">)</span>
<span class="comment">// end of [fixity_get_prec]
</span>
<span class="keyword">implement</span> fxty_non <span class="keyword">=</span> FXTYnon <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">implement</span> fxty_inf <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">,</span> a<span class="keyword">:</span> <span class="staexp">assoc</span><span class="keyword">)</span> <span class="keyword">=</span> FXTYinf <span class="keyword">(</span>p<span class="keyword">,</span> a<span class="keyword">)</span>
<span class="keyword">implement</span> fxty_pre <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">)</span> <span class="keyword">=</span> FXTYpre p
<span class="keyword">implement</span> fxty_pos <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">)</span> <span class="keyword">=</span> FXTYpos p

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">val</span> app_prec <span class="keyword">=</span> 70
<span class="keyword">and</span> app_assoc <span class="keyword">=</span> ASSOClft

<span class="keyword">val</span> backslash_prec <span class="keyword">=</span> app_prec + 1

<span class="comment">//
</span>
<span class="keyword">implement</span> select_prec <span class="keyword">=</span> 80 <span class="comment">(* .label is a postfix operator *)</span>
<span class="keyword">implement</span> selptr_fixity_dyn <span class="keyword">=</span> FXTYinf <span class="keyword">(</span>select_prec<span class="keyword">,</span> ASSOClft<span class="keyword">)</span>

<span class="keyword">implement</span> exi_prec_sta <span class="keyword">=</span> 0
<span class="keyword">implement</span> uni_prec_sta <span class="keyword">=</span> 0

<span class="comment">//
</span>
<span class="keyword">implement</span> delay_prec_dyn <span class="keyword">=</span> 0
<span class="keyword">implement</span> exist_prec_dyn <span class="keyword">=</span> 0 <span class="comment">(* for dynamic patterns *)</span>

<span class="comment">//
</span>
<span class="keyword">implement</span> dynload_prec_dyn <span class="keyword">=</span> app_prec + 1

<span class="comment">//
</span>
<span class="comment">// supporting [&amp;p-&gt;lab] = &amp;(p-&gt;lab)
</span><span class="keyword">implement</span> ptrof_prec_dyn <span class="keyword">=</span> select_prec - 1

<span class="comment">// supporting [fold@ !p], [free@ !p] and [view@ !p]
</span><span class="keyword">implement</span> foldat_prec_dyn <span class="keyword">=</span> app_prec - 1
<span class="keyword">implement</span> freeat_prec_dyn <span class="keyword">=</span> app_prec - 1
<span class="keyword">implement</span> viewat_prec_dyn <span class="keyword">=</span> app_prec - 1

<span class="comment">//
</span>
<span class="comment">(* [invar_prec_sta] must be greater than [trans_prec_sta] *)</span>
<span class="keyword">implement</span> invar_prec_sta <span class="keyword">=</span> 1
<span class="keyword">implement</span> qmark_prec_sta <span class="keyword">=</span> app_prec - 1
<span class="keyword">implement</span> qmarkbang_prec_sta <span class="keyword">=</span> app_prec - 1
<span class="keyword">implement</span> r0ead_prec_sta <span class="keyword">=</span> 100 <span class="comment">(* highest *)</span>
<span class="keyword">implement</span> trans_prec_sta <span class="keyword">=</span> 0

<span class="comment">//
</span>
<span class="keyword">implement</span> crypt_prec_dyn <span class="keyword">=</span> 0

<span class="comment">//
</span>
<span class="keyword">val</span> deref_prec_dyn <span class="keyword">=</span> 100
<span class="keyword">implement</span> deref_fixity_dyn <span class="keyword">=</span> FXTYpre <span class="keyword">(</span>deref_prec_dyn<span class="keyword">)</span>

<span class="comment">//
</span>
<span class="keyword">implement</span> item_app f <span class="keyword">=</span> ITEMopr <span class="keyword">(</span>OPERinf <span class="keyword">(</span>app_prec<span class="keyword">,</span> app_assoc<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>

<span class="comment">//
</span>
<span class="keyword">implement</span> oper_make_backslash <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span>locf<span class="keyword">,</span> appf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> f1 <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">fn</span> f2 <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
      <span class="keyword">val</span> loc <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_combine <span class="keyword">(</span>locf x1<span class="keyword">,</span> locf x2<span class="keyword">)</span>
    <span class="keyword">in</span>
      ITEMatm <span class="keyword">(</span>appf <span class="keyword">(</span>loc<span class="keyword">,</span> x<span class="keyword">,</span> loc<span class="keyword">,</span> <span class="keyword">'[</span>x1<span class="keyword">,</span> x2<span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [f2]
</span>  <span class="keyword">in</span>
    ITEMopr <span class="keyword">(</span>OPERinf <span class="keyword">(</span>0<span class="keyword">,</span> ASSOCnon<span class="keyword">,</span> f2<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [f1]
</span><span class="keyword">in</span>
  ITEMopr <span class="keyword">(</span>OPERpre <span class="keyword">(</span>backslash_prec<span class="keyword">,</span> f1<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [oper_make_backslahsh]
</span>
<span class="comment">//
</span>
<span class="keyword">implement</span> oper_make
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>locf<span class="keyword">,</span> appf<span class="keyword">,</span> opr<span class="keyword">,</span> fx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc_opr <span class="keyword">=</span> locf opr

  <span class="keyword">fn</span> aux_inf
    <span class="keyword">(</span>opr<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">,</span> a<span class="keyword">:</span> <span class="staexp">assoc</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">fn</span> f <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
      <span class="keyword">val</span> loc <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_combine <span class="keyword">(</span>locf x1<span class="keyword">,</span> locf x2<span class="keyword">)</span>
    <span class="keyword">in</span>
      ITEMatm <span class="keyword">(</span>appf <span class="keyword">(</span>loc<span class="keyword">,</span> opr<span class="keyword">,</span> loc<span class="keyword">,</span> <span class="keyword">'[</span>x1<span class="keyword">,</span> x2<span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [f]
</span>  <span class="keyword">in</span>
    ITEMopr <span class="keyword">(</span>OPERinf <span class="keyword">(</span>p<span class="keyword">,</span> a<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux_inf]
</span>   
  <span class="keyword">fn</span> aux_pre <span class="keyword">(</span>opr<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">fn</span> f <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
      <span class="keyword">val</span> loc_x <span class="keyword">=</span> locf x
      <span class="keyword">val</span> loc <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_combine <span class="keyword">(</span>loc_opr<span class="keyword">,</span> loc_x<span class="keyword">)</span>
    <span class="keyword">in</span>
      ITEMatm <span class="keyword">(</span>appf <span class="keyword">(</span>loc<span class="keyword">,</span> opr<span class="keyword">,</span> loc_x<span class="keyword">,</span> <span class="keyword">'[</span>x<span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [f]
</span>  <span class="keyword">in</span>
    ITEMopr <span class="keyword">(</span>OPERpre <span class="keyword">(</span>p<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux_pre]
</span>
  <span class="keyword">fn</span> aux_pos <span class="keyword">(</span>opr<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">prec_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">fn</span> f <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">item a</span> <span class="keyword">=</span> <span class="keyword">let</span>
      <span class="keyword">val</span> loc_x <span class="keyword">=</span> locf x
      <span class="keyword">val</span> loc <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_combine <span class="keyword">(</span>loc_x<span class="keyword">,</span> loc_opr<span class="keyword">)</span>
    <span class="keyword">in</span>
      ITEMatm <span class="keyword">(</span>appf <span class="keyword">(</span>loc<span class="keyword">,</span> opr<span class="keyword">,</span> loc_x<span class="keyword">,</span> <span class="keyword">'[</span>x<span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [f]
</span>  <span class="keyword">in</span>
    ITEMopr <span class="keyword">(</span>OPERpos <span class="keyword">(</span>p<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux_pos]
</span><span class="keyword">in</span> 
  <span class="keyword">case+</span> fx <span class="keyword">of</span>
  <span class="keyword">|</span> FXTYnon <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ITEMatm <span class="keyword">(</span>opr<span class="keyword">)</span>
  <span class="keyword">|</span> FXTYinf <span class="keyword">(</span>p<span class="keyword">,</span> a<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux_inf <span class="keyword">(</span>opr<span class="keyword">,</span> p<span class="keyword">,</span> a<span class="keyword">)</span>
  <span class="keyword">|</span> FXTYpre p <span class="keyword">=&gt;</span> aux_pre <span class="keyword">(</span>opr<span class="keyword">,</span> p<span class="keyword">)</span>
  <span class="keyword">|</span> FXTYpos p <span class="keyword">=&gt;</span> aux_pos <span class="keyword">(</span>opr<span class="keyword">,</span> p<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [oper_make]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> oper_associativity opr <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> opr <span class="keyword">of</span> OPERinf <span class="keyword">(</span>_<span class="keyword">,</span> a<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> a <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> ASSOCnon <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [oper_associativity]
</span>        
<span class="keyword">implement</span> oper_precedence opr <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> opr <span class="keyword">of</span>
  <span class="keyword">|</span> OPERinf <span class="keyword">(</span>p<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> p <span class="keyword">|</span> OPERpre <span class="keyword">(</span>p<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> p <span class="keyword">|</span> OPERpos <span class="keyword">(</span>p<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> p
<span class="keyword">end</span> <span class="comment">// end of [oper_precedence]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">nil list_nil</span>
<span class="keyword">#define</span> <span class="neuexp">:: list_cons</span>

<span class="keyword">implement</span> fixity_resolve
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>loc0<span class="keyword">,</span> app<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>

<span class="keyword">fn</span> err <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">$Loc<span class="keyword">.</span>location_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  $Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": error(1)"<span class="keyword">;</span>
  prerr ": fixity cannot be resolved"<span class="keyword">;</span>
  prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
  $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [err]
</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="6699"><span class="stacstdec">I <span class="keyword">=</span> item a</span></a></span> <span class="keyword">and</span> <span class="staexp"><a name="6714"><span class="stacstdec">IS <span class="keyword">=</span> List <span class="keyword">(</span>item a<span class="keyword">)</span></span></a></span>

<span class="comment">(*
** [fn*] for mutual tail-recursion
*)</span>
<span class="keyword">fn*</span> resolve <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">I</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">)</span>
  <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> m<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> ITEMatm _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ys <span class="keyword">of</span>
    <span class="keyword">|</span> ITEMatm _ :: _ <span class="keyword">=&gt;</span> resolve_app <span class="keyword">(</span>xs<span class="keyword">,</span> m<span class="keyword">,</span> ys<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [begin]
</span>  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> ITEMopr opr<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">(</span>opr<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>OPERpre _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>OPERinf _<span class="keyword">,</span> _ :: nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>OPERinf _<span class="keyword">,</span> _ :: ITEMopr opr1 :: _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> p <span class="keyword">=</span> oper_precedence opr <span class="keyword">and</span> p1 <span class="keyword">=</span> oper_precedence opr1
      <span class="keyword">in</span>
        <span class="keyword">case+</span> compare <span class="keyword">(</span>p<span class="keyword">,</span> p1<span class="keyword">)</span> <span class="keyword">of</span>
        <span class="keyword">|</span>  1 <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span> <span class="keyword">|</span> ~1 <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>m :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
        <span class="keyword">|</span>  _ <span class="comment">(* 0 *)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
             <span class="keyword">val</span> assoc <span class="keyword">=</span> oper_associativity opr
             <span class="keyword">and</span> assoc1 <span class="keyword">=</span> oper_associativity opr1
           <span class="keyword">in</span>
             <span class="keyword">case+</span> <span class="keyword">(</span>assoc<span class="keyword">,</span> assoc1<span class="keyword">)</span> <span class="keyword">of</span>
             <span class="keyword">|</span> <span class="keyword">(</span>ASSOClft <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> ASSOClft <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>m :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
             <span class="keyword">|</span> <span class="keyword">(</span>ASSOCrgt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> ASSOCrgt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span>
             <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
           <span class="keyword">end</span> <span class="comment">// end of [_ (* 0 *)]
</span>      <span class="keyword">end</span> <span class="comment">// end of [let]
</span>    <span class="keyword">|</span> <span class="keyword">(</span>OPERpos _<span class="keyword">,</span> _ :: ITEMopr opr1 :: _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> p <span class="keyword">=</span> oper_precedence opr <span class="keyword">and</span> p1 <span class="keyword">=</span> oper_precedence opr1
      <span class="keyword">in</span>
        <span class="keyword">case+</span> compare <span class="keyword">(</span>p<span class="keyword">,</span> p1<span class="keyword">)</span> <span class="keyword">of</span>
        <span class="keyword">|</span>  1 <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span> <span class="keyword">|</span> ~1 <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>m :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
        <span class="keyword">|</span>  _ <span class="comment">(* 0 *)</span> <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [let]
</span>    <span class="keyword">|</span> <span class="keyword">(</span>OPERpos _<span class="keyword">,</span> _ :: nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>xs<span class="keyword">,</span> m :: ys<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_, ITEMopr, _]
</span><span class="keyword">end</span> <span class="comment">// end of [resolve]
</span>
<span class="keyword">and</span> resolve_app
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">I</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">case+</span> ys <span class="keyword">of</span>
  <span class="keyword">|</span> _ :: ITEMopr opr1 :: _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> p1 <span class="keyword">=</span> oper_precedence opr1
      <span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>app_prec<span class="keyword">,</span> p1<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> sgn <span class="keyword">of</span>
      <span class="keyword">|</span> 1 <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: app :: ys<span class="keyword">)</span> <span class="keyword">|</span> ~1 <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>m :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
      <span class="keyword">|</span> _ <span class="comment">(*0*)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
           <span class="keyword">val</span> assoc1 <span class="keyword">=</span> oper_associativity opr1 <span class="keyword">in</span> <span class="keyword">case+</span> assoc1 <span class="keyword">of</span>
             <span class="keyword">|</span> ASSOClft <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>m :: xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
         <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">// end of [_ :: ITERMopr :: _]
</span>  <span class="keyword">|</span> _ :: nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> next <span class="keyword">(</span>xs<span class="keyword">,</span> m :: app :: ys<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
<span class="comment">// end of [resolve_app]
</span>              
<span class="keyword">and</span> reduce
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">case+</span> ys <span class="keyword">of</span>
  <span class="keyword">|</span> ITEMatm t :: ITEMopr <span class="keyword">(</span>OPERpre <span class="keyword">(</span>_<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span> :: ys <span class="keyword">=&gt;</span>
    next <span class="keyword">(</span>f t :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
  <span class="keyword">|</span> ITEMatm t1 :: ITEMopr <span class="keyword">(</span>OPERinf <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span> :: ITEMatm t2 :: ys <span class="keyword">=&gt;</span>
    next <span class="keyword">(</span>f <span class="keyword">(</span>t2<span class="keyword">,</span> t1<span class="keyword">)</span> :: xs<span class="keyword">,</span> ys<span class="keyword">)</span>
  <span class="keyword">|</span> ITEMopr <span class="keyword">(</span>OPERpos <span class="keyword">(</span>_<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span> :: ITEMatm t :: ys <span class="keyword">=&gt;</span>
    next <span class="keyword">(</span>xs<span class="keyword">,</span> f t :: ys<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">)</span>
<span class="comment">// end of [reduce]
</span>          
<span class="keyword">and</span> next <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">IS</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">case+</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> ITEMatm t :: nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> t
  <span class="keyword">|</span> <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=&gt;</span> reduce <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>x :: xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=&gt;</span> resolve <span class="keyword">(</span>xs<span class="keyword">,</span> x<span class="keyword">,</span> ys<span class="keyword">)</span>
<span class="comment">// end of [next]
</span>
<span class="keyword">in</span>

next <span class="keyword">(</span>xs<span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>

<span class="keyword">end</span> <span class="comment">// end of [fixity_resolve]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_fixity.dats] *)</span>
</pre>
</body>
</html>
