<HTML>
<HEAD>
<STYLE TYPE="text/css">
span.comment {color:787878;font-style:italic}
span.extern  {color:A52A2A}
span.keyword {color:000000;font-weight:bold}
span.neuexp  {color:800080}
span.staexp  {color:0000FF}
span.dynexp  {color:E80000}
span.prfexp  {color:009000}
span.stacstdec  {text-decoration:none}
span.stacstuse  {color:0000CF;text-decoration:underline}
span.dyncstdec  {text-decoration:none}
span.dyncstimp  {color:B80000;text-decoration:underline}
span.dyncstuse  {color:B80000;text-decoration:underline}
</STYLE>
</HEAD>

<BODY BGCOLOR="#E0E0E0" TEXT="#E80000">
<PRE>
<span class="comment">(*
**
** An implementation of functional msets based on AVL trees.
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: October, 2008
**
*)</span>

<span class="comment">//
</span><span class="comment">// License: LGPL 3.0 (available at http://www.gnu.org/licenses/lgpl.txt)
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynamic loading
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">abstype</span> <span class="staexp"><A name="336"><span class="stacstdec">mset_t</span></span></A> <span class="keyword">(</span>elt<span class="keyword">:</span> t@ype<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="386"><span class="stacstdec">cmp <span class="keyword">(</span>elt<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>elt<span class="keyword">,</span> elt<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> Sgn</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  <A name="454"><span class="dyncstdec">compare_elt_elt <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Sgn</span></span></A>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> compare_elt_elt <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> cmp <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="601"><span class="stacstdec">cnt <span class="keyword">=</span> <span class="keyword">[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i <span class="keyword">&gt;</span> 0<span class="keyword">]</span> int i</span></span></A> <span class="comment">(* positive integers *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="keyword">}</span> <A name="667"><span class="dyncstdec">funmset_empty <span class="staexp"><span class="keyword">{</span>elt<span class="keyword">:</span>t@ype<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="735"><span class="dyncstdec">funmset_singleton <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="801"><span class="dyncstdec">funmset_size <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Nat</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="861"><span class="dyncstdec">funmset_member
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Nat</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="948"><span class="dyncstdec">funmset_is_member
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1039"><span class="dyncstdec">funmset_isnot_member
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1133"><span class="dyncstdec">funmset_insert
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1229"><span class="dyncstdec">funmset_remove
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t elt</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1323"><span class="dyncstdec">funmset_union
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1427"><span class="dyncstdec">funmset_intersect
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1535"><span class="dyncstdec">funmset_diff
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1638"><span class="dyncstdec">funmset_foreach_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>view<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1759"><span class="dyncstdec">funmset_foreach_cloref
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">mset_t elt</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">datatype</span> <span class="staexp"><A name="1874"><span class="stacstdec">avltree <span class="keyword">(</span>elt<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="comment">(*height*)</span><span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat</span> <span class="keyword">|</span> <span class="staexp">hl &lt;= hr+1</span><span class="keyword">;</span> <span class="staexp">hr &lt;= hl+1</span><span class="keyword">}</span>
    B <span class="staexp"><span class="keyword">(</span>elt<span class="keyword">,</span> max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">)</span></span> <span class="keyword">of</span>
      <span class="staexp"><span class="keyword">(</span>int <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">)</span><span class="keyword">,</span> elt<span class="keyword">,</span> cnt<span class="keyword">,</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span><span class="keyword">,</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> E <span class="staexp"><span class="keyword">(</span>elt<span class="keyword">,</span> 0<span class="keyword">)</span></span>

<span class="keyword">typedef</span> <span class="staexp"><A name="2081"><span class="stacstdec">avltree_inc <span class="keyword">(</span>elt<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h &lt;= h1<span class="keyword">;</span> h1 &lt;= h+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h1<span class="keyword">)</span></span></span></A>

<span class="keyword">typedef</span> <span class="staexp"><A name="2173"><span class="stacstdec">avltree_dec <span class="keyword">(</span>elt<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h1 &lt;= h<span class="keyword">;</span> h &lt;= h1+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h1<span class="keyword">)</span></span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">assume</span> <span class="staexp">mset_t <span class="keyword">(</span>elt<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span> funmset_empty <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> E <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_singleton <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> B <span class="keyword">(</span>1<span class="keyword">,</span> x<span class="keyword">,</span> 1<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> size <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Nat</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> _<span class="comment">(*x*)</span><span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> n + size <span class="keyword">(</span>tl<span class="keyword">)</span> + size <span class="keyword">(</span>tr<span class="keyword">)</span>
    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
  <span class="keyword">end</span> <span class="comment">// end of [size]
</span><span class="keyword">}</span> <span class="comment">// end of [funmset_size]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_member <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> mem <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> mem <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">Nat</span> <span class="keyword">=</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_elt_elt&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> mem tl <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> mem tr <span class="keyword">else</span> n
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="keyword">}</span> <span class="comment">// end of [funmset_member]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_is_member <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> funmset_member&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> true <span class="keyword">else</span> false
<span class="comment">// end of [funmset_is_member]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_isnot_member <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> funmset_member&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> false <span class="keyword">else</span> true
<span class="comment">// end of [funmset_isnot_member]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_height <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">int h</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> h <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="keyword">end</span> <span class="comment">// end of [avltree_height]
</span>
<span class="comment">(*
** left rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_lrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl+2 == hr<span class="keyword">}</span></span> <span class="keyword">(</span>
    x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">cnt</span><span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat <span class="keyword">|</span> hr &lt;= h<span class="keyword">;</span> h &lt;= hr+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>hr<span class="keyword">,</span> xr<span class="keyword">,</span> nr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr
  <span class="keyword">val</span> hrl <span class="keyword">=</span> avltree_height trl <span class="keyword">and</span> hrr <span class="keyword">=</span> avltree_height trr
<span class="keyword">in</span>
  <span class="keyword">if</span> hrl &lt;= hrr <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// hr = 1+hlr
</span>    B <span class="keyword">(</span>hrl+2<span class="keyword">,</span> xr<span class="keyword">,</span> nr<span class="keyword">,</span> B <span class="keyword">(</span>hrl+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> trl<span class="keyword">)</span><span class="keyword">,</span> trr<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// [hrl &gt; hrr]: deep rotation
</span>    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*hrl*)</span><span class="keyword">,</span> xrl<span class="keyword">,</span> nrl<span class="keyword">,</span> trll<span class="keyword">,</span> trlr<span class="keyword">)</span> <span class="keyword">=</span> trl
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hr<span class="keyword">,</span> xrl<span class="keyword">,</span> nrl<span class="keyword">,</span> B <span class="keyword">(</span>hrl<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> trll<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>hrl<span class="keyword">,</span> xr<span class="keyword">,</span> nr<span class="keyword">,</span> trlr<span class="keyword">,</span> trr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_lrotate]
</span>
<span class="comment">(*
** right rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_rrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl == hr+2<span class="keyword">}</span></span> <span class="keyword">(</span>
    x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">cnt</span><span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat <span class="keyword">|</span> hl &lt;= h<span class="keyword">;</span> h &lt;= hl+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>hl<span class="keyword">,</span> xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl
  <span class="keyword">val</span> hll <span class="keyword">=</span> avltree_height tll <span class="keyword">and</span> hlr <span class="keyword">=</span> avltree_height tlr
<span class="keyword">in</span>
  <span class="keyword">if</span> hll &gt;= hlr <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// hl = 1+hll
</span>    B <span class="keyword">(</span>hlr+2<span class="keyword">,</span> xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> B <span class="keyword">(</span>hlr+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tlr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// [hll &lt; hlr]: deep rotation
</span>    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*hlr*)</span><span class="keyword">,</span> xlr<span class="keyword">,</span> nlr<span class="keyword">,</span> tlrl<span class="keyword">,</span> tlrr<span class="keyword">)</span> <span class="keyword">=</span> tlr
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hl<span class="keyword">,</span> xlr<span class="keyword">,</span> nlr<span class="keyword">,</span> B <span class="keyword">(</span>hlr<span class="keyword">,</span> xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> tlrl<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>hlr<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tlrr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_rrotate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_insert <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> insert <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> insert <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_elt_elt&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tl <span class="keyword">=</span> insert <span class="keyword">(</span>tl<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span> + 1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+2
</span>            avltree_rrotate <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tr <span class="keyword">=</span> insert <span class="keyword">(</span>tr<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span>+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+1 = hr
</span>            avltree_lrotate <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          B <span class="keyword">(</span>h<span class="keyword">,</span> x<span class="keyword">,</span> n+1<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> B <span class="keyword">(</span>1<span class="keyword">,</span> x0<span class="keyword">,</span> 1<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [funmset_insert]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_takeout_min <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span>
  <span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>elt? &gt;&gt; elt</span>
  <span class="keyword">,</span> n0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>cnt? &gt;&gt; cnt</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_dec <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=</span> t
<span class="keyword">in</span>
  <span class="keyword">case+</span> tl <span class="keyword">of</span>
  <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> tl <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> n0<span class="keyword">)</span>
      <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
        B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 = hr
</span>       avltree_lrotate <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="comment">// end of [B]
</span>  <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>x0 := x<span class="keyword">;</span> n0 := n<span class="keyword">;</span> tr<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [avltree_takeout_min]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_remove <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> remove <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> removed<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>int? &gt;&gt; int i</span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>i<span class="keyword">:</span>two<span class="keyword">]</span> avltree_dec <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_elt_elt&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tl <span class="keyword">=</span> remove <span class="keyword">(</span>tl<span class="keyword">,</span> removed<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 == hr
</span>            avltree_lrotate <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tr <span class="keyword">=</span> remove <span class="keyword">(</span>tr<span class="keyword">,</span> removed<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+2
</span>            avltree_rrotate <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> removed := 1
        <span class="keyword">in</span>
          <span class="keyword">case+</span> 0 <span class="keyword">of</span>
          <span class="keyword">|</span> _ <span class="keyword">when</span> n <span class="keyword">&gt;</span> 1  <span class="keyword">=&gt;</span> B <span class="keyword">(</span>h<span class="keyword">,</span> x<span class="keyword">,</span> n-1<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">|</span> _ <span class="comment">(* n = 1 *)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> tr <span class="keyword">of</span>
            <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
                <span class="keyword">var</span> x_min<span class="keyword">:</span> <span class="staexp">elt</span> <span class="keyword">and</span> n_min<span class="keyword">:</span> <span class="staexp">cnt</span>
                <span class="keyword">val</span> tr <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tr<span class="keyword">,</span> x_min<span class="keyword">,</span> n_min<span class="keyword">)</span>
                <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
              <span class="keyword">in</span>
                <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
                  B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> x_min<span class="keyword">,</span> n_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 = hr
</span>                  avltree_rrotate <span class="keyword">(</span>x_min<span class="keyword">,</span> n_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="comment">// end of [if]
</span>              <span class="keyword">end</span> <span class="comment">// end of [B]
</span>            <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> tl
          <span class="keyword">end</span> <span class="comment">// end of [_]
</span>        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>removed := 0<span class="keyword">;</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [remove]
</span>  <span class="keyword">var</span> removed<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  remove <span class="keyword">(</span>t<span class="keyword">,</span> removed<span class="keyword">)</span> <span class="comment">// size = size (t) - removed
</span><span class="keyword">end</span> <span class="comment">// end of [funmset_remove]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
** left join: height(tl) &gt;= height(tr)
*)</span>
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  avltree_ljoin <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl &gt;= hr<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>hl<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">cnt</span><span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> hl - hr &gt;= 2 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="keyword">,</span> xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl
    <span class="keyword">val</span> tlr <span class="keyword">=</span> avltree_ljoin&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tlr<span class="keyword">,</span> tr<span class="keyword">)</span>
    <span class="keyword">val</span> hll <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tll<span class="keyword">)</span> <span class="keyword">and</span> hlr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tlr<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> hlr - hll &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
      B <span class="keyword">(</span>max<span class="keyword">(</span>hll<span class="keyword">,</span>hlr<span class="keyword">)</span>+1<span class="keyword">,</span> xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hll+2 = hlr
</span>      avltree_lrotate <span class="keyword">(</span>xl<span class="keyword">,</span> nl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    B <span class="keyword">(</span>hl+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_ljoin]
</span>
<span class="comment">(*
** right join: height(tl) &lt;= height(tr)
*)</span>
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  avltree_rjoin <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl &lt;= hr<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>hr<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">cnt</span><span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> hr - hl &gt;= 2 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="keyword">,</span> xr<span class="keyword">,</span> nr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr
    <span class="keyword">val</span> trl <span class="keyword">=</span> avltree_rjoin&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> trl<span class="keyword">)</span>
    <span class="keyword">val</span> hrl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>trl<span class="keyword">)</span> <span class="keyword">and</span> hrr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>trr<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> hrl - hrr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
      B <span class="keyword">(</span>max<span class="keyword">(</span>hrl<span class="keyword">,</span>hrr<span class="keyword">)</span>+1<span class="keyword">,</span> xr<span class="keyword">,</span> nr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hrl = hrr+2
</span>      avltree_rrotate <span class="keyword">(</span>xr<span class="keyword">,</span> nr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    B <span class="keyword">(</span>hr+1<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_rjoin]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_join <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">elt</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">cnt</span><span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>int <span class="keyword">|</span> hl &lt;= h<span class="keyword">;</span> hr &lt;= h<span class="keyword">;</span> h &lt;= max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
<span class="keyword">in</span>
  <span class="keyword">if</span> hl &gt;= hr <span class="keyword">then</span>
    avltree_ljoin <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
  <span class="keyword">else</span>
    avltree_rjoin <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [avltree_join]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_concat <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span><span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat <span class="keyword">|</span> h &lt;= max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> tr
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> tl
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">let</span>
      <span class="keyword">var</span> x_min<span class="keyword">:</span> <span class="staexp">elt</span> <span class="keyword">and</span> n_min<span class="keyword">:</span> <span class="staexp">cnt</span> <span class="comment">// uninitialized
</span>      <span class="keyword">val</span> tr <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tr<span class="keyword">,</span> x_min<span class="keyword">,</span> n_min<span class="keyword">)</span>
    <span class="keyword">in</span>
      avltree_join <span class="keyword">(</span>x_min<span class="keyword">,</span> n_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_, _]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_concat]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="10962"><span class="stacstdec">avltree <span class="keyword">=</span> avltree <span class="keyword">(</span>void<span class="keyword">,</span> 0<span class="keyword">)</span></span></span></A>

<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">elt<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  avltree_split_at <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">elt</span>
  <span class="keyword">,</span> tl0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>avltree? &gt;&gt; avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hl<span class="keyword">)</span></span>
  <span class="keyword">,</span> tr0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>avltree? &gt;&gt; avltree <span class="keyword">(</span>elt<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp elt</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">#[</span>i<span class="keyword">:</span>nat<span class="keyword">;</span> hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl &lt;= h<span class="keyword">;</span> hr &lt;= h<span class="keyword">]</span> int i</span> <span class="keyword">=</span>
  <span class="keyword">case</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_elt_elt&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="keyword">val</span> i <span class="keyword">=</span> avltree_split_at <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">,</span> tl0<span class="keyword">,</span> tr0<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        tr0 := avltree_join <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tr0<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">;</span> i
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="keyword">val</span> i <span class="keyword">=</span> avltree_split_at <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">,</span> tl0<span class="keyword">,</span> tr0<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        tl0 := avltree_join <span class="keyword">(</span>x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tl0<span class="keyword">)</span><span class="keyword">;</span> i
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        tl0 := tl<span class="keyword">;</span> tr0 := tr<span class="keyword">;</span> n <span class="comment">// [x] is found in [t]
</span>      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="comment">// end of [B]
</span>  <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>tl0 := E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> tr0 := E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> 0<span class="keyword">)</span>
<span class="comment">// end of [avltree_split_at]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_union <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> uni <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> uni <span class="staexp"><span class="keyword">{</span>h1<span class="keyword">,</span>h2<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h1<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t1<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h1<span class="keyword">)</span></span><span class="keyword">,</span> t2<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h2<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">case+</span> <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> t2 <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> t1 <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*h1*)</span><span class="keyword">,</span> x1<span class="keyword">,</span> n1<span class="keyword">,</span> t1l<span class="keyword">,</span> t1r<span class="keyword">)</span> <span class="keyword">=</span> t1
        <span class="keyword">var</span> t2l0<span class="keyword">:</span> <span class="staexp">avltree?</span> <span class="keyword">and</span> t2r0<span class="keyword">:</span> <span class="staexp">avltree?</span>
        <span class="keyword">val+</span> i <span class="keyword">=</span> avltree_split_at <span class="keyword">(</span>t2<span class="keyword">,</span> x1<span class="keyword">,</span> t2l0<span class="keyword">,</span> t2r0<span class="keyword">,</span> cmp<span class="keyword">)</span>
        <span class="keyword">val</span> t12l <span class="keyword">=</span> uni <span class="keyword">(</span>t1l<span class="keyword">,</span> t2l0<span class="keyword">)</span> <span class="keyword">and</span> t12r <span class="keyword">=</span> uni <span class="keyword">(</span>t1r<span class="keyword">,</span> t2r0<span class="keyword">)</span>
      <span class="keyword">in</span>
        avltree_join <span class="keyword">(</span>x1<span class="keyword">,</span> n1 + i<span class="keyword">,</span> t12l<span class="keyword">,</span> t12r<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_, _]
</span>    <span class="comment">// end of [uni]
</span><span class="keyword">}</span> <span class="comment">// end of [funmset_union]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_intersect <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> inter <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> inter <span class="staexp"><span class="keyword">{</span>h1<span class="keyword">,</span>h2<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h1<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t1<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h1<span class="keyword">)</span></span><span class="keyword">,</span> t2<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h2<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*h1*)</span><span class="keyword">,</span> x1<span class="keyword">,</span> n1<span class="keyword">,</span> t1l<span class="keyword">,</span> t1r<span class="keyword">)</span> <span class="keyword">=</span> t1
        <span class="keyword">var</span> t2l0<span class="keyword">:</span> <span class="staexp">avltree?</span> <span class="keyword">and</span> t2r0<span class="keyword">:</span> <span class="staexp">avltree?</span>
        <span class="keyword">val+</span> i <span class="keyword">=</span> avltree_split_at <span class="keyword">(</span>t2<span class="keyword">,</span> x1<span class="keyword">,</span> t2l0<span class="keyword">,</span> t2r0<span class="keyword">,</span> cmp<span class="keyword">)</span>
        <span class="keyword">val</span> t12l <span class="keyword">=</span> inter <span class="keyword">(</span>t1l<span class="keyword">,</span> t2l0<span class="keyword">)</span> <span class="keyword">and</span> t12r <span class="keyword">=</span> inter <span class="keyword">(</span>t1r<span class="keyword">,</span> t2r0<span class="keyword">)</span>
        <span class="keyword">val</span> n1 <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">if</span> n1 &lt;= i <span class="keyword">then</span> n1 <span class="keyword">else</span> i<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Nat</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> n1 <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
          avltree_concat <span class="keyword">(</span>t12l<span class="keyword">,</span> t12r<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          avltree_join <span class="keyword">(</span>x1<span class="keyword">,</span> n1<span class="keyword">,</span> t12l<span class="keyword">,</span> t12r<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [_, _]
</span>    <span class="keyword">end</span> <span class="comment">// end of [inter]
</span><span class="keyword">}</span> <span class="comment">// end of [funmset_intersect]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span> funmset_diff <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> diff <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> diff <span class="staexp"><span class="keyword">{</span>h1<span class="keyword">,</span>h2<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h1<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t1<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h1<span class="keyword">)</span></span><span class="keyword">,</span> t2<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h2<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span>
    <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">(</span>t1<span class="keyword">,</span> t2<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> t1 <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*h1*)</span><span class="keyword">,</span> x1<span class="keyword">,</span> n1<span class="keyword">,</span> t1l<span class="keyword">,</span> t1r<span class="keyword">)</span> <span class="keyword">=</span> t1
        <span class="keyword">var</span> t2l0<span class="keyword">:</span> <span class="staexp">avltree?</span> <span class="keyword">and</span> t2r0<span class="keyword">:</span> <span class="staexp">avltree?</span>
        <span class="keyword">val+</span> i <span class="keyword">=</span> avltree_split_at <span class="keyword">(</span>t2<span class="keyword">,</span> x1<span class="keyword">,</span> t2l0<span class="keyword">,</span> t2r0<span class="keyword">,</span> cmp<span class="keyword">)</span>
        <span class="keyword">val</span> t12l <span class="keyword">=</span> diff <span class="keyword">(</span>t1l<span class="keyword">,</span> t2l0<span class="keyword">)</span> <span class="keyword">and</span> t12r <span class="keyword">=</span> diff <span class="keyword">(</span>t1r<span class="keyword">,</span> t2r0<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> n1 &lt;= i <span class="keyword">then</span> <span class="keyword">begin</span>
          avltree_concat <span class="keyword">(</span>t12l<span class="keyword">,</span> t12r<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          avltree_join <span class="keyword">(</span>x1<span class="keyword">,</span> n1 - i<span class="keyword">,</span> t12l<span class="keyword">,</span> t12r<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [_, _]
</span>    <span class="keyword">end</span> <span class="comment">// end of [diff]
</span><span class="keyword">}</span> <span class="comment">// end of [funmset_diff]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span>
  funmset_foreach_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">typedef</span> <span class="staexp"><A name="14147"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>clo_type</span><span class="keyword">,</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>elt<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> x<span class="keyword">,</span> n<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="comment">(* inorder traversal *)</span>
        aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tl<span class="keyword">)</span><span class="keyword">;</span> f <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> x<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span><span class="keyword">}</span> <span class="comment">// end of [funmset_foreach_clo]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">elt</span><span class="keyword">}</span>
  funmset_foreach_cloref <span class="keyword">(</span>t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> f <span class="keyword">=</span> __cast <span class="keyword">(</span>f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span> <span class="keyword">extern</span> <span class="keyword">castfn</span> <A name="14607"><span class="dyncstdec">__cast
    <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">typedef</span> <span class="staexp"><A name="14718"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> elt<span class="keyword">,</span> cnt<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">vbox pf_f</span> <span class="keyword">|</span> p_f<span class="keyword">)</span> <span class="keyword">=</span> cloref_get_view_ptr <span class="staexp"><span class="keyword">{</span>clo_type<span class="keyword">}</span></span> <span class="keyword">(</span>f<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> funmset_foreach_clo&lt;<span class="staexp">elt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="keyword">!</span>p_f<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [funmset_foreach_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [funmset_avltree.dats] *)</span>
</PRE>
</BODY>
</HTML>
