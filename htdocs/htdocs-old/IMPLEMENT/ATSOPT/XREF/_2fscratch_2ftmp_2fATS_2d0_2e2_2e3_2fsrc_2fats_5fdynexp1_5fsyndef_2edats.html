<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//
</span><span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: August 2007
</span><span class="comment">//
</span><span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Loc <span class="keyword">=</span> "ats_location.sats"</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="1593"><span class="stacstdec">loc_t <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_t</span></a></span>
<span class="keyword">staload</span> <span class="staexp">Lst <span class="keyword">=</span> "ats_list.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Sym <span class="keyword">=</span> "ats_symbol.sats"</span>
<span class="keyword">typedef</span> <span class="staexp"><a name="1687"><span class="stacstdec">sym_t <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_t</span></a></span>
<span class="neuexp"><span class="keyword">overload</span> <span class="keyword">=</span> <span class="keyword">with</span> $Sym<span class="keyword">.</span>eq_symbol_symbol</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_staexp1.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_dynexp1.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_dynexp1_syndef.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
dynload "libatsyndef/atsyndef_main.dats"
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">nil list_nil</span>
<span class="keyword">#define</span> <span class="neuexp">cons list_cons</span>
<span class="keyword">#define</span> <span class="neuexp">:: list_cons</span>

<span class="keyword">macdef</span> <span class="neuexp">list_sing <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> list_cons <span class="keyword">(</span><span class="keyword">,(</span>x<span class="keyword">)</span><span class="keyword">,</span> list_nil<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> prerr_loc_error1
  <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>$Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": error(1)"<span class="keyword">)</span>
<span class="comment">// end of [prerr_loc_error1]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
fprint_intlst
  <span class="keyword">(</span>out<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop <span class="keyword">(</span>
    out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> ns <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>n<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
          fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> ", "<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_int <span class="keyword">(</span>out<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">in</span>
        loop <span class="keyword">(</span>out<span class="keyword">,</span> ns<span class="keyword">,</span> i+1<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [loop]
</span><span class="keyword">in</span>
  loop <span class="keyword">(</span>out<span class="keyword">,</span> ns<span class="keyword">,</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_intlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
//
// n &gt;= 0 means exact n
// n &lt;  0 means at least (~n-1)
//
*)</span>

<span class="keyword">implement</span>
match_intlst_intlst <span class="keyword">(</span>ns1<span class="keyword">,</span> ns2<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> ns1 <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>n1<span class="keyword">,</span> ns1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">case+</span> ns2 <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>n2<span class="keyword">,</span> ns2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
        <span class="keyword">if</span> n2 &gt;= 0 <span class="keyword">then</span>
          <span class="keyword">(</span><span class="keyword">if</span> <span class="keyword">(</span>n1 <span class="keyword">=</span> n2<span class="keyword">)</span> <span class="keyword">then</span> match_intlst_intlst <span class="keyword">(</span>ns1<span class="keyword">,</span> ns2<span class="keyword">)</span> <span class="keyword">else</span> false<span class="keyword">)</span>
        <span class="keyword">else</span> <span class="keyword">if</span> n2 &lt;= ~2 <span class="keyword">then</span>
          <span class="keyword">(</span><span class="keyword">if</span> <span class="keyword">(</span>n1 + 1 &gt;= <span class="keyword">~</span>n2<span class="keyword">)</span> <span class="keyword">then</span> match_intlst_intlst <span class="keyword">(</span>ns1<span class="keyword">,</span> ns2<span class="keyword">)</span> <span class="keyword">else</span> false<span class="keyword">)</span>
        <span class="keyword">else</span> <span class="keyword">(</span>
          match_intlst_intlst <span class="keyword">(</span>ns1<span class="keyword">,</span> ns2<span class="keyword">)</span>
        <span class="keyword">)</span> <span class="comment">// end of [if]
</span>      <span class="keyword">)</span> <span class="comment">// end of [list_cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
    <span class="keyword">)</span> <span class="comment">// end of [cons]
</span>  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> ns2 <span class="keyword">of</span> list_cons _ <span class="keyword">=&gt;</span> false <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
    <span class="keyword">)</span> <span class="comment">// end of [list_nil]
</span><span class="comment">// end of [match_intlst_intlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
tmpqi0de_make_qid
  <span class="keyword">(</span>loc<span class="keyword">,</span> q<span class="keyword">,</span> id<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  tmpqi0de_loc<span class="keyword">=</span> loc<span class="keyword">,</span> tmpqi0de_qua<span class="keyword">=</span> q<span class="keyword">,</span> tmpqi0de_sym<span class="keyword">=</span> id
<span class="keyword">}</span> <span class="comment">// end of [tmpqi0de_make_qid]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
un_d1exp_ann_type
  <span class="keyword">(</span>d1e<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Eann_type <span class="keyword">(</span>d1e<span class="keyword">,</span> s1e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>d1e<span class="keyword">,</span> s1e<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the dynexp is expected be some annotated expression."
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      $Err<span class="keyword">.</span>abort <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [un_d1exp_ann_type]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
un_d1exp_idext <span class="keyword">(</span>d1e<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Eidextapp <span class="keyword">(</span>id<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> id
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the dynexp is expected to be some external identifer."
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>sym_t<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [un_d1exp_idext]
</span>
<span class="keyword">implement</span>
un_d1exp_idext_sym
  <span class="keyword">(</span>d1e<span class="keyword">,</span> sym0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sym <span class="keyword">=</span> un_d1exp_idext <span class="keyword">(</span>d1e<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> $Sym<span class="keyword">.</span>eq_symbol_symbol
    <span class="keyword">(</span>sym0<span class="keyword">,</span> sym<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
      prerr ": the external id ["<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol <span class="keyword">(</span>sym0<span class="keyword">)</span><span class="keyword">;</span> prerr "] is expected."
    <span class="keyword">)</span> <span class="comment">// end of [val]
</span>    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">in</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
<span class="keyword">end</span> <span class="comment">// end of [un_d1exp_idext_sym]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
un_d1exp_qid <span class="keyword">(</span>d1e<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Eqid <span class="keyword">(</span>q<span class="keyword">,</span> id<span class="keyword">)</span> <span class="keyword">=&gt;</span>  <span class="keyword">(</span>q<span class="keyword">,</span> id<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the dynexp is expected be some (qualified) identifier."
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      $Err<span class="keyword">.</span>abort <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [un_d1exp_qid]
</span>
<span class="keyword">implement</span>
un_d1exp_qid_sym
  <span class="keyword">(</span>d1e<span class="keyword">,</span> sym0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span>q<span class="keyword">,</span> sym<span class="keyword">)</span> <span class="keyword">=</span> un_d1exp_qid <span class="keyword">(</span>d1e<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> $Sym<span class="keyword">.</span>eq_symbol_symbol
    <span class="keyword">(</span>sym0<span class="keyword">,</span> sym<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
      prerr ": the symbol ["<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol <span class="keyword">(</span>sym0<span class="keyword">)</span><span class="keyword">;</span> prerr "] is expected."
    <span class="keyword">)</span> <span class="comment">// end of [val]
</span>    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">in</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
<span class="keyword">end</span> <span class="comment">// end of [un_d1exp_qid_sym]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
un_d1exp_sexparg <span class="keyword">(</span>d1e<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Esexparg s1a <span class="keyword">=&gt;</span> s1a
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the dynexp is expected to be a static argument."
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>s1exparg<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [un_d1exp_sexparg]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
un_d1exp_decseq <span class="keyword">(</span>d1e<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Edecseq <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> d1cs
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error1 <span class="keyword">(</span>d1e<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the dynexp is expected to be a list of declarations."
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d1eclst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [un_d1exp_decseq]
</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//
</span><span class="comment">// HX-2010-11-02:
</span><span class="comment">// this function is implemented in
</span><span class="comment">// $ATSHOME/utils/syndef/atsyndef_main.dats
</span><span class="comment">//
</span><span class="keyword">typedef</span>
<span class="staexp"><a name="6352"><span class="stacstdec">atsyndef_search_all_type <span class="keyword">=</span>
  <span class="keyword">(</span>sym_t<span class="keyword">,</span> intlst<span class="keyword">)</span> <span class="keyword">-&lt;</span>fun1<span class="keyword">&gt;</span> Option_vt <span class="keyword">(</span>fsyndef<span class="keyword">)</span></span></a></span>
<span class="comment">(*
//
// HX: this style is not supported in ATS/Geizella
//
extern
fun atsyndef_search_all : atsyndef_search_all_type
// end of [extern]
*)</span>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="6576"><span class="dyncstdec">atsyndef_search_all
  <span class="keyword">(</span>_<span class="keyword">:</span> <span class="staexp">sym_t</span><span class="keyword">,</span> _<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">fun1</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt <span class="keyword">(</span>fsyndef<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [extern]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">val</span> _n1 <span class="keyword">=</span> <span class="keyword">(</span>~1 :: nil<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intlst</span>
<span class="keyword">val</span> _n1_p1 <span class="keyword">=</span> <span class="keyword">(</span>~1 :: 1 :: nil<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intlst</span> <span class="comment">// while ($test) 
</span><span class="keyword">val</span> _n1_p1_n1 <span class="keyword">=</span>
  <span class="keyword">(</span>~1 :: 1 :: ~1 :: nil<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intlst</span> <span class="comment">// do ($body) while ($test)
</span><span class="keyword">val</span> _n2 <span class="keyword">=</span> <span class="keyword">(</span>~2 :: nil<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intlst</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">macdef</span> <span class="neuexp">matii <span class="keyword">=</span> match_intlst_intlst</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="6971"><span class="dyncstdec">search_DO
  <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="7019"><span class="dyncstdec">d1exp_do_n1_p1_n1
  <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="comment">// end of [d1exp_do_n1_p1_n1]
</span>
<span class="keyword">implement</span>
search_DO <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "search_DO: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n1_p1_n1 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_do_n1_p1_n1<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_DO]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="7406"><span class="dyncstdec">search_WHILE
  <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="7457"><span class="dyncstdec">d1exp_while_n1_p1
  <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="comment">// end of [d1exp_while_n1_p1]
</span>
<span class="keyword">implement</span>
search_WHILE <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "search_WHILE: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n1_p1 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_while_n1_p1<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_WHILE]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="7850"><span class="dyncstdec">search_PRINT <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="7899"><span class="dyncstdec">d1exp_print_n1 <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="keyword">implement</span>
search_PRINT <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "print_search: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n1 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_print_n1<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_PRINT]
</span>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="8229"><span class="dyncstdec">search_PRINTLN  <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="8281"><span class="dyncstdec">d1exp_println_n1 <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="keyword">implement</span>
search_PRINTLN <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "search_PRINTLN: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n1 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_println_n1<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_PRINTLN]
</span>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="8621"><span class="dyncstdec">search_FPRINT <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="8671"><span class="dyncstdec">d1exp_fprint_n2 <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="keyword">implement</span>
search_FPRINT <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "search_FPRINT: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n2 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_fprint_n2<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_FPRINT]
</span>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="9006"><span class="dyncstdec">search_FPRINTLN <span class="keyword">(</span>ns<span class="keyword">:</span> <span class="staexp">intlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">fsyndefopt</span></span></a>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="9058"><span class="dyncstdec">d1exp_fprintln_n2 <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d1exp</span></span></a>
<span class="keyword">implement</span>
search_FPRINTLN <span class="keyword">(</span>ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "search_FPRINTLN: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> ns <span class="keyword">\</span>matii _n2 <span class="keyword">=&gt;</span> Some_vt <span class="keyword">(</span>d1exp_fprintln_n2<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [search_FPRINTLN]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">val</span> symbol_DO <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_DO
<span class="keyword">val</span> symbol_WHILE <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_WHILE
<span class="keyword">val</span> symbol_PRINT <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"print"<span class="keyword">)</span>
<span class="keyword">val</span> symbol_PRINTLN <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"println"<span class="keyword">)</span>
<span class="keyword">val</span> symbol_FPRINT <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"fprint"<span class="keyword">)</span>
<span class="keyword">val</span> symbol_FPRINTLN <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"fprintln"<span class="keyword">)</span>

<span class="keyword">implement</span>
atsyndef_search_all_default
  <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "atsyndef_search_all_default: id = "
  val () = $Sym.print_symbol (id)
  val () = print_newline ()
  val () = print "atsyndef_search_all_default: ns = "
  val () = fprint_intlst (stdout_ref, ns)
  val () = print_newline ()
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> 0 <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_DO <span class="keyword">=&gt;</span> search_DO <span class="keyword">(</span>ns<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_WHILE <span class="keyword">=&gt;</span> search_WHILE <span class="keyword">(</span>ns<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_PRINT <span class="keyword">=&gt;</span> search_PRINT <span class="keyword">(</span>ns<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_PRINTLN <span class="keyword">=&gt;</span> search_PRINTLN <span class="keyword">(</span>ns<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_FPRINT <span class="keyword">=&gt;</span> search_FPRINT <span class="keyword">(</span>ns<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> symbol_FPRINTLN <span class="keyword">=&gt;</span> search_FPRINTLN <span class="keyword">(</span>ns<span class="keyword">)</span>
<span class="comment">(*
// HX-2010-11-15:
// how should I judge whether a new external symbol should be supported?
*)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [atsyndef_search_all_default]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
// HX: compile with the -DATS_SYNDEFATS flag
#define _SYNDEFATS 1
*)</span>
<span class="keyword">#if</span> <span class="neuexp">defined<span class="keyword">(</span>_SYNDEFATS<span class="keyword">)</span></span> <span class="keyword">#then</span>
<span class="comment">//
</span><span class="keyword">local</span>
<span class="comment">//
</span><span class="keyword">staload</span> <span class="staexp">"libc/SATS/dlfcn.sats"</span>
<span class="comment">//
</span><span class="keyword">val</span> finit_name <span class="keyword">=</span> "atsyndef_initialize"
<span class="keyword">var</span> finit_ptr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">=</span> null
<span class="comment">//
</span><span class="keyword">val</span> fsrch_name <span class="keyword">=</span> "atsyndef_search_all"
<span class="keyword">var</span> fsrch_ptr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">=</span> null
<span class="comment">//
</span><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfopt_lib</span> <span class="keyword">|</span> p_lib<span class="keyword">)</span> <span class="keyword">=</span>
  dlopen <span class="keyword">(</span>"libatsyndef.so"<span class="keyword">,</span> RTLD_LAZY<span class="keyword">)</span>
<span class="comment">// end of [val]
</span><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span>
p_lib <span class="keyword">&gt;</span> null <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>prerr "\
ATS/Anairiats: [libatsyndef.so] is available to support syndef-loaded external ids.\n\
"
  <span class="keyword">)</span> <span class="comment">// end of [val]
</span>  <span class="keyword">prval</span> <span class="prfexp">Some_v <span class="keyword">(</span>pf_lib<span class="keyword">)</span> <span class="keyword">=</span> pfopt_lib</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> dlerror_clr <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> finit_ptr := dlsym <span class="keyword">(</span><span class="prfexp">pf_lib</span> <span class="keyword">|</span> p_lib<span class="keyword">,</span> finit_name<span class="keyword">)</span>
<span class="comment">(*
  val (fpf_msg | msg) = dlerror () // clearing any existing error
  val () = (
    print "atsyndef_search_all: finit: "; print msg; print_newline ()
  ) // end of [val]
  prval () = fpf_msg (msg)
*)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> dlerror_clr <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fsrch_ptr := dlsym <span class="keyword">(</span><span class="prfexp">pf_lib</span> <span class="keyword">|</span> p_lib<span class="keyword">,</span> fsrch_name<span class="keyword">)</span>
<span class="comment">(*
  val (fpf_msg | msg) = dlerror () // see if there is any error
  val () = (
    print "atsyndef_search_all: fsrch = "; print msg; print_newline ()
  ) // end of [val]
  prval () = fpf_msg (msg)
*)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> dlclose_exn <span class="keyword">(</span><span class="prfexp">pf_lib</span> <span class="keyword">|</span> p_lib<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="comment">// nothing
</span><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>prerr "\
ATS/Anairiats: [libatsyndef.so] is not available to support syndef-loaded external ids.\n\
"
  <span class="keyword">)</span> <span class="comment">// end of [val]
</span>  <span class="keyword">prval</span> <span class="prfexp">None_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pfopt_lib</span>
<span class="keyword">in</span>
  <span class="comment">// nothing
</span><span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="comment">//
</span><span class="keyword">val</span> finit_ptr <span class="keyword">=</span> finit_ptr
<span class="keyword">val</span> fsrch_ptr <span class="keyword">=</span> fsrch_ptr
<span class="comment">//
</span><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span>
  finit_ptr <span class="keyword">&gt;</span> null <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="keyword">val</span> finit <span class="keyword">=</span> __cast <span class="keyword">(</span>finit_ptr<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">extern</span> <span class="keyword">castfn</span> <a name="12075"><span class="dyncstdec">__cast <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="comment">(*none*)</span><span class="keyword">)</span> <span class="keyword">-&lt;</span>fun1<span class="keyword">&gt;</span> void</span></span></a>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span><span class="keyword">in</span>
  finit <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [val]
</span>
<span class="keyword">in</span> <span class="comment">// in of [local]
</span>
<span class="keyword">implement</span>
atsyndef_search_all
  <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> atsyndef_search_all_default <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> ans <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>None_vt _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">case+</span> 0 <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> fsrch_ptr <span class="keyword">&gt;</span> null <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> fsrch <span class="keyword">=</span> __cast <span class="keyword">(</span>fsrch_ptr<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
          <span class="keyword">extern</span> <span class="keyword">castfn</span> <a name="12446"><span class="dyncstdec">__cast <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">atsyndef_search_all_type</span></span></a>
        <span class="keyword">}</span> <span class="comment">// end of [_ when ...]
</span>      <span class="keyword">in</span>
        fsrch <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">)</span> <span class="comment">// end of [None_vt]
</span>  <span class="keyword">|</span> Some_vt _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ ans<span class="keyword">;</span> ans<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [atsyndef_search_all]
</span>
<span class="keyword">end</span>  <span class="comment">// end of [local]
</span>
<span class="keyword">#else</span> <span class="comment">// else of [_SYNDEFATS]
</span>
<span class="keyword">implement</span>
atsyndef_search_all
  <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=</span> atsyndef_search_all_default <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span>
<span class="comment">// end of [atsyndef_search_all]
</span>
<span class="keyword">#endif</span> <span class="comment">// end of [_SYNDEFATS]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_idextapp_resolve
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Eidextapp <span class="keyword">(</span>
      id<span class="keyword">,</span> _<span class="comment">(*ns*)</span><span class="keyword">,</span> d1es_arg
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> 0 <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> id <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TUPZ <span class="keyword">=&gt;</span>
        d1exp_list <span class="keyword">(</span>loc0<span class="keyword">,</span> $Lst<span class="keyword">.</span>list_reverse <span class="keyword">(</span>d1es_arg<span class="keyword">)</span><span class="keyword">)</span>
      <span class="comment">// end of [_ when ...]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> d1e
    <span class="keyword">end</span> <span class="comment">// end of [D1Eidextapp]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> d1e <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [d1exp_idextapp_resolve]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_app_syndef <span class="keyword">(</span>
  loc0<span class="keyword">,</span> d1e_fun<span class="keyword">,</span> d1e_arg
<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d1e_fun<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Eidextapp
      <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">,</span> arglst<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> n <span class="keyword">=</span> <span class="keyword">(</span>
        <span class="keyword">case+</span> d1e_arg<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
        <span class="keyword">|</span> D1Elist <span class="keyword">(</span>_<span class="comment">(*npf*)</span><span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> $Lst<span class="keyword">.</span>list_length <span class="keyword">(</span>d1es<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> 1
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> ns <span class="keyword">=</span> cons <span class="keyword">(</span>n<span class="keyword">,</span> ns<span class="keyword">)</span>
      <span class="keyword">val</span> arglst <span class="keyword">=</span> cons <span class="keyword">(</span>d1e_arg<span class="keyword">,</span> arglst<span class="keyword">)</span>
      <span class="keyword">val</span> opt <span class="keyword">=</span> atsyndef_search_all <span class="keyword">(</span>id<span class="keyword">,</span> ns<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> opt <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">~</span>Some_vt <span class="keyword">(</span>fsyndef<span class="keyword">)</span> <span class="keyword">=&gt;</span> fsyndef <span class="keyword">(</span>loc0<span class="keyword">,</span> arglst<span class="keyword">)</span>
      <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d1exp_idextapp <span class="keyword">(</span>loc0<span class="keyword">,</span> id<span class="keyword">,</span> ns<span class="keyword">,</span> arglst<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Eidexpapp]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">case+</span> d1e_arg<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elist <span class="keyword">(</span>npf<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        d1exp_app_dyn <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e_fun<span class="keyword">,</span> d1e_arg<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> npf<span class="keyword">,</span> d1es<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D1Elist]
</span>    <span class="keyword">|</span> D1Esexparg s1a <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">case+</span> d1e_fun<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
      <span class="keyword">|</span> D1Eapp_sta <span class="keyword">(</span>d1e_fun<span class="keyword">,</span> s1as<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          d1exp_app_sta <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e_fun<span class="keyword">,</span> $Lst<span class="keyword">.</span>list_extend <span class="keyword">(</span>s1as<span class="keyword">,</span> s1a<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [D1Eapp_sta]
</span>      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> s1as <span class="keyword">=</span>  cons <span class="keyword">(</span>s1a<span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">in</span> d1exp_app_sta <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e_fun<span class="keyword">,</span> s1as<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">)</span> <span class="comment">// end of [D1Esexparg]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> npf <span class="keyword">=</span> 0 <span class="keyword">and</span> d1es <span class="keyword">=</span> cons <span class="keyword">(</span>d1e_arg<span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">in</span>
        d1exp_app_dyn <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e_fun<span class="keyword">,</span> d1e_arg<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> npf<span class="keyword">,</span> d1es<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_]    
</span>    <span class="keyword">)</span> <span class="comment">// end of [_]
</span><span class="comment">// end of [d1exp_app_syndef]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> d1exp_applstseq <span class="keyword">(</span>
  loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
<span class="keyword">,</span> d1es<span class="keyword">:</span> <span class="staexp">d1explst</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span><span class="keyword">(</span>d1exp<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloptr1<span class="keyword">&gt;</span> d1exp</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d1exp</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> mapf <span class="keyword">(</span>
    d1es<span class="keyword">:</span> <span class="staexp">d1explst</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span><span class="keyword">(</span>d1exp<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloptr1<span class="keyword">&gt;</span> d1exp</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d1explst</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> d1es <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>d1e<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_cons <span class="keyword">(</span>f <span class="keyword">(</span>d1e<span class="keyword">)</span><span class="keyword">,</span> mapf <span class="keyword">(</span>d1es<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [mapf]
</span><span class="keyword">in</span>
  d1exp_seq <span class="keyword">(</span>loc0<span class="keyword">,</span> mapf <span class="keyword">(</span>d1es<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [d1exp_applstseq]
</span>
<span class="keyword">fun</span> d1exp_appseq <span class="keyword">(</span>
  loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
<span class="keyword">,</span> d1e<span class="keyword">:</span> <span class="staexp">d1exp</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span><span class="keyword">(</span>d1exp<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloptr1<span class="keyword">&gt;</span> d1exp</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d1exp</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Elist <span class="keyword">(</span>_<span class="comment">(*npf*)</span><span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> d1exp_applstseq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">,</span> f<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> f <span class="keyword">(</span>d1e<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [d1exp_appseq]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_do_n1_p1_n1
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span>  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e3<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> d1es
<span class="comment">//
</span>  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e2<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> un_d1exp_idext_sym <span class="keyword">(</span>d1e2<span class="keyword">,</span> $Sym<span class="keyword">.</span>symbol_WHILE<span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e1<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> d1es
<span class="comment">//
</span>  <span class="keyword">val</span> _then <span class="keyword">=</span> d1exp_loopexn <span class="keyword">(</span>loc0<span class="keyword">,</span> 1<span class="keyword">)</span> <span class="comment">// continue
</span>  <span class="keyword">val</span> _else <span class="keyword">=</span> Some <span class="keyword">(</span>d1exp_loopexn <span class="keyword">(</span>loc0<span class="keyword">,</span> 0<span class="keyword">)</span><span class="keyword">)</span> <span class="comment">// break
</span><span class="comment">//
</span>  <span class="keyword">val</span> loc3 <span class="keyword">=</span> d1e3<span class="keyword">.</span>d1exp_loc
  <span class="keyword">val</span> _ifexp <span class="keyword">=</span> d1exp_if <span class="keyword">(</span>loc3<span class="keyword">,</span> i1nvresstate_nil<span class="keyword">,</span> d1e3<span class="keyword">,</span> _then<span class="keyword">,</span> _else<span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">val</span> _inv <span class="keyword">=</span> loopi1nv_nil <span class="keyword">(</span>loc0<span class="keyword">)</span>
  <span class="keyword">val</span> _true <span class="keyword">=</span> d1exp_bool <span class="keyword">(</span>loc0<span class="keyword">,</span> true<span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">val</span> _body <span class="keyword">=</span> d1exp_seq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e1 :: _ifexp :: nil<span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">in</span>
  d1exp_while <span class="keyword">(</span>loc0<span class="keyword">,</span> _inv<span class="keyword">,</span> _true<span class="keyword">,</span> _body<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [do_n1_p1_n1]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_while_n1_p1
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span>  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e2<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> _body <span class="keyword">=</span> d1e2
<span class="comment">//
</span>  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e1<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> _test <span class="keyword">=</span> d1e1
<span class="comment">//
</span>  <span class="keyword">val</span> _inv <span class="keyword">=</span> loopi1nv_nil <span class="keyword">(</span>loc0<span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">in</span>
  d1exp_while <span class="keyword">(</span>loc0<span class="keyword">,</span> _inv<span class="keyword">,</span> _test<span class="keyword">,</span> _body<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [d1exp_while_n1_p1]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_print_n1
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e1<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> q <span class="keyword">=</span> $Syn<span class="keyword">.</span>d0ynq_none <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> fqid <span class="keyword">=</span> d1exp_qid <span class="keyword">(</span>loc0<span class="keyword">,</span> q<span class="keyword">,</span> symbol_PRINT<span class="keyword">)</span>
  <span class="keyword">val</span> f <span class="keyword">=</span> <span class="keyword">lam</span>
    <span class="keyword">(</span>d1e<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">)</span>
    <span class="keyword">:</span> <span class="staexp">d1exp</span> <span class="keyword">=&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> loc <span class="keyword">=</span> d1e<span class="keyword">.</span>d1exp_loc
  <span class="keyword">in</span>
    d1exp_app_dyn <span class="keyword">(</span>loc<span class="keyword">,</span> fqid<span class="keyword">,</span> loc<span class="keyword">,</span> 0<span class="comment">(*npf*)</span><span class="keyword">,</span> list_sing <span class="keyword">(</span>d1e<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [_]
</span>  <span class="keyword">val</span> d1eseq <span class="keyword">=</span> d1exp_appseq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1e1<span class="keyword">,</span> f<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cloptr_free <span class="keyword">(</span>f<span class="keyword">)</span>
<span class="keyword">in</span>
  d1eseq
<span class="keyword">end</span> <span class="comment">// end of [print_n1]
</span>
<span class="keyword">implement</span>
d1exp_println_n1
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span>  <span class="keyword">val</span> q <span class="keyword">=</span> $Syn<span class="keyword">.</span>d0ynq_none <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> println_id <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"print_newline"<span class="keyword">)</span>
  <span class="keyword">val</span> println_qid <span class="keyword">=</span> d1exp_qid <span class="keyword">(</span>loc0<span class="keyword">,</span> q<span class="keyword">,</span> println_id<span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">val</span> d1eseq <span class="keyword">=</span> d1exp_print_n1 <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span>
  <span class="keyword">val</span> d1eln <span class="keyword">=</span> d1exp_app_dyn <span class="keyword">(</span>loc0<span class="keyword">,</span> println_qid<span class="keyword">,</span> loc0<span class="keyword">,</span> 0<span class="comment">(*npf*)</span><span class="keyword">,</span> list_nil<span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">in</span>
  d1exp_seq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1eseq :: d1eln :: list_nil<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [println_n1]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_fprint_n2
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e1<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> q <span class="keyword">=</span> $Syn<span class="keyword">.</span>d0ynq_none <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> fqid <span class="keyword">=</span> d1exp_qid <span class="keyword">(</span>loc0<span class="keyword">,</span> q<span class="keyword">,</span> symbol_FPRINT<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span>d1e_out<span class="keyword">,</span> d1es_arg<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d1e1<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elist <span class="keyword">(</span>_<span class="comment">(*npf*)</span><span class="keyword">,</span> d1e :: d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>d1e<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>d1e1<span class="keyword">,</span> list_nil<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>d1exp<span class="keyword">,</span> d1explst<span class="keyword">)</span></span>
  <span class="keyword">val</span> f <span class="keyword">=</span> <span class="keyword">lam</span>
    <span class="keyword">(</span>d1e_arg<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">)</span>
    <span class="keyword">:</span> <span class="staexp">d1exp</span> <span class="keyword">=&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> loc <span class="keyword">=</span> d1e_arg<span class="keyword">.</span>d1exp_loc <span class="keyword">in</span>
    d1exp_app_dyn <span class="keyword">(</span>loc<span class="keyword">,</span> fqid<span class="keyword">,</span> loc<span class="keyword">,</span> 0<span class="comment">(*npf*)</span><span class="keyword">,</span> d1e_out :: d1e_arg :: list_nil<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [_]
</span>  <span class="keyword">val</span> d1eseq <span class="keyword">=</span> d1exp_applstseq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es_arg<span class="keyword">,</span> f<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cloptr_free <span class="keyword">(</span>f<span class="keyword">)</span>
<span class="keyword">in</span>
  d1eseq
<span class="keyword">end</span> <span class="comment">// end of [fprint_n2]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1exp_fprintln_n2
  <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val-</span> cons <span class="keyword">(</span>d1e1<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> d1es
  <span class="keyword">val</span> q <span class="keyword">=</span> $Syn<span class="keyword">.</span>d0ynq_none <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> fqid <span class="keyword">=</span> d1exp_qid <span class="keyword">(</span>loc0<span class="keyword">,</span> q<span class="keyword">,</span> symbol_FPRINT<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span>d1e_out<span class="keyword">,</span> d1es_arg<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d1e1<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elist <span class="keyword">(</span>_<span class="comment">(*npf*)</span><span class="keyword">,</span> d1e :: d1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>d1e<span class="keyword">,</span> d1es<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>d1e1<span class="keyword">,</span> list_nil<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>d1exp<span class="keyword">,</span> d1explst<span class="keyword">)</span></span>
  <span class="keyword">val</span> f <span class="keyword">=</span> <span class="keyword">lam</span>
    <span class="keyword">(</span>d1e_arg<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">)</span>
    <span class="keyword">:</span> <span class="staexp">d1exp</span> <span class="keyword">=&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="keyword">let</span>
    <span class="keyword">val</span> loc <span class="keyword">=</span> d1e_arg<span class="keyword">.</span>d1exp_loc <span class="keyword">in</span>
    d1exp_app_dyn <span class="keyword">(</span>loc<span class="keyword">,</span> fqid<span class="keyword">,</span> loc<span class="keyword">,</span> 0<span class="comment">(*npf*)</span><span class="keyword">,</span> d1e_out :: d1e_arg :: list_nil<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [_]
</span>  <span class="keyword">val</span> d1eseq <span class="keyword">=</span> d1exp_applstseq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1es_arg<span class="keyword">,</span> f<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cloptr_free <span class="keyword">(</span>f<span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">val</span> fprintln_id <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_make_string <span class="keyword">(</span>"fprint_newline"<span class="keyword">)</span>
  <span class="keyword">val</span> fprintln_qid <span class="keyword">=</span> d1exp_qid <span class="keyword">(</span>loc0<span class="keyword">,</span> q<span class="keyword">,</span> fprintln_id<span class="keyword">)</span>
  <span class="keyword">val</span> d1eln <span class="keyword">=</span> d1exp_app_dyn <span class="keyword">(</span>loc0<span class="keyword">,</span> fprintln_qid<span class="keyword">,</span> loc0<span class="keyword">,</span> 0<span class="comment">(*npf*)</span><span class="keyword">,</span> list_sing <span class="keyword">(</span>d1e_out<span class="keyword">)</span><span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">in</span>
  d1exp_seq <span class="keyword">(</span>loc0<span class="keyword">,</span> d1eseq :: d1eln :: list_nil<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprintln_n2]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_dynexp1_syndef.dats] *)</span>
</pre>
</body>
</html>
