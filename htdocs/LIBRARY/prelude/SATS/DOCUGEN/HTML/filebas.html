
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/filebas</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/filebas</h1>

<p>
The functions declared in this package are mostly provided
for the sake of convenience.  For full-fledged IO support,
please see [ATSLIB/libc/SATS/stdio.sats].
</p> 

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#dirsep_get">dirsep_get</a></li>
<li><a href="#dirname_self">dirname_self</a></li>
<li><a href="#dirname_parent">dirname_parent</a></li>
<li><a href="#filename_get_ext">filename_get_ext</a></li>
<li><a href="#filename_get_base">filename_get_base</a></li>
<li><a href="#test_file_exists">test_file_exists</a></li>
<li><a href="#test_file_mode">test_file_mode</a></li>
<li><a href="#test_file_isblk">test_file_isblk</a></li>
<li><a href="#test_file_ischr">test_file_ischr</a></li>
<li><a href="#test_file_isdir">test_file_isdir</a></li>
<li><a href="#test_file_isfifo">test_file_isfifo</a></li>
<li><a href="#test_file_isreg">test_file_isreg</a></li>
<li><a href="#fileref_open_exn">fileref_open_exn</a></li>
<li><a href="#fileref_open_opt">fileref_open_opt</a></li>
<li><a href="#fileref_close">fileref_close</a></li>
<li><a href="#fileref_flush">fileref_flush</a></li>
<li><a href="#fileref_getc">fileref_getc</a></li>
<li><a href="#fileref_putc">fileref_putc</a></li>
<li><a href="#fileref_putc_int">fileref_putc_int</a></li>
<li><a href="#fileref_putc_char">fileref_putc_char</a></li>
<li><a href="#fileref_puts">fileref_puts</a></li>
<li><a href="#fileref_is_eof">fileref_is_eof</a></li>
<li><a href="#fileref_load_type">fileref_load_type</a></li>
<li><a href="#fileref_load">fileref_load</a></li>
<li><a href="#fileref_load_int">fileref_load_int</a></li>
<li><a href="#fileref_load_char">fileref_load_char</a></li>
<li><a href="#fileref_load_double">fileref_load_double</a></li>
<li><a href="#fileref_load_string">fileref_load_string</a></li>
<li><a href="#fileref_get_optval">fileref_get_optval</a></li>
<li><a href="#fileref_get_line_charlst">fileref_get_line_charlst</a></li>
<li><a href="#fileref_get_lines_charlstlst">fileref_get_lines_charlstlst</a></li>
<li><a href="#fileref_get_line_string">fileref_get_line_string</a></li>
<li><a href="#fileref_get_line_string_main">fileref_get_line_string_main</a></li>
<li><a href="#fileref_get_lines_stringlst">fileref_get_lines_stringlst</a></li>
<li><a href="#fileref_get_line_string$bufsize">fileref_get_line_string$bufsize</a></li>
<li><a href="#fileref_get_file_charlst">fileref_get_file_charlst</a></li>
<li><a href="#fileref_get2_file_charlst">fileref_get2_file_charlst</a></li>
<li><a href="#fileref_put_charlst">fileref_put_charlst</a></li>
<li><a href="#fileref_foreach">fileref_foreach</a></li>
<li><a href="#fileref_foreach_env">fileref_foreach_env</a></li>
<li><a href="#fileref_foreach$bufsize">fileref_foreach$bufsize</a></li>
<li><a href="#fileref_foreach$fwork">fileref_foreach$fwork</a></li>
<li><a href="#fileref_foreach$fworkv">fileref_foreach$fworkv</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="dirsep_get">dirsep_get</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span> dirsep_get <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">charNZ</span></span></pre>
<h3>Description</h3>
This function returns the character for separating directory names
in a vaild path. In Unix-like systems, this character is the slash
symbol (/).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="dirname_self">dirname_self</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span> dirname_self <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>
This function returns the name referring to the self directory, which
is "." by default.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="dirname_parent">dirname_parent</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span> dirname_parent <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>
This function returns the name referring to the self directory, which
is ".." by default.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="filename_get_ext">filename_get_ext</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
filename_get_ext<span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">vStrptr0</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="filename_get_base">filename_get_base</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
filename_get_base <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">vStrptr1</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_exists">test_file_exists</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_exists
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>
This function tests whether a given path refers to a file in existence.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_mode">test_file_mode</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
test_file_mode
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span></pre>
<h3>Description</h3>

This function calls [stat] to obtain the mode of a given file and then
applies its second argument f to the mode to return an integer: ~1/0/1
means error/false/true, respectively.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_isblk">test_file_isblk</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_isblk<span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_ischr">test_file_ischr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_ischr<span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_isdir">test_file_isdir</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_isdir<span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_isfifo">test_file_isfifo</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_isfifo<span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="test_file_isreg">test_file_isreg</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
test_file_isreg<span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_open_exn">fileref_open_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_open_exn
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">file_mode</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">FILEref</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function calls the libc-function fclose (declared in [stdio.h]) to create
a handle for the file referred to by its first argument <span class="patsyntaxdynexp">path</span>
and then set the mode of the created handle according to its second
argument <span class="patsyntaxdynexp">fm</span>. In case of a failure, a fatal non-catchable
exception is raised.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_open_opt">fileref_open_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_open_opt
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">file_mode</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">fileref_open_exn</span>: The
returned value is an option that indicates whether a call to
<span class="patsyntaxdynexp">fileref_open_opt</span> successfully yields a file handle or not.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_close">fileref_close</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_close<span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function calls the libc-function fclose (declared in [stdio.h]) to close a
given file handle. Note that <span class="patsyntaxdynexp">fileref_close</span> does not report any
errors. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_flush">fileref_flush</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_flush<span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function calls the libc-function fflush (declared in [stdio.h]) to flush a
given file handle. Note that <span class="patsyntaxdynexp">fileref_flush</span> does not report any
errors.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_getc">fileref_getc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_getc<span class="keyword">(</span>input<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function reads a char from a given file handle. Note that the function
is based on the libc-function <span class="patsyntaxdynexp">fgetc</span>, and it returns a negative
integer (EOF) as an indication of error.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_putc">fileref_putc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fileref_putc <span class="keyword">with</span> fileref_putc_int</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fileref_putc <span class="keyword">with</span> fileref_putc_char</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_putc_int">fileref_putc_int</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_putc_int
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">fileref_putc</span>, casts
its first argument into a char and then write the char to a given file
handle. Note that the function is based on the libc-function <span class="patsyntaxdynexp">fputc</span>,
and it does not report any errors.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_putc_char">fileref_putc_char</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_putc_char
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function, which  overloads the symbol <span class="patsyntaxdynexp">fileref_putc</span>, writes
a char  to a  given file  handle. Note that  the function  is based  on the
libc-function <span class="patsyntaxdynexp">fputc</span>, and it does not report any errors.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_puts">fileref_puts</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_puts
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function writes a string to a given file handle. Note that the
function is based on the libc-function <span class="patsyntaxdynexp">fputs</span>, and it does not
report any errors. The following code gives a reference implementation of
the function:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_filebas_0.dats"><span class="dynexp"><span class="keyword">implement</span>
fileref_puts
  <span class="keyword">(</span>out<span class="keyword">,</span> str<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> g1ofg0_string<span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
string_foreach$cont <span class="keyword">(</span>c<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> true</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
string_foreach$fwork <span class="keyword">(</span>c<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> fileref_putc <span class="keyword">(</span>out<span class="keyword">,</span> c<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> _ <span class="keyword">=</span> string_foreach <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [fileref_puts]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_is_eof">fileref_is_eof</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_is_eof<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function tests whether the end of a given file handle is reached.  It
is based on the libc-function <span class="patsyntaxdynexp">feof</span> declared in [stdio.h].
<h3>Example</h3>

The following code gives a naive implementation of file-copying:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_filebas_1.dats"><span class="dynexp"><span class="keyword">fun</span> fprint_fileref
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> <span class="keyword">~</span>fileref_is_eof<span class="keyword">(</span>inp<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fileref_putc <span class="keyword">(</span>out<span class="keyword">,</span> fileref_getc <span class="keyword">(</span>inp<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">in</span>
    fprint_fileref <span class="keyword">(</span>out<span class="keyword">,</span> inp<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_fileref]</span>

<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_fileref <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> stdin_ref<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load_type">fileref_load_type</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span>
<span class="staexp">fileref_load_type<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">(</span><span class="staexp">FILEref</span><span class="keyword">,</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">fun1</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load">fileref_load</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fileref_load <span class="keyword">:</span> <span class="staexp">fileref_load_type</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function loads a value from a given file handle into a given variable,
and returns a boolean to indicate whether loading is successful or not. It
is only implemented for certain template arguments.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load_int">fileref_load_int</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_load_int <span class="keyword">:</span> <span class="staexp">fileref_load_type</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>
This function is a specific instance of <span class="patsyntaxdynexp">fileref_load</span> for
loading a integer.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load_char">fileref_load_char</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [fileref_load_char] is unavailable.</pre>
<h3>Description</h3>
This function is a specific instance of <span class="patsyntaxdynexp">fileref_load</span> for
loading a character.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load_double">fileref_load_double</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_load_double <span class="keyword">:</span> <span class="staexp">fileref_load_type</span><span class="keyword">(</span><span class="staexp">double</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>
This function is a specific instance of <span class="patsyntaxdynexp">fileref_load</span> for
loading a double-precision float.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_load_string">fileref_load_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [fileref_load_string] is unavailable.</pre>
<h3>Description</h3>
This function is a specific instance of <span class="patsyntaxdynexp">fileref_load</span> for
loading a doubly-quoted string.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_optval">fileref_get_optval</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fileref_get_optval
  <span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function reads a value from a given file handle. It is only
implemented for certain template arguments.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_line_charlst">fileref_get_line_charlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_get_line_charlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charlst_vt</span></span></pre>
<h3>Description</h3>

This function reads chars from a given file handle until a newline
symbol or EOF is reached and it then returns a linear list of the chars in
the order they were read. Note that the newline symbol is not included in
the chars returned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_lines_charlstlst">fileref_get_lines_charlstlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_get_lines_charlstlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">charlst_vt</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a linear list consisting of all the lines read from a
given file handle. Note that each of the returned lines is obtained by
calling <span class="patsyntaxdynexp">fileref_get_line_charlst</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_line_string">fileref_get_line_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_get_line_string<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr1</span></span></pre>
<h3>Description</h3>

This function returns a line read from a given file handle.
It is just a specialization of <span class="patsyntaxdynexp">fileref_get_line_string_main</span>,
and its implementation is given as follows:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_filebas_2.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span>
fileref_get_line_string
  <span class="keyword">(</span>filr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// uninitialized</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> fileref_get_line_string_main <span class="keyword">(</span>filr<span class="keyword">,</span> n<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_strnptr_param <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="keyword">in</span>
  strnptr2strptr <span class="keyword">(</span>str<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fileref_get_line_string]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_line_string_main">fileref_get_line_string_main</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_get_line_string_main
<span class="keyword">(</span>
  inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> nchar<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">int</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>n<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end-of-function</span></pre>
<h3>Description</h3>

This function returns a line read from a given file handle and records
the length of the line in its second (call-by-reference) argument. Note
that the length information can only be trusted if there are no occurrences
of the NUL char in the line.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_lines_stringlst">fileref_get_lines_stringlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_get_lines_stringlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">Strptr1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a linear list consisting of all the lines read from a
given file handle. Note that each of the returned lines is obtained by
calling <span class="patsyntaxdynexp">fileref_get_line_string</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_line_string$bufsize">fileref_get_line_string$bufsize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_get_line_string$bufsize<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the size of the initial buffer to be used by
<span class="patsyntaxdynexp">fileref_get_line_string</span>. Note that
<span class="patsyntaxdynexp">fileref_get_line_string</span> can automatically increase the size of
the buffer it uses if the buffer is not large enough.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get_file_charlst">fileref_get_file_charlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_get_file_charlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function reads chars from a given file handle until none is left
and it then returns a linear list of the chars in the order they were read.

<h3>Example</h3>

The following code prints out the content of a given file backwardly:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_filebas_3.dats"><span class="dynexp"><span class="keyword">fun</span> fprint_fileref_back
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> cs <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons
        <span class="keyword">(</span>c<span class="keyword">,</span> cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fileref_putc <span class="keyword">(</span>out<span class="keyword">,</span> c<span class="keyword">)</span></span> <span class="keyword">in</span> loop <span class="keyword">(</span>cs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="comment">// end of [loop]</span>
  <span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span> fileref_get_file_charlst <span class="keyword">(</span>inp<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>list_vt_reverse <span class="keyword">(</span>cs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_fileref_back]</span>

<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_fileref_back <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> stdin_ref<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_get2_file_charlst">fileref_get2_file_charlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_get2_file_charlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function reads chars from a given file handle until either the number
of chars being read reaches n (the value of the second argument) or no
char is left. It then returns a linear list consisting of the chars in the
order they were read and also updates the second argument with the length
of the returned list, that is, the number of chars being actually read.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_put_charlst">fileref_put_charlst</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
fileref_put_charlst<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> cs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">List</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function prints out the chars in its second argument to the file
handle provided as its first argument. Note that it does not report any
errors. <h3>Example</h3>

The following code removes every empty line in a given file:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_filebas_4.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> remove_empty_lines
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> isfst<span class="keyword">:</span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> EOL <span class="keyword">=</span> <span class="dynexp">'\n'</span></span>
  <span class="dynexp"><span class="keyword">val</span> iseof <span class="keyword">=</span> fileref_is_eof <span class="keyword">(</span>inp<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> <span class="keyword">~</span>iseof <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="keyword">var</span> isfst<span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> isfst
  <span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span>
    fileref_get_line_charlst <span class="keyword">(</span>inp<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> list_vt_is_cons <span class="keyword">(</span>cs<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> iscons <span class="keyword">then</span> <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isfst <span class="keyword">then</span> <span class="keyword">(</span>isfst := false<span class="keyword">)</span> <span class="keyword">else</span> fileref_putc <span class="keyword">(</span>out<span class="keyword">,</span> EOL<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fileref_put_charlst <span class="keyword">(</span>out<span class="keyword">,</span> $UN<span class="keyword">.</span>list_vt2t <span class="keyword">(</span>cs<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">}</span></span> <span class="comment">// end of [if] // end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>cs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  remove_empty_lines <span class="keyword">(</span>out<span class="keyword">,</span> inp<span class="keyword">,</span> isfst<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [remove_empty_lines]</span>

<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> remove_empty_lines <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> stdin_ref<span class="keyword">,</span> true<span class="comment">(*isfst*)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>


Clearly, this is a wasteful and inefficient way of removing empty lines.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_foreach">fileref_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_foreach<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function reads from a given file handle multiple characters and then
applies to them the function implemented by
<span class="patsyntaxdynexp">fileref_foreach$fworkv</span>. It does so repeatedly until it can read
no more characters from the file handle.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_foreach_env">fileref_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> fileref_foreach_env<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">fileref_foreach</span>
except for taking an additional argument that serves as an environment.
Actually, <span class="patsyntaxdynexp">fileref_foreach</span> is implemented as a special case of
<span class="patsyntaxdynexp">fileref_foreach_env</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_foreach$bufsize">fileref_foreach$bufsize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fileref_foreach$bufsize<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeGte</span><span class="keyword">(</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function determines the size of the buffer allocated for storing
characters during the evaluation of a call to <span class="patsyntaxdynexp">fileref_foreach_env</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_foreach$fwork">fileref_foreach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> fileref_foreach$fwork<span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is used in the default implementation of <span class="patsyntaxdynexp">fileref_foreach$fworkv</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fileref_foreach$fworkv">fileref_foreach$fworkv</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> fileref_foreach$fworkv
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">arrayref</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is directly called in the implementation of <span class="patsyntaxdynexp">fileref_foreach_env</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

