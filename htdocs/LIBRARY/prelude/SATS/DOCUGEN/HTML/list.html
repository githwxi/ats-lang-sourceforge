
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/list</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/list</h1>


<p>
This package contains a variety of common functions for creating and
manipulationg functional lists.
</p>

<p>
A functional data structure is one that is immutable after creation; the
memory it occupies is heap-allocated, which can only be safely freed by a
garbage collector (GC).  The type for a singly-linked functional list
containing N elements of type T is denoted by <span class="patsyntaxstaexp">list(T, N)</span>, where
T is nonlinear. Note that the type constructor <span class="patsyntaxstaexp">list</span> is
co-variant in its first argument, that is, <span class="patsyntaxstaexp">list(T1, N)</span> is a
subtype of <span class="patsyntaxstaexp">list(T2, N)</span> if T1 is a subtype of T2.
</p>

<p>
Please see
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/SATS/list.sats">list.sats</a> and
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/list.dats">list.dats</a> for
the SATS file and DATS file in ATSLIB where the functions in this package
are declared and implemented.
</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#list">list</a></li>
<li><a href="#List">List</a></li>
<li><a href="#List0">List0</a></li>
<li><a href="#List1">List1</a></li>
<li><a href="#listLt">listLt</a></li>
<li><a href="#listLte">listLte</a></li>
<li><a href="#listGt">listGt</a></li>
<li><a href="#listGte">listGte</a></li>
<li><a href="#listBtw">listBtw</a></li>
<li><a href="#listBtwe">listBtwe</a></li>
<li><a href="#ListSubscriptExn">ListSubscriptExn</a></li>
<li><a href="#lemma_list_param">lemma_list_param</a></li>
<li><a href="#list_cast">list_cast</a></li>
<li><a href="#list_vt2t">list_vt2t</a></li>
<li><a href="#list_of_list_vt">list_of_list_vt</a></li>
<li><a href="#list_make_sing">list_make_sing</a></li>
<li><a href="#list_make_pair">list_make_pair</a></li>
<li><a href="#list_make_elt">list_make_elt</a></li>
<li><a href="#list_make_intrange">list_make_intrange</a></li>
<li><a href="#list_make_array">list_make_array</a></li>
<li><a href="#list_make_arrpsz">list_make_arrpsz</a></li>
<li><a href="#fprint_list">fprint_list</a></li>
<li><a href="#fprint_list$sep">fprint_list$sep</a></li>
<li><a href="#fprint_list_sep">fprint_list_sep</a></li>
<li><a href="#list_head">list_head</a></li>
<li><a href="#list_head_exn">list_head_exn</a></li>
<li><a href="#list_tail">list_tail</a></li>
<li><a href="#list_tail_exn">list_tail_exn</a></li>
<li><a href="#list_last">list_last</a></li>
<li><a href="#list_last_exn">list_last_exn</a></li>
<li><a href="#list_nth">list_nth</a></li>
<li><a href="#list_get_at">list_get_at</a></li>
<li><a href="#list_set_at">list_set_at</a></li>
<li><a href="#list_exch_at">list_exch_at</a></li>
<li><a href="#list_insert_at">list_insert_at</a></li>
<li><a href="#list_remove_at">list_remove_at</a></li>
<li><a href="#list_takeout_at">list_takeout_at</a></li>
<li><a href="#list_length">list_length</a></li>
<li><a href="#list_copy">list_copy</a></li>
<li><a href="#list_append">list_append</a></li>
<li><a href="#list_append1_vt">list_append1_vt</a></li>
<li><a href="#list_append2_vt">list_append2_vt</a></li>
<li><a href="#list_extend">list_extend</a></li>
<li><a href="#list_snoc">list_snoc</a></li>
<li><a href="#list_reverse">list_reverse</a></li>
<li><a href="#list_reverse_append">list_reverse_append</a></li>
<li><a href="#list_reverse_append1_vt">list_reverse_append1_vt</a></li>
<li><a href="#list_reverse_append2_vt">list_reverse_append2_vt</a></li>
<li><a href="#list_concat">list_concat</a></li>
<li><a href="#list_take">list_take</a></li>
<li><a href="#list_take_exn">list_take_exn</a></li>
<li><a href="#list_drop">list_drop</a></li>
<li><a href="#list_drop_exn">list_drop_exn</a></li>
<li><a href="#list_split_at">list_split_at</a></li>
<li><a href="#list_exists">list_exists</a></li>
<li><a href="#list_exists$pred">list_exists$pred</a></li>
<li><a href="#list_forall">list_forall</a></li>
<li><a href="#list_forall$pred">list_forall$pred</a></li>
<li><a href="#list_equal">list_equal</a></li>
<li><a href="#list_equal$eqfn">list_equal$eqfn</a></li>
<li><a href="#list_find">list_find</a></li>
<li><a href="#list_find$pred">list_find$pred</a></li>
<li><a href="#list_find_exn">list_find_exn</a></li>
<li><a href="#list_find_opt">list_find_opt</a></li>
<li><a href="#list_assoc">list_assoc</a></li>
<li><a href="#list_assoc$eqfn">list_assoc$eqfn</a></li>
<li><a href="#list_assoc_exn">list_assoc_exn</a></li>
<li><a href="#list_assoc_opt">list_assoc_opt</a></li>
<li><a href="#list_filter">list_filter</a></li>
<li><a href="#list_filter$pred">list_filter$pred</a></li>
<li><a href="#list_labelize">list_labelize</a></li>
<li><a href="#list_app">list_app</a></li>
<li><a href="#list_app$fwork">list_app$fwork</a></li>
<li><a href="#list_map">list_map</a></li>
<li><a href="#list_map$fopr">list_map$fopr</a></li>
<li><a href="#list_imap">list_imap</a></li>
<li><a href="#list_imap$fopr">list_imap$fopr</a></li>
<li><a href="#list_mapopt">list_mapopt</a></li>
<li><a href="#list_mapopt$fopr">list_mapopt$fopr</a></li>
<li><a href="#list_map2">list_map2</a></li>
<li><a href="#list_map2$fopr">list_map2$fopr</a></li>
<li><a href="#list_tabulate">list_tabulate</a></li>
<li><a href="#list_tabulate$fopr">list_tabulate$fopr</a></li>
<li><a href="#list_zip">list_zip</a></li>
<li><a href="#list_zipwith">list_zipwith</a></li>
<li><a href="#list_zipwith$fopr">list_zipwith$fopr</a></li>
<li><a href="#list_cross">list_cross</a></li>
<li><a href="#list_crosswith">list_crosswith</a></li>
<li><a href="#list_crosswith$fopr">list_crosswith$fopr</a></li>
<li><a href="#list_foreach">list_foreach</a></li>
<li><a href="#list_foreach_env">list_foreach_env</a></li>
<li><a href="#list_foreach$cont">list_foreach$cont</a></li>
<li><a href="#list_foreach$fwork">list_foreach$fwork</a></li>
<li><a href="#list_foreach2">list_foreach2</a></li>
<li><a href="#list_foreach2_env">list_foreach2_env</a></li>
<li><a href="#list_foreach2$cont">list_foreach2$cont</a></li>
<li><a href="#list_foreach2$fwork">list_foreach2$fwork</a></li>
<li><a href="#list_iforeach">list_iforeach</a></li>
<li><a href="#list_iforeach_env">list_iforeach_env</a></li>
<li><a href="#list_iforeach$cont">list_iforeach$cont</a></li>
<li><a href="#list_iforeach$fwork">list_iforeach$fwork</a></li>
<li><a href="#list_iforeach2">list_iforeach2</a></li>
<li><a href="#list_iforeach2_env">list_iforeach2_env</a></li>
<li><a href="#list_foldleft">list_foldleft</a></li>
<li><a href="#list_foldleft$fopr">list_foldleft$fopr</a></li>
<li><a href="#list_mergesort">list_mergesort</a></li>
<li><a href="#list_mergesort$cmp">list_mergesort$cmp</a></li>
<li><a href="#list_quicksort">list_quicksort</a></li>
<li><a href="#list_quicksort$cmp">list_quicksort$cmp</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#+">+</a></li>
<li><a href="#[]">[]</a></li>
<li><a href="#.head">.head</a></li>
<li><a href="#.tail">.tail</a></li>
<li><a href="#iseqz">iseqz</a></li>
<li><a href="#isneqz">isneqz</a></li>
<li><a href="#length">length</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#print">print</a></li>
<li><a href="#prerr">prerr</a></li>
<li><a href="#fprint">fprint</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="list">list</a></h2>
<h3>Synopsis</h3>
<p>The full name for the list-type constructor <span class="patsyntaxstaexp">list</span> is
<span class="patsyntaxstaexp">list_t0ype_int_type</span>, which is given to the datatype declared as
follows:
<pre class="patsyntax"><span class="keyword">datatype</span> <span class="comment">// t@ype+: covariant</span>
<span class="staexp">list_t0ype_int_type
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">list_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">}</span></span>
    list_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list_t0ype_int_type</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
 <span class="comment">// end of [list_t0ype_int_type]</span>
</pre>
</p><h3>Description</h3>

There are two data constructors <span class="patsyntaxdynexp">list_nil</span> and
<span class="patsyntaxdynexp">list_cons</span> associated with <span class="patsyntaxstaexp">list</span>; the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List">List</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span>
<span class="staexp">List<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This type is for lists of unspecified length.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List0">List0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span>
<span class="staexp">List0<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This type is for lists of unspecified length that is greater than or equal
to 0. Note that <span class="patsyntaxstaexp">List0</span> is essentially equivalent to
<span class="patsyntaxstaexp">List</span> since the length of a list can never be negative.  The
proof function <span class="patsyntaxprfexp">lemma_list_param</span> can be called explicitly to
cast from <span class="patsyntaxstaexp">List</span> to <span class="patsyntaxstaexp">List0</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List1">List1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span>
<span class="staexp">List1<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 1<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This type is for lists of unspecified positive length.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listLt">listLt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listLt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listLte">listLte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listLte
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k &lt;= n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listGt">listGt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listGt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> k <span class="keyword">&gt;</span> n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listGte">listGte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listGte
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> k &gt;= n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listBtw">listBtw</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listBtw
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= k<span class="keyword">;</span> k <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listBtwe">listBtwe</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">typedef</span> <span class="staexp">listBtwe
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= k<span class="keyword">;</span> k &lt;= n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ListSubscriptExn">ListSubscriptExn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">exception</span>
<span class="dynexp">ListSubscriptExn <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

By convention, this exception is raised to indicate a situation where a
list expected to be non-empty is actually empty.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_list_param">lemma_list_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
lemma_list_param
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function establishes that the integer n in any list type
<span class="patsyntaxstaexp">list(T, n)</span> is a natural number, where T is a nonlinear type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_cast">list_cast</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list_cast
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function can be employed to explicitly cast a list containing
elements of type T1 into another list containing elements of type T2
whenever T1 is a subtype of T2.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt2t">list_vt2t</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list_vt2t
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function does the same as <span class="patsyntaxdynexp">list_of_list_vt</span>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_of_list_vt">list_of_list_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list_of_list_vt
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function casts a linear list-value into a nonlinear list-value.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_sing">list_make_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_make_sing <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list consisting of a single given value.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_pair">list_make_pair</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_make_pair <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list consisting of a pair of given values.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_elt">list_make_elt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_make_elt
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a natural number n and an element x, this function returns a list
consisting of n occurrences of x.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_intrange">list_make_intrange</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> list_make_intrange
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>r<span class="keyword">:</span>int <span class="keyword">|</span> l &lt;= r<span class="keyword">}</span></span>
  <span class="keyword">(</span>l<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">l</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">r</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">intBtw</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">r</span><span class="staexp">-</span><span class="staexp">l</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given integers l and r satisfying l <= r, this function returns a list of
integers ranging from l until r-1, inclusive.

<h3>Example</h3>

The following code demonstrates two ways of constructing the same list of
digits:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_0.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> list_make_intrange <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">10</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">(</span>list<span class="keyword">)</span><span class="keyword">$arrpsz</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t<span class="staexp"><span class="keyword">{</span>T<span class="keyword">}</span></span><span class="keyword">(</span>xs1<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>xs2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>xs2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_array">list_make_array</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_make_array
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?!</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given an array of size n, this function returns a linear list of length n
such that element i in the list is the element stored in cell i of the
array, where i ranges from 0 until n-1, inclusive.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_make_arrpsz">list_make_arrpsz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_make_arrpsz
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>psz<span class="keyword">:</span> <span class="staexp">arrpsz</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">list</span>, is often
conveniently employed to build a list of some fixed length. Note that the
argument of <span class="patsyntaxdynexp">list_make_arrpsz</span> is a linear arrpsz-value, which is
consumed after <span class="patsyntaxdynexp">list_make_arrpsz</span> returns.

<h3>Example</h3>

The following code demonstrates two ways of constructing lists of fixed
length:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_1.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">{</span>
  <span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
  <span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">(</span>list<span class="keyword">)</span><span class="keyword">$arrpsz</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>xs1 <span class="keyword">=</span> list_vt2t<span class="keyword">(</span>xs2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main0]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list">fprint_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fprint_list<span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function prints the elements in a given list to the output
channel provided as its first argument, and it calls the function
<span class="patsyntaxdynexp">fprint_list$sep</span> before printing an element as long as the
element is not the first one.  Note that printing each list element is
handled by calling the function <span class="patsyntaxdynexp">fprint_val</span>.
<h3>Example</h3>

The following code builds a list of digits and then prints them onto the
standard output channel:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_2.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="dynexp"><span class="keyword">val</span> digits <span class="keyword">=</span>
  <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> digits<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list$sep">fprint_list$sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fprint_list$sep<span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is called by <span class="patsyntaxdynexp">fprint_list</span> to print a separator
between two consecutive list elements. By default, it prints the comma
symbol (,).

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list_sep">fprint_list_sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fprint_list_sep
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function prints the elements in a given list to the output channel
provided as its first argument, interspersing the string <span class="patsyntaxdynexp">sep</span>
between the printed list elements. Note that printing each list element is
handled by calling the function <span class="patsyntaxdynexp">fprint_val</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_head">list_head</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_head<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the head of a given non-empty list. It is O(1)-time.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_head_exn">list_head_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_head_exn<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the head of a given list if the list is not
empty. Otherwise, it raise a run-time exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_tail">list_tail</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_tail<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the tail of a given non-empty list. It is O(1)-time.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_tail_exn">list_tail_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_tail_exn<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the tail of a given list if the list is not
empty. Otherwise, it raise a run-time exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_last">list_last</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_last<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the last element of a given non-empty list. It is
O(n)-time, when n is the length of the given list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_last_exn">list_last_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_last_exn<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the last element of a given list if the list is not
empty. Otherwise, it raise a run-time exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_nth">list_nth</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_nth<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list of length n and a natural number i less than n, this function
returns xs[i], that is, element i in xs.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_get_at">list_get_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_get_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function does the same as <span class="patsyntaxdynexp">list_nth</span>.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_set_at">list_set_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [list_set_at] is unavailable.</pre>
<h3>Description</h3>


Given a list xs of length n, a natural number i less than n, and an element
x, this function returns another list obtained from replacing element i in
xs with x. 
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_exch_at">list_exch_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [list_exch_at] is unavailable.</pre>
<h3>Description</h3>


Given a list xs of length n, a natural number i less than n, and an element
x, this function returns another list and another element such that the
list is obtained from replacing element i in xs with x and the element is
xs[i]. 
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_insert_at">list_insert_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_insert_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span> <span class="comment">// end of [list_insert_at]</span></pre>
<h3>Description</h3>

Given a list xs of length n, a natural number i <= n, and an element x, this
function inserts x into xs so that x becomes element i in the returned list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_remove_at">list_remove_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_remove_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span></span> <span class="comment">// end of [list_remove_at]</span></pre>
<h3>Description</h3>

Given a list xs of length n and a natural number i < n, this function
returns a list obtained from removing xs[i] from xs.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_takeout_at">list_takeout_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_takeout_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span></span> <span class="comment">// end of [list_takeout_at]</span></pre>
<h3>Description</h3>

This function does the same as <span class="patsyntaxdynexp">list_remove_at</span> except for
storing the removed element in its third call-by-reference argument.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_length">list_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns the length of a given list.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_copy">list_copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_copy
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns a copy of xs. Note that the returned
copy is a linear list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_append">list_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_append
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [list_append]</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">+</span>, returns a
concatenation of its first argument xs and second argument ys.  The
time-complexity of this function is O(m), where m is the length of xs. What
is special about the implementation of this function in ATSLIB is that it
is tail-recursive.

<h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">list_append</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_3.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span> <span class="keyword">(</span><span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs12 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>xs1+xs2 <span class="keyword">=</span> xs12<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [main0]</span>
</pre>


<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_append1_vt">list_append1_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_append1_vt
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given a linear list xs and a list ys, this function returns a concatenation
of xs and ys. Note that the linear list xs is consumed in the construction of
the concatenation.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_append2_vt">list_append2_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_append2_vt
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">j</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">i</span><span class="staexp">+</span><span class="staexp">j</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given a list xs and a linear list ys, this function returns a concatenation
of xs and ys. Note that the linear list ys is consumed in the construction of
the concatenation.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_extend">list_extend</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_extend<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs and an element x, this function returns a list that is the
concatenation of xs and [x], which [x] refers to the singleton list
consisting of x alone. Note that the time-complexity of this is function is
O(n), where n is the length of xs.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_snoc">list_snoc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">macdef</span> list_snoc <span class="dynexp"><span class="keyword">(</span>xs<span class="keyword">,</span> x<span class="keyword">)</span></span> <span class="keyword">=</span> list_extend <span class="keyword">(</span><span class="dynexp"><span class="keyword">,(</span>xs<span class="keyword">)</span></span><span class="keyword">,</span> <span class="dynexp"><span class="keyword">,(</span>x<span class="keyword">)</span></span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_reverse">list_reverse</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_reverse
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list that is the reverse of its argument.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_reverse_append">list_reverse_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_reverse_append
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list that is the concatenation of the reverse of
its first argument and its second argument.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_reverse_append1_vt">list_reverse_append1_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_reverse_append1_vt
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs and a list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list xs is consumed in
the construction of the concatenation.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_reverse_append2_vt">list_reverse_append2_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_reverse_append2_vt
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs and a linear list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list ys is consumed in
the construction of the concatenation.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_concat">list_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_concat<span class="keyword">(</span>xss<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xss, this function builds a concatenation of xss[0],
xss[1], ..., and xss[n-1], where n is the length of xss and each xss[i]
refers to element i in xss.
<h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">list_concat</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_4.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">2</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs3 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">3</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xss <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">List</span><span class="keyword">(</span><span class="staexp">T</span><span class="keyword">)</span><span class="keyword">}</span><span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> xs3<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs123 <span class="keyword">=</span> list_concat <span class="keyword">(</span>xss<span class="keyword">)</span></span> <span class="comment">// xs123 = [1, 2, 3]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"xs123 = "</span><span class="keyword">,</span> xs123<span class="keyword">)</span></span> <span class="comment">// output 1,2,3</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>xs123<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_take">list_take</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_take
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a prefix of its first argument, where the length of
the prefix is specified by its second argument.

<h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">list_take</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_5.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> n1 <span class="keyword">=</span> list_length <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>xs1 <span class="keyword">=</span> list_vt2t<span class="keyword">(</span>list_take <span class="keyword">(</span>xs1 + xs2<span class="keyword">,</span> n1<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_take_exn">list_take_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_take_exn
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="comment">// it may raise [ListSubscriptException]</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i &lt;= n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">list_take</span> except that it raises an
exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>) if its second argument exceeds the
length of its first argument.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_drop">list_drop</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_drop
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a suffix of its first argument, where the length of
the suffix is the length of the first argument minus the integer provided
as its second argument.  <h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">list_drop</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_6.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> n1 <span class="keyword">=</span> list_length <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>xs2 <span class="keyword">=</span> list_drop <span class="keyword">(</span>xs1 + xs2<span class="keyword">,</span> n1<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_drop_exn">list_drop_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_drop_exn
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="comment">// it may raise [ListSubscriptException]</span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i &lt;= n<span class="keyword">]</span></span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">list_drop</span> except that it raises an
exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>) if its second argument exceeds the
length of its first argument.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_split_at">list_split_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_split_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n and an integer i between 0 and n, inclusive,
this function returns a pair of lists of length i and n-i such that the
concatenation of the pair equals the given list xs.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_exists">list_exists</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_exists<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns true if and only if there exists an
element in xs that satisfies the predicate implemented by
<span class="patsyntaxdynexp">list_exists$pred</span>.

<h3>Example</h3>

The following code implements a function for removing the duplicates in a
given list:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_7.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_remove_dup <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> eq<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">&gt;</span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">List0_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">implement</span>
        list_exists$pred&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>y<span class="keyword">)</span> <span class="keyword">=</span> eq <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> found <span class="keyword">=</span> list_exists&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>ys<span class="keyword">)</span><span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> found <span class="keyword">then</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">else</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> list_vt_cons <span class="keyword">(</span>x<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_cons]</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  list_vt_reverse <span class="keyword">(</span>loop <span class="keyword">(</span>xs<span class="keyword">,</span> list_vt_nil<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_remove_dup]</span>
</pre>

Note that the order of elements in the returned list is consistent with
their order in the original list.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_exists$pred">list_exists$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_exists$pred<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_forall">list_forall</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_forall<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns true if and only if every element in
xs satisfies the predicate implemented by <span class="patsyntaxdynexp">list_forall$pred</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_forall$pred">list_forall$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_forall$pred<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_equal">list_equal</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_equal<span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

Given two lists xs1 and xs2 of length n1 and n2, respectively, this
function returns true if and only if xs1 and xs2 are of the same length and
the predicate implemented by <span class="patsyntaxdynexp">list_equal$pred</span> holds on each
pair (xs1[i], xs2[i]), where i ranges from 0 until n1-1, inclusive, and
xs1[i] (xs2[i]) refers to element i in xs1 (xs2). <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_equal$eqfn">list_equal$eqfn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_equal$eqfn<span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

This function is called in the implementation of <span class="patsyntaxdynexp">list_equal</span> to
perform equality test on list elements, and its default implementation is
based on <span class="patsyntaxdynexp">gequal_val</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_8.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list_equal$eqfn <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gequal_val&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_find">list_find</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_find<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">i</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span></span> <span class="comment">// end-of-function</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_find$pred">list_find$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span> list_find$pred <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_find_exn">list_find_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span> list_find_exn <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">x</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns xs[i] (element i in xs) for the
least index i such that xs[i] satisfies the predicate implemented by
<span class="patsyntaxdynexp">list_find$pred</span>. In case there is no such an element, the
function raises an exception (<span class="patsyntaxdynexp">NotFoundExn</span>).

<h3>Example</h3>

The following code finds the first odd number in a give list:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_9.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_find$pred&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> x mod <span class="dynexp">2</span> <span class="keyword">=</span> <span class="dynexp">1</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span><span class="dynexp">1</span> <span class="keyword">=</span> list_find_exn&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_find_opt">list_find_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span> list_find_opt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">list_find_exn</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_assoc">list_assoc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
key<span class="keyword">,</span>itm<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_assoc
<span class="keyword">(</span>
  <span class="staexp">List</span><span class="keyword">@(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">key</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">itm</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">key</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">itm</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span><span class="keyword">(</span><span class="staexp">itm</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>b<span class="keyword">:</span>bool<span class="keyword">]</span></span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span> <span class="comment">// end of [list_assoc]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_assoc$eqfn">list_assoc$eqfn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>key<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_assoc$eqfn <span class="keyword">(</span>k1<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> k2<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_assoc_exn">list_assoc_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
key<span class="keyword">,</span>itm<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_assoc_exn
  <span class="keyword">(</span>kxs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">@(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">key</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">itm</span><span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">itm</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_assoc_opt">list_assoc_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
key<span class="keyword">,</span>itm<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_assoc_opt
  <span class="keyword">(</span>kxs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">@(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">key</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">itm</span><span class="keyword">)</span><span class="keyword">,</span> k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">itm</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_filter">list_filter</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_filter<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">listLte_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns a linear list consisting elements in
xs that satisfy the predicate implemented by <span class="patsyntaxdynexp">list_filter$pred</span>.
The implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_filter$pred">list_filter$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span> list_filter$pred <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_labelize">list_labelize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_labelize<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="keyword">@(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns a linear list consisting
pairs (i, xs[i]), where i ranges from 0 until n-1, inclusive, and xs[i]
refers to element i in xs.  The implementation of this function in ATSLIB
is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_app">list_app</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_app <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function traverses a given list, applying to each encountered element
the function implemented by <span class="patsyntaxdynexp">list_app$fwork</span>.
<h3>Example</h3>

The following code tallies all the integers in a given list:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_10.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">var</span> sum<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="dynexp"><span class="keyword">val</span> p_sum <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span>sum</span>
<span class="comment">//</span>
<span class="keyword">local</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_app$fwork&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span>
  $UN<span class="keyword">.</span>ptr0_addby&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_sum<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span> <span class="comment">(*in-of-local*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_app&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="comment">// end of [local]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>sum <span class="keyword">=</span> <span class="dynexp">1</span>+<span class="dynexp">2</span>+<span class="dynexp">3</span>+<span class="dynexp">4</span>+<span class="dynexp">5</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_app$fwork">list_app$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span> list_app$fwork <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_map">list_map</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_map<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns a linear list consisting
f(xs[i]), where i ranges from 0 until n-1, xs[i] refers to element i in xs
and f is the function implemented by <span class="patsyntaxdynexp">list_map$fopr</span>.  The
implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_map$fopr">list_map$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> list_map$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_imap">list_imap</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_imap<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns a linear list consisting
f(i, xs[i]), where i ranges from 0 until n-1, xs[i] refers to element i in
xs, and f is the function implemented by <span class="patsyntaxdynexp">list_imap$fopr</span>.  The
implementation of this function in ATSLIB is tail-recursive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_imap$fopr">list_imap$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_imap$fopr<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_mapopt">list_mapopt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_mapopt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">listLte_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs, this function applies the function implemented by
<span class="patsyntaxdynexp">list_mapopt$fopr</span> to each element x in xs; if the application
returns an optional value of the form <span class="patsyntaxdynexp">Some(y)</span> for some y, then
y is collected in the linear list returned by <span class="patsyntaxdynexp">list_mapopt</span>.
The implementation of this function in ATSLIB is tail-recursive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_mapopt$fopr">list_mapopt$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_mapopt$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_map2">list_map2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x1<span class="keyword">,</span>x2<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_map2<span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x1</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x2</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">min</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">,</span><span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="comment">// end of [list_map2]</span></pre>
<h3>Description</h3>

Given lists xs1 and xs2 of length n1 and n2, respectively, this function
returns a linear list consisting f(xs1[i], xs2[i]), where i ranges from 0
until min(n1,n2)-1, xs1[i] (xs2[i]) refers to element i in xs1 (xs2) and f is
the function implemented by <span class="patsyntaxdynexp">list_map2$fopr</span>.  The
implementation of this function in ATSLIB is tail-recursive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_map2$fopr">list_map2$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x1<span class="keyword">,</span>x2<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_map2$fopr <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">x1</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">x2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_tabulate">list_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_tabulate<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a natural number n, this function returns a linear list consisting of
f(i) for i ranging from 0 until n-1, inclusive, where f is the function
implemented by <span class="patsyntaxdynexp">list_tabulate$fwork</span>. The implementation of this
function in ATSLIB is tail-recursive.

<h3>Example</h3>

The following code implements a function that returns a list of integers
between two given arguments:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_11.dats"><span class="dynexp"><span class="keyword">fun</span> list_make_intrange
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>r<span class="keyword">:</span>int <span class="keyword">|</span> l &lt;= r<span class="keyword">}</span></span> <span class="keyword">(</span>
  l<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">l</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">r</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">r</span><span class="staexp">-</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_tabulate$fopr&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=</span> l + i</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  list_tabulate&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>r-l<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_make_intrange]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_tabulate$fopr">list_tabulate$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> list_tabulate$fopr <span class="keyword">(</span>index<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_zip">list_zip</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_zip<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">min</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
zips them into a linear list xys of length min(m,n) such that element i in
xys is the pair of element i in xs and element i in ys, where i ranges from
0 until min(m,n)-1, inclusive.  The implementation of this function in
ATSLIB is tail-recursive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_zipwith">list_zipwith</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_zipwith<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">min</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
returns a linear list consisting of f (xs[i], ys[i]), where f is the
function implemented by <span class="patsyntaxdynexp">list_zipwith$fopr</span> and i ranges from 0
until min(m,n)-1, inclusive.  The implementation of this function in ATSLIB
is tail-recursive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_zipwith$fopr">list_zipwith$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_zipwith$fopr <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_cross">list_cross</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_cross
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
returns a linear list xys of length m*n that is the cross-product of xs and
ys. More specifically, element k in xys (for each k between 0 and m*n-1,
inclusive) equals (xs[i], ys[j]), where i = k/n and j=k-i*n.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_crosswith">list_crosswith</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_crosswith
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [list_crosswith]</span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
returns a linear list xys of length m*n such that element k in xys (for
each k between 0 and m*n-1, inclusive) is the return value of f (xs[i],
ys[j]), where f is the function implemented by
<span class="patsyntaxdynexp">list_crosswith$fopr</span>, and i = k/n and j=k-i*n. <h3>Example</h3>

The following code builds a list of natural numbers by calling
<span class="patsyntaxdynexp">list_crosswith</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_12.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xys <span class="keyword">=</span> list_make_intrange <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">100</span><span class="keyword">)</span></span> <span class="comment">// = 0, 1, 2, ..., 99</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_crosswith$fopr&lt;<span class="staexp">T</span><span class="keyword">,</span><span class="staexp">T</span><span class="keyword">&gt;&lt;</span><span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">10</span> * x + y</span>
<span class="dynexp"><span class="keyword">val</span> xys2 <span class="keyword">=</span> list_crosswith&lt;<span class="staexp">T</span><span class="keyword">,</span><span class="staexp">T</span><span class="keyword">&gt;&lt;</span><span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span></span> <span class="comment">// = 0, 1, ..., 99</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t<span class="staexp"><span class="keyword">{</span>T<span class="keyword">}</span></span><span class="keyword">(</span>xys<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>xys2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xys<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xys2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_crosswith$fopr">list_crosswith$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_crosswith$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">y</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach">list_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_foreach<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function applies to xs[i] the function
implemented by <span class="patsyntaxdynexp">list_foreach$fwork</span>, where i ranges from 0 until
n-1, inclusive, and xs[i] refers to element i in xs.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach_env">list_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_foreach_env
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">list_foreach</span>
except for taking an additional argument that serves as an environment.  <h3>Example</h3>
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_13.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> "contrib/libats-hwxi/testing/SATS/randgen.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="neuexp"><span class="keyword">#define</span> N 1000000</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> randgen_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>N<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">env <span class="keyword">=</span> <span class="staexp">T</span></span>
<span class="dynexp"><span class="keyword">implement</span>
list_foreach$fwork&lt;<span class="staexp">T</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := env + x</span>
<span class="comment">//</span>
<span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">env</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_foreach_env&lt;<span class="staexp">T</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> res<span class="keyword">)</span></span>
<span class="comment">//  </span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  print <span class="keyword">(</span><span class="dynstr">"The total equals "</span><span class="keyword">)</span><span class="keyword">;</span> print res<span class="keyword">;</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach$cont">list_foreach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_foreach$cont <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach$fwork">list_foreach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_foreach$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach2">list_foreach2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_foreach2
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
applies to each pair (xs[i], ys[i]) the function implemented by
<span class="patsyntaxdynexp">list_foreach2$fwork</span>, where i ranges from 0 until min(m, n)-1,
inclusive, and xs[i] (ys[i]) refers to element i in xs (ys).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach2_env">list_foreach2_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_foreach2_env
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach2$cont">list_foreach2$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_foreach2$cont<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">y</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foreach2$fwork">list_foreach2$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_foreach2$fwork<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">y</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach">list_iforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_iforeach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function applies to each pair (i, xs[i])
the function implemented by <span class="patsyntaxdynexp">list_iforeach$fwork</span>, where i
ranges from 0 until n-1, inclusive, and xs[i] refers to element i in xs.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach_env">list_iforeach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_iforeach_env<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach$cont">list_iforeach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_iforeach$cont<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach$fwork">list_iforeach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_iforeach$fwork<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach2">list_iforeach2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_iforeach2<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">min</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="comment">// end-of-function</span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
applies to each tuple (i, xs[i], ys[i]) the function implemented by
<span class="patsyntaxdynexp">list_iforeach2$fwork</span>, where i ranges from 0 until min(m, n)-1,
inclusive, and xs[i] (ys[i]) refers to element i in xs (ys).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_iforeach2_env">list_iforeach2_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_iforeach2_env<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">min</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="comment">// end-of-function</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foldleft">list_foldleft</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_foldleft
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">res</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function return the value of f(...f(ini,
xs[0])..., xs[n-1]), where the notation xs[i] refers element i in xs and f
is the function implemented by <span class="patsyntaxdynexp">list_foldleft$fopr</span>.

<h3>Example</h3>

The following code computes factorial of n for a given natural number n:
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_14.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> factorial
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list_make_intrange <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> n<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span>
list_foldleft$fopr&lt;<span class="staexp">int</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>acc<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> acc * <span class="keyword">(</span>x+<span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> list_foldleft&lt;<span class="staexp">int</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="comment">(*ini*)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [factorial]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_foldleft$fopr">list_foldleft$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
res<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_foldleft$fopr<span class="keyword">(</span>acc<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">res</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_mergesort">list_mergesort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_mergesort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its argument according to the
ordering implemented by <span class="patsyntaxdynexp">list_mergesort$cmp</span> and returns a
linear list that is a sorted permutation of the argument. <h3>Example</h3>

The following code mergesorts a given list of integers into a list of
ascending integers and a list of descending integers.
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_15.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">10</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_mergesort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> ys_inc <span class="keyword">=</span> list_mergesort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"ys_inc = "</span><span class="keyword">,</span> ys_inc<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys_inc<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_mergesort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">~</span>compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> zs_dec <span class="keyword">=</span> list_mergesort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"zs_inc = "</span><span class="keyword">,</span> zs_dec<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>zs_dec<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_mergesort$cmp">list_mergesort$cmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_mergesort$cmp<span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span> <span class="comment">(* sign *)</span></pre>
<h3>Description</h3>

This function is called in the implementation of <span class="patsyntaxdynexp">list_mergesort</span> to
perform comparison test on list elements, and its default implementation is
based on <span class="patsyntaxdynexp">gcompare_val</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_16.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list_mergesort$cmp <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gcompare_val&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_quicksort">list_quicksort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list_quicksort<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its argument according to the ordering implemented by
<span class="patsyntaxdynexp">list_quicksort$cmp</span> and returns a linear list that is a sorted
permutation of the argument. <h3>Example</h3>

The following code quicksorts a given list of integers into a list of
ascending integers and a list of descending integers.
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_17.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">10</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> <span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span>
  <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  fprint_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_quicksort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> ys_inc <span class="keyword">=</span> list_quicksort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"ys_inc = "</span><span class="keyword">,</span> ys_inc<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys_inc<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_quicksort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">~</span>compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> zs_dec <span class="keyword">=</span> list_quicksort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"zs_dec = "</span><span class="keyword">,</span> zs_dec<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>zs_dec<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_quicksort$cmp">list_quicksort$cmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_quicksort$cmp<span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span> <span class="comment">(* sign *)</span></pre>
<h3>Description</h3>

This function is called in the implementation of <span class="patsyntaxdynexp">list_quicksort</span> to
perform comparison test on list elements, and its default implementation is
based on <span class="patsyntaxdynexp">gcompare_val</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_18.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list_quicksort$cmp <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gcompare_val&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="+">+</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> + <span class="keyword">with</span> list_append</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> list_get_at</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".head">.head</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>head <span class="keyword">with</span> list_head</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".tail">.tail</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>tail <span class="keyword">with</span> list_tail</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="iseqz">iseqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> list_is_nil</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="isneqz">isneqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> list_is_cons</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="length">length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> list_length</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="copy">copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> copy <span class="keyword">with</span> list_copy</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="print">print</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_list</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="prerr">prerr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_list</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint">fprint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list_sep</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

