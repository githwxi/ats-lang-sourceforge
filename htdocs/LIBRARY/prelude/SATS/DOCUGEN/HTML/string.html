
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/string</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/string</h1>

<p>
This package contains various common functions for processing (immutable)
strings.

</p> 

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#string_index_p">string_index_p</a></li>
<li><a href="#StringSubscriptExn">StringSubscriptExn</a></li>
<li><a href="#lemma_string_param">lemma_string_param</a></li>
<li><a href="#string2ptr">string2ptr</a></li>
<li><a href="#g0ofg1_string">g0ofg1_string</a></li>
<li><a href="#g1ofg0_string">g1ofg0_string</a></li>
<li><a href="#string_sing">string_sing</a></li>
<li><a href="#string_is_empty">string_is_empty</a></li>
<li><a href="#string_isnot_empty">string_isnot_empty</a></li>
<li><a href="#string_is_atend">string_is_atend</a></li>
<li><a href="#string_is_atend_gint">string_is_atend_gint</a></li>
<li><a href="#string_is_atend_guint">string_is_atend_guint</a></li>
<li><a href="#string_head">string_head</a></li>
<li><a href="#string_tail">string_tail</a></li>
<li><a href="#string_get_at">string_get_at</a></li>
<li><a href="#string_get_at_gint">string_get_at_gint</a></li>
<li><a href="#string_get_at_guint">string_get_at_guint</a></li>
<li><a href="#string_test_at">string_test_at</a></li>
<li><a href="#string_test_at_gint">string_test_at_gint</a></li>
<li><a href="#string_test_at_guint">string_test_at_guint</a></li>
<li><a href="#lt_string_string">lt_string_string</a></li>
<li><a href="#lte_string_string">lte_string_string</a></li>
<li><a href="#gt_string_string">gt_string_string</a></li>
<li><a href="#gte_string_string">gte_string_string</a></li>
<li><a href="#eq_string_string">eq_string_string</a></li>
<li><a href="#neq_string_string">neq_string_string</a></li>
<li><a href="#compare_string_string">compare_string_string</a></li>
<li><a href="#strcmp">strcmp</a></li>
<li><a href="#strintcmp">strintcmp</a></li>
<li><a href="#strlencmp">strlencmp</a></li>
<li><a href="#string_make_list">string_make_list</a></li>
<li><a href="#string_make_listlen">string_make_listlen</a></li>
<li><a href="#string_make_rlist">string_make_rlist</a></li>
<li><a href="#string_make_rlistlen">string_make_rlistlen</a></li>
<li><a href="#string_make_substring">string_make_substring</a></li>
<li><a href="#fprint_string">fprint_string</a></li>
<li><a href="#strchr">strchr</a></li>
<li><a href="#strrchr">strrchr</a></li>
<li><a href="#strstr">strstr</a></li>
<li><a href="#strspn">strspn</a></li>
<li><a href="#strcspn">strcspn</a></li>
<li><a href="#string_index">string_index</a></li>
<li><a href="#string_rindex">string_rindex</a></li>
<li><a href="#string_length">string_length</a></li>
<li><a href="#string0_length">string0_length</a></li>
<li><a href="#string1_length">string1_length</a></li>
<li><a href="#string0_copy">string0_copy</a></li>
<li><a href="#string1_copy">string1_copy</a></li>
<li><a href="#string_append">string_append</a></li>
<li><a href="#string0_append">string0_append</a></li>
<li><a href="#string1_append">string1_append</a></li>
<li><a href="#string_append3">string_append3</a></li>
<li><a href="#string0_append3">string0_append3</a></li>
<li><a href="#stringlst_concat">stringlst_concat</a></li>
<li><a href="#stringarr_concat">stringarr_concat</a></li>
<li><a href="#string_explode">string_explode</a></li>
<li><a href="#string_tabulate">string_tabulate</a></li>
<li><a href="#string_tabulate$fopr">string_tabulate$fopr</a></li>
<li><a href="#string_foreach">string_foreach</a></li>
<li><a href="#string_foreach_env">string_foreach_env</a></li>
<li><a href="#string_foreach$cont">string_foreach$cont</a></li>
<li><a href="#string_foreach$fwork">string_foreach$fwork</a></li>
<li><a href="#string_rforeach">string_rforeach</a></li>
<li><a href="#string_rforeach_env">string_rforeach_env</a></li>
<li><a href="#string_rforeach$cont">string_rforeach$cont</a></li>
<li><a href="#string_rforeach$fwork">string_rforeach$fwork</a></li>
<li><a href="#stropt_none">stropt_none</a></li>
<li><a href="#stropt_some">stropt_some</a></li>
<li><a href="#stropt_is_none">stropt_is_none</a></li>
<li><a href="#stropt_is_some">stropt_is_some</a></li>
<li><a href="#stropt_unsome">stropt_unsome</a></li>
<li><a href="#stropt_length">stropt_length</a></li>
<li><a href="#fprint_stropt">fprint_stropt</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#g0ofg1">g0ofg1</a></li>
<li><a href="#g1ofg0">g1ofg0</a></li>
<li><a href="#[]">[]</a></li>
<li><a href="#<"><</a></li>
<li><a href="#<="><=</a></li>
<li><a href="#>">></a></li>
<li><a href="#>=">>=</a></li>
<li><a href="#=">=</a></li>
<li><a href="#!=">!=</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#.head">.head</a></li>
<li><a href="#.tail">.tail</a></li>
<li><a href="#iseqz">iseqz</a></li>
<li><a href="#isneqz">isneqz</a></li>
<li><a href="#length">length</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#print">print</a></li>
<li><a href="#prerr">prerr</a></li>
<li><a href="#fprint">fprint</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="string_index_p">string_index_p</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">dataprop</span>
<span class="staexp">string_index_p
<span class="keyword">(</span>
  n<span class="keyword">:</span> int<span class="keyword">,</span> int<span class="comment">(*i*)</span><span class="keyword">,</span> int<span class="comment">(*c*)</span>
<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">string_index_p_eqz <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> i<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>int8 <span class="keyword">|</span> c != 0<span class="keyword">}</span></span>
    string_index_p_neqz <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span></span></span></pre>
<h3>Description</h3>

Given a string str of length n and an index i, <span class="patsyntaxstaexp">string_index_p(n,
i, c)</span> means that str[i] in the string is of the type <span class="patsyntaxstaexp">char(c)</span>.
If str[i] equals the null character, then i equals n.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="StringSubscriptExn">StringSubscriptExn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">exception</span> <span class="dynexp">StringSubscriptExn <span class="keyword">of</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_string_param">lemma_string_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_string_param<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string2ptr">string2ptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
string2ptr <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g0ofg1_string">g0ofg1_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> g0ofg1_string <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">String</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g1ofg0_string">g1ofg0_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> g1ofg0_string <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">String0</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_sing">string_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_sing <span class="keyword">(</span>chr<span class="keyword">:</span> <span class="staexp">charNZ</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function constructs a singleton string consisting of its char argument.
<h3>Return Value</h3>
A linear string of length 1 is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_is_empty">string_is_empty</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> string_is_empty<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This funtion returns true if and only if its string argument is empty.
<h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_isnot_empty">string_isnot_empty</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> string_isnot_empty<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This funtion returns true if and only if its string argument is non-empty.
<h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_is_atend">string_is_atend</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_is_atend <span class="keyword">with</span> string_is_atend_gint</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_is_atend <span class="keyword">with</span> string_is_atend_guint</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_is_atend_gint">string_is_atend_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_is_atend_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string of length n and an index i &lt;= n, this function returns true
if and only if i equals n.  <h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_is_atend_guint">string_is_atend_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_is_atend_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">i</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does the same as <span class="patsyntaxdynexp">string_is_atend_gint</span> except for
taking an unsigned integer as the string index.  <h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_head">string_head</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_head<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">charNZ</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_tail">string_tail</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_tail<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_get_at">string_get_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_get_at <span class="keyword">with</span> string_get_at_size <span class="keyword">of</span> 1</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_get_at <span class="keyword">with</span> string_get_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_get_at <span class="keyword">with</span> string_get_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_get_at_gint">string_get_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_get_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">charNZ</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, returns the char
stored in cell i of the given string.  Note that the given index i is
guranteed to be legal and the returned character is always non-null. <h3>Return Value</h3>
A non-null char is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_get_at_guint">string_get_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_get_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">charNZ</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, does the same as
<span class="patsyntaxdynexp">string_get_at_gint</span> except for taking an unsigned integer as the
string index.  <h3>Return Value</h3>
A non-null char is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_test_at">string_test_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_test_at <span class="keyword">with</span> string_test_at_size <span class="keyword">of</span> 1</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_test_at <span class="keyword">with</span> string_test_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_test_at <span class="keyword">with</span> string_test_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_test_at_gint">string_test_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_test_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">string_index_p</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">char</span> <span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string of length n and an index i &lt;= n, this function returns a
char c paired with a proof stating that i &lt; n holds if and only if c is
non-null. <h3>Return Value</h3>
A char is returned.<h3>Example</h3>

The following code implements a function for computing the length of a
given string:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_0.dats"><span class="dynexp"><span class="keyword">fun</span>
string1_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> NUL '\000'</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_string_param <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> c<span class="keyword">)</span> <span class="keyword">=</span> string_test_at <span class="keyword">(</span>str<span class="keyword">,</span> i<span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">if</span> c != NUL <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span>
    string_index_p_neqz <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> loop <span class="keyword">(</span>str<span class="keyword">,</span> succ<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> string_index_p_eqz <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> i <span class="comment">// HX: i equals n</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>str<span class="keyword">,</span> g1i2u<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [string1_length]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_test_at_guint">string_test_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk<span class="keyword">}</span></span>
string_test_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">string_index_p</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">char</span> <span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does the same as <span class="patsyntaxdynexp">string_test_at_gint</span> except for
taking an unsigned integer as the string index.  <h3>Return Value</h3>
A char is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lt_string_string">lt_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> lt_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is less than
its second argument according to the lexicographic ordering on signed
characters.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lte_string_string">lte_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> lte_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is less than
or equal to its second argument according to the lexicographic ordering on
signed characters.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="gt_string_string">gt_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> gt_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is greater
than its second argument according to the lexicographic ordering on
signed characters.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="gte_string_string">gte_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> gte_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is greater
than or equal to its second argument according to the lexicographic
ordering on signed characters.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="eq_string_string">eq_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> eq_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is equal to
its second argument according to the lexicographic ordering on
signed characters. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="neq_string_string">neq_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> neq_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns true if and only if its first argument is unequal
to its second argument according to the lexicographic ordering on signed
characters.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="compare_string_string">compare_string_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> compare_string_string
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Sgn</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function returns ~1, 0 and 1 if and only if its first argument is
less than, equal to and greater than its second argument according to the
lexicographic ordering on signed characters.
<h3>Return Value</h3>
An integer between ~1 (negative 1) and 1, inclusive, is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strcmp">strcmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> strcmp <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span></pre>
<h3>Description</h3>

This function returns a negative integer, 0 and a postive integer to
indicate that its first string argument is less than, equal to and greater
than its second string argument, respectively, where the comparison is
based on the lexicographic ordering on signed chars.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strintcmp">strintcmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> strintcmp
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int <span class="keyword">|</span> n2 &gt;=0<span class="keyword">}</span></span>
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n1</span><span class="keyword">,</span> n2<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">sgn</span><span class="keyword">(</span><span class="staexp">n1</span><span class="staexp">-</span><span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns ~1,0 and 1 to indicate that the length of its first
string argument is less than, equal to and greater than the value of its
second integer argument, respectively.  <h3>Return Value</h3>
An integer between ~1 (negative 1) and 1 is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strlencmp">strlencmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> strlencmp
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n1</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">sgn</span><span class="keyword">(</span><span class="staexp">n1</span><span class="staexp">-</span><span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns -1, 0 and 1 to indicate that the length of its first
string argument is less than, equal to and greater than the length of its
second string argument, respectively.
<h3>Return Value</h3>
An integer between ~1 (negative 1) and 1 is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_list">string_make_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_list
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">charNZ</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a linear string consisting of the same sequence of
non-null chars in its argument.  <h3>Return Value</h3>
A linear string is returned.<h3>Example</h3>

The following code implements a function that returns a linear string
consisting of the reverse of the sequence of chars in its argument:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_1.dats"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
string_reverse
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;&gt;.</span>
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_string_param <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span> string_explode <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span> list_vt_reverse <span class="keyword">(</span>cs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> string_make_list <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t<span class="keyword">(</span>cs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free <span class="keyword">(</span>cs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [string_reverse]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_listlen">string_make_listlen</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_listlen
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">charNZ</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does the same as <span class="patsyntaxdynexp">string_make_list</span> except for
taking the length of the given string as its second argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_rlist">string_make_rlist</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_rlist
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">charNZ</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a linear string consisting of the reverse of the
sequence of non-null chars in its argument.  <h3>Return Value</h3>
A linear string is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_rlistlen">string_make_rlistlen</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_rlistlen
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">charNZ</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does the same as <span class="patsyntaxdynexp">string_make_rlist</span> except for
taking the length of the given string as its second argument.  <h3>Return Value</h3>
A linear string is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_substring">string_make_substring</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_substring
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>st<span class="keyword">,</span>ln<span class="keyword">:</span>nat <span class="keyword">|</span> st+ln &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> st<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">st</span><span class="keyword">,</span> ln<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">ln</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">ln</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string str of length n and integers st and ln, this function
returns a string that equals the substring in str that starts at char st
and is of length ln.
<h3>Return Value</h3>
A linear string is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_string">fprint_string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> fprint_string <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function prints a string (its second argument) to a given output
channel (its first argument). The implementation of this function calls the
libc-function fputs declared in [stdio.h]. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strchr">strchr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
strchr<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssizeBtwe</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string str and a char c0, this function returns the index of the
first char in str that equals c0 if there is such a char.  Otherwise, it
returns ~1 (negative 1).  The implementation of this function in ATSLIB
calls the libc-function of the same name (declared in [string.h]).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strrchr">strrchr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
strrchr<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssizeBtwe</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string str and a char c0, this function returns the index of the
last char in str that equals c0 if there is such a char.  Otherwise, it
returns ~1 (negative 1).  The implementation of this function in ATSLIB
calls the libc-function of the same name (declared in [string.h]).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strstr">strstr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
strstr<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>haystack<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> needle<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssizeBtw</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string str1 and a string str2, this function returns the index of
the first substring in str1 that equals str2 if there is such a
substring. Otherwise, it returns ~1 (negative 1).  Note that the function
returns 0 in the special case where str2 is empty, The implementation of
this function in ATSLIB calls the libc-function of the same name (declared
in [string.h]).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strspn">strspn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
strspn<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="comment">// spanning</span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> accept<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strcspn">strcspn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
strcspn<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="comment">// complement spanning</span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> accept<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_index">string_index</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> string_index<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">charNZ</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssizeBtw</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the same as <span class="patsyntaxdynexp">strchr</span> except for requiring that
its second argument be a non-null char.  The implementation of this
function in ATSLIB calls the libc-function of the same name (declared in
[strings.h]).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_rindex">string_rindex</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> string_rindex<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp">charNZ</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssizeBtw</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the same as <span class="patsyntaxdynexp">strrchr</span> except for requiring that
its second argument be a non-null char.  The implementation of this
function in ATSLIB calls the libc-function of the same name (declared in
[strings.h]).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_length">string_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_length <span class="keyword">with</span> string0_length <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_length <span class="keyword">with</span> string1_length <span class="keyword">of</span> 10</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string0_length">string0_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string0_length
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">string_length</span>, computes
the length of a given string.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string1_length">string1_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string1_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">string_length</span>, does the
same as <span class="patsyntaxdynexp">string0_length</span> but is assigned a more informative type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string0_copy">string0_copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string0_copy
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span></span></pre>
<h3>Description</h3>
This function returns a linear string that is the copy of its argument.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string1_copy">string1_copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string1_copy
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function does the same as <span class="patsyntaxdynexp">string0_copy</span> but is assigned
a more accurate type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_append">string_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_append <span class="keyword">with</span> string0_append <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_append <span class="keyword">with</span> string0_append3 <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_append <span class="keyword">with</span> string0_append4 <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_append <span class="keyword">with</span> string0_append5 <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> string_append <span class="keyword">with</span> string0_append6 <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string0_append">string0_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string0_append
<span class="keyword">(</span>
  x1<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span></span> <span class="comment">// end-of-fun</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">string_append</span>,
returns a linear string equal to the concatenation of its two string
arguments. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string1_append">string1_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string1_append
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  x1<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">strnptr</span> <span class="keyword">(</span><span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span> <span class="comment">// end of [string1_append]</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">string_append</span>, does
the same as <span class="patsyntaxdynexp">string0_append</span> but is assigned a more informative
type.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_append3">string_append3</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [string_append3] is unavailable.</pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string0_append3">string0_append3</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string0_append3
<span class="keyword">(</span>
  x1<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> x3<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span></span> <span class="comment">// end-of-fun</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">string_append</span>,
returns a linear string equal to the concatenation of its three string
arguments. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stringlst_concat">stringlst_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stringlst_concat <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span></span></pre>
<h3>Description</h3>

This function returns a linear string that is the concatenation of the
strings in its argument. It is implemented based on
<span class="patsyntaxdynexp">stringarr_concat</span>.
<h3>Example</h3>

The following code builds a linear string "Hello" by concatenating five
singleton strings and then prints it (plus a newline) onto the standard
output channel:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_2.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
<span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">string</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynstr">"H"</span><span class="keyword">,</span> <span class="dynstr">"e"</span><span class="keyword">,</span> <span class="dynstr">"l"</span><span class="keyword">,</span> <span class="dynstr">"l"</span><span class="keyword">,</span> <span class="dynstr">"o"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> Hello <span class="keyword">=</span> stringlst_concat <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">fprintln!</span> <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> Hello<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> strptr_free <span class="keyword">(</span>Hello<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main] *)</span>
</pre>

Note that the created linear string is freed before the code exits.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stringarr_concat">stringarr_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stringarr_concat<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">arrayref</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span></span></pre>
<h3>Description</h3>

This function returns a linear string that is the concatenation of the
strings in its argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_explode">string_explode</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_explode
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">charNZ</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string of length n, this function returns a linear list
such that element i in the list equals char i in the string for
0 &lt;= i &lt; n.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_tabulate">string_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_tabulate<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given an integer n, this function returns a string of length n
such that char i in the string equals f(i) for 0 &lt;= i &lt n,
where f is the function implemented by <span class="patsyntaxdynexp">string_tabulate$fopr</span>.
<h3>Return Value</h3>
A linear string is returned.<h3>Example</h3>

The following code gives an implementation of
<span class="patsyntaxdynexp">string_make_substring</span>, which constructs a linear string
consisting of the chars in a segment of a given string:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_3.dats"><span class="comment">//</span>
<span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span>
string_make_substring
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>st<span class="keyword">,</span>ln<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">,</span> st<span class="keyword">,</span> ln<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
string_tabulate$fopr&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>sizeLt<span class="keyword">(</span>ln<span class="keyword">)</span><span class="keyword">}</span></span> <span class="keyword">(</span>i<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="dynexp">str[st+i<span class="keyword">]</span></span>
<span class="keyword">end</span></span> <span class="comment">// end of [string_tabulate$fopr]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span> <span class="keyword">(</span>string_tabulate <span class="keyword">(</span>ln<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [string_make_substring]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_tabulate$fopr">string_tabulate$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_tabulate$fopr <span class="keyword">(</span><span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">charNZ</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_foreach">string_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> string_foreach <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function traverses a given string from left to right and applies to
each encountered char the function implemented by
<span class="patsyntaxdynexp">string_foreach$fwork</span>. The traversal stops if the function
implemented by <span class="patsyntaxdynexp">string_foreach$cont</span> returns false.  <h3>Parameters</h3>
<ul><li><span class="patsyntaxdynexp">str</span> : the string to be traversed.</li></ul><h3>Return Value</h3>
The number of processed chars is returned.<h3>Example</h3>

The following code implements the function <span class="patsyntaxdynexp">strspn</span> that computes
the length of the longest prefix of a given string consisting of only chars
contained in the second argument of this function:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_4.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span>
strspn <span class="keyword">(</span>str<span class="keyword">,</span> accept<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> accept <span class="keyword">=</span> g1ofg0_string <span class="keyword">(</span>accept<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
string_foreach$cont <span class="keyword">(</span>c<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> strchr <span class="keyword">(</span>accept<span class="keyword">,</span> c<span class="keyword">)</span> &gt;= <span class="dynexp">0</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span> <span class="keyword">(</span>string_foreach&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>str<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [strspn]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_foreach_env">string_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> string_foreach_env
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">string_foreach</span>
except for taking an additional argument that serves as an environment.  <h3>Return Value</h3>
The number of processed chars is returned.<h3>Example</h3>
The following code implements a function that computes the value of an
unsigned integer represented as a sequence of digits (of base 10):

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_5.dats"><span class="dynexp"><span class="keyword">fun</span> atoi
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> g1ofg0_string <span class="keyword">(</span>str<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="dynexp"><span class="keyword">implement</span>
string_foreach$fwork&lt;<span class="staexp">int</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>c<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := <span class="dynexp">10</span> * env + <span class="keyword">(</span>c - <span class="dynexp">'0'</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> _ <span class="keyword">=</span> string_foreach_env&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>str<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  env
<span class="keyword">end</span></span> <span class="comment">// end of [atoi]</span>
</pre>

Note that this function assumes its string argument consisting of
a sequence of digits.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_foreach$cont">string_foreach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
string_foreach$cont <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_foreach$fwork">string_foreach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
string_foreach$fwork <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_rforeach">string_rforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_rforeach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function traverses a given string from right to left and applies to
each encountered char the function implemented by
<span class="patsyntaxdynexp">string_rforeach$fwork</span>. The traversal stops if the function
implemented by <span class="patsyntaxdynexp">string_rforeach$cont</span> returns false.

<h3>Return Value</h3>
The number of processed chars is returned.<h3>Example</h3>

The following code implements the function <span class="patsyntaxdynexp">strrchr</span> that finds
the index of the last occurrence of a char in a given string. If there is
no such occurrence, then ~1 (negative 1) is returned.

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_string_6.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span>
strrchr <span class="keyword">(</span>str<span class="keyword">,</span> c0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
string_rforeach$cont <span class="keyword">(</span>c<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> c0 != c</span>
<span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>string_rforeach&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>str<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> string_is_atend <span class="keyword">(</span>str<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">then</span> g1i2i<span class="keyword">(</span><span class="keyword">~</span><span class="dynexp">1</span><span class="keyword">)</span> <span class="keyword">else</span> g1u2i<span class="keyword">(</span>i<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [strrchr]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_rforeach_env">string_rforeach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> string_rforeach_env
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">string_rforeach</span>
except for taking an additional argument that serves as an environment.  <h3>Return Value</h3>
The number of processed chars is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_rforeach$cont">string_rforeach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
string_rforeach$cont<span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_rforeach$fwork">string_rforeach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
string_rforeach$fwork<span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_none">stropt_none</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> stropt_none <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stropt</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Return Value</h3>
The null pointer is returned as a stropt-value.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_some">stropt_some</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> stropt_some <span class="keyword">with</span> stropt0_some <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> stropt_some <span class="keyword">with</span> stropt1_some <span class="keyword">of</span> 10</span></pre>
<h3>Description</h3>
This function casts a string into a stropt-value.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_is_none">stropt_is_none</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> stropt_is_none<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">stropt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&lt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function tests whether a stropt-value (optional string) is null.  <h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_is_some">stropt_is_some</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> stropt_is_some<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">stropt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function tests whether a stropt-value (optional string) is non-null.  <h3>Return Value</h3>
A boolean value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_unsome">stropt_unsome</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
stropt_unsome<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="keyword">(</span>opt<span class="keyword">:</span> <span class="staexp">stropt</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function casts a non-null stropt-value (optional string) to a
string-value.  <h3>Return Value</h3>
A string is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stropt_length">stropt_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stropt_length<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>opt<span class="keyword">:</span> <span class="staexp">stropt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ssize_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function computes the length of a given stropt-value (optional
string). If the argument is the null pointer, then the returned value is ~1
(negative 1).
<h3>Return Value</h3>
A signed-size integer is returned.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_stropt">fprint_stropt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> fprint_stropt <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> opt<span class="keyword">:</span> <span class="staexp">Stropt0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>
This function prints a stropt-value (optional string) to a given output
channel (its first argument). If the stropt-value is not null, then it is
treated as a string. Otherwise, it is treated as the null pointer. <h3>Parameters</h3>
<ul><li><span class="patsyntaxdynexp">out</span> : the channel for receiving the output.</li><li><span class="patsyntaxdynexp">opt</span> : the optional string to be printed. Note that an optional string is either a
string or a null pointer.</li></ul><h3>Return Value</h3>
The void value is returned.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g0ofg1">g0ofg1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> g0ofg1 <span class="keyword">with</span> g0ofg1_string</span> <span class="comment">// index-erasing</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g1ofg0">g1ofg0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> g1ofg0 <span class="keyword">with</span> g1ofg0_string</span> <span class="comment">// index-inducing</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span>
<span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> string_get_at_size <span class="keyword">of</span> 1</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span>
<span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> string_get_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span>
<span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> string_get_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="<"><</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">&lt;</span> <span class="keyword">with</span> lt_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="<="><=</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> &lt;= <span class="keyword">with</span> lte_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=">">></a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">&gt;</span> <span class="keyword">with</span> gt_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=">=">>=</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> &gt;= <span class="keyword">with</span> gte_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="=">=</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">=</span> <span class="keyword">with</span> eq_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="!=">!=</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> != <span class="keyword">with</span> neq_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="compare">compare</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> compare <span class="keyword">with</span> compare_string_string</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".head">.head</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>head <span class="keyword">with</span> string_head</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".tail">.tail</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>tail <span class="keyword">with</span> string_tail</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="iseqz">iseqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> string_is_empty</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> stropt_is_none</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="isneqz">isneqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> string_isnot_empty</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> stropt_is_some</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="length">length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> string_length</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> stropt_length</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="copy">copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> copy <span class="keyword">with</span> string0_copy <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="print">print</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_string <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_stropt <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="prerr">prerr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_string <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_stropt <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint">fprint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_string <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_stropt <span class="keyword">of</span> 0</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

