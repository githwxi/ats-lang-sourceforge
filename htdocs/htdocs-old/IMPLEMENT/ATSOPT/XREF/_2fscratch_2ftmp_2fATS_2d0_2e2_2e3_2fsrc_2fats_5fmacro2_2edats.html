<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: February 2008
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Mainly for handling macro expansion during type-checking *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="extern">%{^
#include "ats_counter.cats" /* only needed for [ATS/Geizella] */
#include "ats_intinf.cats"  /* only needed for [ATS/Geizella] */
%}</span> <span class="comment">// end of [%{^]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">staload</span> <span class="staexp">IntInf <span class="keyword">=</span> "ats_intinf.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Loc <span class="keyword">=</span> "ats_location.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Lst <span class="keyword">=</span> "ats_list.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Stamp <span class="keyword">=</span> "ats_stamp.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Sym <span class="keyword">=</span> "ats_symbol.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Syn <span class="keyword">=</span> "ats_syntax.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_staexp2.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_dynexp2.sats"</span>

<span class="keyword">staload</span> <span class="staexp">TRAN2ENV <span class="keyword">=</span> "ats_trans2_env.sats"</span>

<span class="keyword">staload</span> <span class="staexp">"ats_macro2.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">overload</span> <span class="keyword">=</span> <span class="keyword">with</span> $Sym<span class="keyword">.</span>eq_symbol_symbol</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> prerr_loc_errmac <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>$Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": error(macro)"<span class="keyword">)</span>
<span class="comment">// end of [prerr_loc_errmac]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">datatype</span> <span class="staexp"><a name="2391"><span class="stacstdec">v2alue</span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> V2ALbool <span class="keyword">of</span> <span class="staexp">bool</span>
  <span class="keyword">|</span> V2ALchar <span class="keyword">of</span> <span class="staexp">char</span>
  <span class="keyword">|</span> V2ALcode <span class="keyword">of</span> <span class="staexp">d2exp</span>
  <span class="keyword">|</span> V2ALfloat <span class="keyword">of</span> <span class="staexp">string</span>
  <span class="keyword">|</span> V2ALint <span class="keyword">of</span> <span class="staexp">intinf_t</span>
  <span class="keyword">|</span> V2ALlst <span class="keyword">of</span> <span class="staexp">v2aluelst</span>
  <span class="keyword">|</span> V2ALstring <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>string<span class="keyword">,</span> int<span class="comment">(*length*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> V2ALunit
<span class="comment">// end of [v2alue]
</span>
<span class="keyword">where</span> <span class="staexp"><a name="2618"><span class="stacstdec">v2aluelst <span class="keyword">=</span> List v2alue</span></a></span>

<span class="keyword">viewtypedef</span> <span class="staexp"><a name="2655"><span class="stacstdec">v2alueopt_vt <span class="keyword">=</span> Option_vt v2alue</span></a></span>

<span class="keyword">val</span> v2alue_bool_true <span class="keyword">=</span> V2ALbool <span class="keyword">(</span>true<span class="keyword">)</span>
<span class="keyword">val</span> v2alue_bool_false <span class="keyword">=</span> V2ALbool <span class="keyword">(</span>false<span class="keyword">)</span>

<span class="keyword">fun</span> fprint_v2alue <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span> w<span class="keyword">)</span></span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">macdef</span> <span class="neuexp">prstr <span class="keyword">(</span>s<span class="keyword">)</span> <span class="keyword">=</span> fprint1_string <span class="keyword">(</span>pf <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">,(</span>s<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALbool b <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALbool("<span class="keyword">;</span> fprint1_bool <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> b<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALbool]
</span>  <span class="keyword">|</span> V2ALchar <span class="keyword">(</span>c<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALchar("<span class="keyword">;</span> fprint1_char <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> c<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALchar]
</span>  <span class="keyword">|</span> V2ALcode <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALcode("<span class="keyword">;</span> fprint_d2exp <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> d2e<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALcode]
</span>  <span class="keyword">|</span> V2ALfloat f<span class="comment">(*string*)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALfloat("<span class="keyword">;</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALfloat]
</span>  <span class="keyword">|</span> V2ALint <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALint("<span class="keyword">;</span> $IntInf<span class="keyword">.</span>fprint_intinf <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALint]
</span>  <span class="keyword">|</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "V2ALlst("<span class="keyword">;</span> fprint_v2aluelst <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> vs<span class="keyword">)</span><span class="keyword">;</span> prstr ")"
    <span class="keyword">end</span> <span class="comment">// end of [V2ALlst]
</span>  <span class="keyword">|</span> V2ALstring <span class="keyword">(</span>str<span class="keyword">,</span> len<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprintf1_exn <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "V2ALstring(\"%s\", %i)"<span class="keyword">,</span> <span class="keyword">@(</span>str<span class="keyword">,</span> len<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">(* end of [V2ALstring] *)</span>
  <span class="keyword">|</span> V2ALunit <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "V2ALunit()"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">(* end of [V2ALunit] *)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_v2alue]
</span>
<span class="keyword">and</span> fprint_v2aluelst <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span> w<span class="keyword">)</span></span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> vs<span class="keyword">:</span> <span class="staexp">v2aluelst</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop
    <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> vs<span class="keyword">:</span> <span class="staexp">v2aluelst</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> vs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>v<span class="keyword">,</span> vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>out<span class="keyword">,</span> vs<span class="keyword">,</span> i+1<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">(</span>i <span class="keyword">&gt;</span> 0<span class="keyword">)</span> <span class="keyword">then</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ", "<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_v2alue <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> v<span class="keyword">)</span>
      <span class="keyword">}</span> <span class="comment">// end of [list_cons]  
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [list_nil]
</span>  <span class="comment">// end of [loop]  
</span><span class="keyword">in</span>
  loop <span class="keyword">(</span>out<span class="keyword">,</span> vs<span class="keyword">,</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_v2aluelst]
</span>
<span class="keyword">fn</span> print_v2alue <span class="keyword">(</span>v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_v2alue<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="neuexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_v2alue</span>

<span class="keyword">fn</span> prerr_v2alue <span class="keyword">(</span>v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> prerr_mac <span class="keyword">(</span>fprint_v2alue<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="neuexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_v2alue</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> lift_val_exp
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2exp</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALchar c <span class="keyword">=&gt;</span> d2exp_char <span class="keyword">(</span>loc0<span class="keyword">,</span> c<span class="keyword">)</span>
  <span class="keyword">|</span> V2ALint int <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d2exp_int <span class="keyword">(</span>loc0<span class="keyword">,</span> $IntInf<span class="keyword">.</span>tostring_intinf int<span class="keyword">,</span> int<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> V2ALfloat f<span class="comment">(*string*)</span> <span class="keyword">=&gt;</span> d2exp_float <span class="keyword">(</span>loc0<span class="keyword">,</span> f<span class="keyword">)</span>
  <span class="keyword">|</span> V2ALstring <span class="keyword">(</span>str<span class="keyword">,</span> len<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2exp_string <span class="keyword">(</span>loc0<span class="keyword">,</span> str<span class="keyword">,</span> len<span class="keyword">)</span>
  <span class="keyword">|</span> V2ALunit <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2exp_empty <span class="keyword">(</span>loc0<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": a value representing code (abstract syntax tree) cannot be lifted."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [lift_val_exp]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataviewtype</span> <span class="staexp"><a name="5307"><span class="stacstdec">alphaenv</span></a></span> <span class="keyword">=</span> 
  <span class="keyword">|</span> ALPHAENVcons <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>stamp_t<span class="keyword">,</span> d2var_t<span class="keyword">,</span> alphaenv<span class="keyword">)</span></span>
  <span class="keyword">|</span> ALPHAENVmark <span class="keyword">of</span> <span class="staexp">alphaenv</span>
  <span class="keyword">|</span> ALPHAENVnil
<span class="comment">// end of [alphaenv]
</span>
<span class="keyword">fun</span> alphaenv_free <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp">alphaenv</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> env <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVcons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=&gt;</span> alphaenv_free env
  <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVmark env <span class="keyword">=&gt;</span> alphaenv_free env
  <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [alphaenv_free]
</span>
<span class="keyword">fn</span> alphaenv_add
  <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp">alphaenv</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">,</span> d2v_new<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">alphaenv</span> <span class="keyword">=</span>
  ALPHAENVcons <span class="keyword">(</span>d2var_stamp_get d2v<span class="keyword">,</span> d2v_new<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="comment">// end of [alphaenv_add]
</span>
<span class="keyword">fn</span> alphaenv_find
  <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>alphaenv</span><span class="keyword">,</span> d2v0<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt <span class="keyword">(</span>d2var_t<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>alphaenv</span><span class="keyword">,</span> stamp0<span class="keyword">:</span> <span class="staexp">stamp_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt <span class="keyword">(</span>d2var_t<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case+</span> env <span class="keyword">of</span>
  <span class="keyword">|</span> ALPHAENVcons <span class="keyword">(</span>stamp<span class="keyword">,</span> d2v<span class="keyword">,</span> <span class="keyword">!</span>env_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> ans <span class="keyword">=</span> <span class="keyword">(</span>
        <span class="keyword">if</span> $Stamp<span class="keyword">.</span>eq_stamp_stamp <span class="keyword">(</span>stamp<span class="keyword">,</span> stamp0<span class="keyword">)</span> <span class="keyword">then</span> Some_vt d2v
        <span class="keyword">else</span> aux <span class="keyword">(</span><span class="keyword">!</span>env_nxt<span class="keyword">,</span> stamp0<span class="keyword">)</span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt d2var_t</span> <span class="comment">// end of [if]
</span>    <span class="keyword">in</span>
      fold@ env<span class="keyword">;</span> ans
    <span class="keyword">end</span>
  <span class="keyword">|</span> ALPHAENVmark <span class="keyword">(</span><span class="keyword">!</span>env_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> ans <span class="keyword">=</span> aux <span class="keyword">(</span><span class="keyword">!</span>env_nxt<span class="keyword">,</span> stamp0<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ env<span class="keyword">;</span> ans
    <span class="keyword">end</span>
  <span class="keyword">|</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ env<span class="keyword">;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span>env<span class="keyword">,</span> d2var_stamp_get d2v0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [alphaenv_find]
</span>
<span class="keyword">fn</span> alphaenv_insert
  <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">,</span> d2v_new<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>env := ALPHAENVcons <span class="keyword">(</span>d2var_stamp_get d2v<span class="keyword">,</span> d2v_new<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">)</span>

<span class="keyword">fun</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp">alphaenv</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">alphaenv</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> env <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVcons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux env
    <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVmark env <span class="keyword">=&gt;</span> env
    <span class="keyword">|</span> <span class="keyword">~</span>ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  env := aux <span class="keyword">(</span>env<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [alphaenv_pop]
</span>
<span class="keyword">fn</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span>env := ALPHAENVmark env<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="6941"><span class="dyncstdec">d2var_copy
  <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2var_t</span></span></a>
<span class="keyword">implement</span> d2var_copy <span class="keyword">(</span>loc<span class="keyword">,</span> d2v<span class="keyword">)</span> <span class="keyword">=</span> d2v

<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// eval0: evaluation at level 0
</span><span class="comment">// eval1: evaluation at level 1
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="7153"><span class="dyncstdec">eval1_p2at
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> p2t0<span class="keyword">:</span> <span class="staexp">p2at</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">p2at</span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="7226"><span class="dyncstdec">eval1_p2atlst <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> p2ts<span class="keyword">:</span> <span class="staexp">p2atlst n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">p2atlst n</span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="7320"><span class="dyncstdec">eval1_labp2atlst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> lp2ts<span class="keyword">:</span> <span class="staexp">labp2atlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">labp2atlst</span></span></a>

<span class="keyword">implement</span>
eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> p2t0<span class="keyword">.</span>p2at_node <span class="keyword">of</span>
  <span class="keyword">|</span> P2Tann <span class="keyword">(</span>p2t<span class="keyword">,</span> s2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_ann <span class="keyword">(</span>loc0<span class="keyword">,</span> p2t<span class="keyword">,</span> s2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tann]
</span>  <span class="keyword">|</span> P2Tany <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> p2at_any <span class="keyword">(</span>loc0<span class="keyword">)</span>
  <span class="keyword">|</span> P2Tas <span class="keyword">(</span>refknd<span class="keyword">,</span> d2v<span class="keyword">,</span> p2t<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2v_new <span class="keyword">=</span> d2var_copy <span class="keyword">(</span>loc0<span class="keyword">,</span> d2v<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_insert <span class="keyword">(</span>env<span class="keyword">,</span> d2v<span class="keyword">,</span> d2v_new<span class="keyword">)</span>
      <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_as <span class="keyword">(</span>loc0<span class="keyword">,</span> refknd<span class="keyword">,</span> d2v_new<span class="keyword">,</span> p2t<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tas]
</span>  <span class="keyword">|</span> P2Tcon <span class="keyword">(</span>freeknd<span class="keyword">,</span> d2c<span class="keyword">,</span> s2qs<span class="keyword">,</span> s2e<span class="keyword">,</span> npf<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//
</span><span class="comment">// HX-2010-03-24:
</span><span class="comment">// this is necessary for handling the static arguments
</span><span class="comment">//
</span>      <span class="keyword">var</span> sub<span class="keyword">:</span> <span class="staexp">stasub_t</span> <span class="keyword">=</span> stasub_nil
      <span class="keyword">val</span> s2qs <span class="keyword">=</span> aux <span class="keyword">(</span>s2qs<span class="keyword">,</span> sub<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">fun</span> aux <span class="keyword">(</span>s2qs<span class="keyword">:</span> <span class="staexp">s2qualst</span><span class="keyword">,</span> sub<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>stasub_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">s2qualst</span> <span class="keyword">=</span>
          <span class="keyword">case+</span> s2qs <span class="keyword">of</span>
          <span class="keyword">|</span> list_cons <span class="keyword">(</span>s2q<span class="keyword">,</span> s2qs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
              <span class="keyword">val</span> subs2vs <span class="keyword">=</span> stasub_extend_svarlst <span class="keyword">(</span>sub<span class="keyword">,</span> s2q<span class="keyword">.</span>0<span class="keyword">)</span>
              <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sub := subs2vs<span class="keyword">.</span>0
              <span class="keyword">val</span> s2vs <span class="keyword">=</span> subs2vs<span class="keyword">.</span>1
              <span class="keyword">val</span> s2ps <span class="keyword">=</span> s2explst_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2q<span class="keyword">.</span>1<span class="keyword">)</span>
              <span class="keyword">val</span> s2q <span class="keyword">=</span> <span class="keyword">(</span>s2vs<span class="keyword">,</span> s2ps<span class="keyword">)</span>
            <span class="keyword">in</span>
              list_cons <span class="keyword">(</span>s2q<span class="keyword">,</span> aux <span class="keyword">(</span>s2qs<span class="keyword">,</span> sub<span class="keyword">)</span><span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>          <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">}</span> <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> s2e <span class="keyword">=</span> s2exp_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2e<span class="keyword">)</span>
<span class="comment">//
</span>      <span class="keyword">val</span> p2ts <span class="keyword">=</span> eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_con <span class="keyword">(</span>loc0<span class="keyword">,</span> freeknd<span class="keyword">,</span> d2c<span class="keyword">,</span> s2qs<span class="keyword">,</span> s2e<span class="keyword">,</span> npf<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tcon]
</span>  <span class="keyword">|</span> P2Tempty <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> p2at_empty <span class="keyword">(</span>loc0<span class="keyword">)</span>
  <span class="keyword">|</span> P2Texist <span class="keyword">(</span>s2vs<span class="keyword">,</span> p2t<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_exist <span class="keyword">(</span>loc0<span class="keyword">,</span> s2vs<span class="keyword">,</span> p2t<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Texist]
</span>  <span class="keyword">|</span> P2Tlist <span class="keyword">(</span>npf<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> p2ts <span class="keyword">=</span> eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_list <span class="keyword">(</span>loc0<span class="keyword">,</span> npf<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tlist]
</span>  <span class="keyword">|</span> P2Tlst <span class="keyword">(</span>p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> p2ts <span class="keyword">=</span> eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_lst <span class="keyword">(</span>loc0<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tlst]
</span>  <span class="keyword">|</span> P2Trec <span class="keyword">(</span>recknd<span class="keyword">,</span> npf<span class="keyword">,</span> lp2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> lp2ts <span class="keyword">=</span> eval1_labp2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> lp2ts<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_rec <span class="keyword">(</span>loc0<span class="keyword">,</span> recknd<span class="keyword">,</span> npf<span class="keyword">,</span> lp2ts<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Trec]
</span>  <span class="keyword">|</span> P2Tvar <span class="keyword">(</span>refknd<span class="keyword">,</span> d2v<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2v_new <span class="keyword">=</span> d2var_copy <span class="keyword">(</span>loc0<span class="keyword">,</span> d2v<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_insert <span class="keyword">(</span>env<span class="keyword">,</span> d2v<span class="keyword">,</span> d2v_new<span class="keyword">)</span>
    <span class="keyword">in</span>
      p2at_var <span class="keyword">(</span>loc0<span class="keyword">,</span> refknd<span class="keyword">,</span> d2v_new<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P2Tvar]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> p2t0 <span class="keyword">where</span> <span class="keyword">{</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
        print "eval1_p2at: p2t0 = "<span class="keyword">;</span> print_p2at p2t0<span class="keyword">;</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [val]
</span>    <span class="keyword">}</span> <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [eval1_p2at]
</span>
<span class="keyword">implement</span>
eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> p2ts<span class="keyword">:</span> <span class="staexp">p2atlst n</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>p2atlst? &gt;&gt; p2atlst n</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> p2ts <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>p2t<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := list_cons <span class="staexp"><span class="keyword">{</span>p2at<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>p2t<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">p2atlst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_p2atlst]
</span>
<span class="keyword">implement</span>
eval1_labp2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> lp2ts<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> lp2ts<span class="keyword">:</span> <span class="staexp">labp2atlst</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>labp2atlst? &gt;&gt; labp2atlst</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> lp2ts <span class="keyword">of</span>
    <span class="keyword">|</span> LABP2ATLSTcons <span class="keyword">(</span>l<span class="keyword">,</span> p2t<span class="keyword">,</span> lp2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := LABP2ATLSTcons <span class="keyword">(</span>l<span class="keyword">,</span> p2t<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> LABP2ATLSTcons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> lp2ts<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> LABP2ATLSTdot <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := LABP2ATLSTdot <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> LABP2ATLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := LABP2ATLSTnil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">labp2atlst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> lp2ts<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_labp2atlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataviewtype</span> <span class="staexp"><a name="11196"><span class="stacstdec">eval0ctx</span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> EVAL0CTXcons <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>stamp_t<span class="keyword">,</span> v2alue<span class="keyword">,</span> eval0ctx<span class="keyword">)</span></span>
  <span class="keyword">|</span> EVAL0CTXnil
<span class="comment">// end of [eval0ctx]
</span>
<span class="keyword">fun</span> eval0ctx_free <span class="keyword">(</span>ctx<span class="keyword">:</span> <span class="staexp">eval0ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> ctx <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>EVAL0CTXcons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> ctx<span class="keyword">)</span> <span class="keyword">=&gt;</span> eval0ctx_free ctx
  <span class="keyword">|</span> <span class="keyword">~</span>EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0ctx_free]
</span>
<span class="keyword">fn</span> eval0ctx_add
  <span class="keyword">(</span>ctx<span class="keyword">:</span> <span class="staexp">eval0ctx</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">eval0ctx</span> <span class="keyword">=</span>
  EVAL0CTXcons <span class="keyword">(</span>d2var_stamp_get d2v<span class="keyword">,</span> v2al<span class="keyword">,</span> ctx<span class="keyword">)</span>
<span class="comment">// end of [eval0ctx_add]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> fprint_eval0ctx <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span> w<span class="keyword">)</span></span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ctx <span class="keyword">of</span>
  <span class="keyword">|</span> EVAL0CTXcons <span class="keyword">(</span>stamp<span class="keyword">,</span> v2al<span class="keyword">,</span> <span class="keyword">!</span>ctx_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      $Stamp<span class="keyword">.</span>fprint_stamp <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> stamp<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> " -&gt; "<span class="keyword">)</span><span class="keyword">;</span>
      fprint_v2alue <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> v2al<span class="keyword">)</span><span class="keyword">;</span>
      fprint_newline <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">)</span><span class="keyword">;</span>
      fprint_eval0ctx <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>ctx_nxt<span class="keyword">)</span><span class="keyword">;</span>
      fold@ ctx
    <span class="keyword">end</span> <span class="comment">// end of [EVAL0CTXcons]
</span>  <span class="keyword">|</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ ctx<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_eval0ctx]
</span>
<span class="keyword">fn</span> print_eval0ctx <span class="keyword">(</span>ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_eval0ctx<span class="keyword">,</span> ctx<span class="keyword">)</span>
<span class="neuexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_eval0ctx</span>

<span class="keyword">fn</span> prerr_eval0ctx <span class="keyword">(</span>ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> prerr_mac <span class="keyword">(</span>fprint_eval0ctx<span class="keyword">,</span> ctx<span class="keyword">)</span>
<span class="neuexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_eval0ctx</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="12380"><span class="dyncstdec">eval0_exp
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2e<span class="keyword">:</span> <span class="staexp">d2exp</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="12470"><span class="dyncstdec">eval0_labexplst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> ld2e<span class="keyword">:</span> <span class="staexp">labd2explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2aluelst</span></span></a>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="12597"><span class="dyncstdec">eval0_exp_app_mac_long <span class="staexp"><span class="keyword">{</span>narg<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> d2m<span class="keyword">:</span> <span class="staexp">d2mac_t narg</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
  <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp">d2exparglst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span></span></a>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="12756"><span class="dyncstdec">eval0_exp_app_mac_short <span class="staexp"><span class="keyword">{</span>narg<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> d2m<span class="keyword">:</span> <span class="staexp">d2mac_t narg</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
  <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp">d2exparglst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2exp</span></span></a>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// not qualified dynamic symbol
</span><span class="keyword">fn</span> d2sym_is_nonqua <span class="keyword">(</span>d2s<span class="keyword">:</span> <span class="staexp">d2sym</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> q <span class="keyword">=</span> d2s<span class="keyword">.</span>d2sym_qua
<span class="keyword">in</span>
  <span class="keyword">case+</span> q<span class="keyword">.</span>d0ynq_node <span class="keyword">of</span> $Syn<span class="keyword">.</span>D0YNQnone <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> false
<span class="keyword">end</span> <span class="comment">// end of [d2sym_is_nonqua]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="13156"><span class="dyncstdec">eval0_exp_app_sym <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> sym<span class="keyword">:</span> <span class="staexp">sym_t</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
  <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp">d2exparglst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span></span></a>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval0_exp_app_compare_sgn
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": values that do not support comparison are compared."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>Sgn<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> v2al1 <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALint i1 <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v2al2 <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALint i2 <span class="keyword">=&gt;</span> $IntInf<span class="keyword">.</span>compare_intinf_intinf <span class="keyword">(</span>i1<span class="keyword">,</span> i2<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [V2ALint]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_compare]
</span>
<span class="keyword">fn</span> eval0_exp_app_gt
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_gt]
</span>
<span class="keyword">fn</span> eval0_exp_app_gte
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn &gt;= 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_gte]
</span>
<span class="keyword">fn</span> eval0_exp_app_lt
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_lt]
</span>
<span class="keyword">fn</span> eval0_exp_app_lte
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn &lt;= 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_lte]
</span>
<span class="keyword">fn</span> eval0_exp_app_eq
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn <span class="keyword">=</span> 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_eq]
</span>
<span class="keyword">fn</span> eval0_exp_app_neq
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> eval0_exp_app_compare_sgn <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn &lt;&gt; 0 <span class="keyword">then</span> v2alue_bool_true <span class="keyword">else</span> v2alue_bool_false
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_neq]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval0_exp_app_neg
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": negation is performed on a value that does not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALbool b <span class="keyword">=&gt;</span> <span class="keyword">if</span> b <span class="keyword">then</span> v2alue_bool_false <span class="keyword">else</span> v2alue_bool_true
  <span class="keyword">|</span> V2ALint i <span class="keyword">=&gt;</span> V2ALint <span class="keyword">(</span>$IntInf<span class="keyword">.</span>neg_intinf i<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_add]
</span>
<span class="keyword">fn</span> eval0_exp_app_add
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": addition is performed on values that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> v2al1 <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALint i1 <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v2al2 <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALint i2 <span class="keyword">=&gt;</span> V2ALint <span class="keyword">(</span>$IntInf<span class="keyword">.</span>add_intinf_intinf <span class="keyword">(</span>i1<span class="keyword">,</span> i2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [V2ALint]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_add]
</span>
<span class="keyword">fn</span> eval0_exp_app_sub
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": subtraction is performed on values that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> v2al1 <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALint i1 <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v2al2 <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALint i2 <span class="keyword">=&gt;</span> V2ALint <span class="keyword">(</span>$IntInf<span class="keyword">.</span>sub_intinf_intinf <span class="keyword">(</span>i1<span class="keyword">,</span> i2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [V2ALint]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_sub]
</span>
<span class="keyword">fn</span> eval0_exp_app_mul
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al1<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">,</span> v2al2<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": multiplication is performed on values that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> v2al1 <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALint i1 <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v2al2 <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALint i2 <span class="keyword">=&gt;</span> V2ALint <span class="keyword">(</span>$IntInf<span class="keyword">.</span>mul_intinf_intinf <span class="keyword">(</span>i1<span class="keyword">,</span> i2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [V2ALint]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_mul]
</span>
<span class="comment">(*
fn eval0_exp_app_div
  (loc0: loc_t, v2al1: v2alue, v2al2: v2alue): v2alue = let
  fn err (loc0: loc_t, v2al1: v2alue, v2al2: v2alue): v2alue = begin
    prerr_loc_errmac loc0;
    prerr ": division is performed on values that do not support it.";
    prerr_newline ();
    $Err.abort {v2alue} ()
  end // end of [err]
in
  case+ v2al1 of
  | V2ALint i1 =&gt; begin case+ v2al2 of
    | V2ALint i2 =&gt; V2ALint (i1 / i2) | _ =&gt; err (loc0, v2al1, v2al2)
    end
  | _ =&gt; err (loc0, v2al1, v2al2)
end // end of [eval0_exp_app_div]
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval0_exp_app_is_nil
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": [is_nil] is performed on a value that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> vs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> v2alue_bool_false <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> v2alue_bool_true
    <span class="keyword">end</span> <span class="comment">(* end of [V2ALlst] *)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_is_nil]
</span>
<span class="keyword">fn</span> eval0_exp_app_is_cons
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": [is_cons] is performed on a value that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> vs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> v2alue_bool_false <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> v2alue_bool_true
    <span class="keyword">end</span> <span class="comment">(* end of [V2ALlst] *)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_is_cons]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval0_exp_app_tup_head
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_tup_head: v2al = "; print v2al; print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": [tup_head] is performed on a value that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
  <span class="keyword">val</span> ret <span class="keyword">=</span> <span class="keyword">case+</span> v2al <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> vs <span class="keyword">of</span>
      <span class="keyword">|</span> list_cons <span class="keyword">(</span>v<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> v <span class="keyword">|</span> list_nil _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">(* end of [V2ALlst] *)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_tup_head: ret = "; print ret; print_newline ()
  end // end of [val]
*)</span>
<span class="keyword">in</span>
  ret <span class="comment">// the return value
</span><span class="keyword">end</span> <span class="comment">(* end of [eval0_exp_app_tup_head] *)</span>

<span class="keyword">fn</span> eval0_exp_app_tup_tail <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_tup_tail: v2al = "; print v2al; print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": [tup_tail] is performed on a value that do not support it."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [err]
</span>  <span class="keyword">val</span> ret <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> v2al <span class="keyword">of</span>
    <span class="keyword">|</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> vs <span class="keyword">of</span>
      <span class="keyword">|</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> V2ALlst <span class="keyword">(</span>vs<span class="keyword">)</span> <span class="keyword">|</span> list_nil _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">(* end of [V2ALlst] *)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="comment">// end of [val]
</span><span class="comment">(*
  val () = begin
    print "eval0_exp_app_tup_tail: ret = "; print ret; print_newline ()
  end // end of [val]
*)</span>
<span class="keyword">in</span>
  ret <span class="comment">// the return value
</span><span class="keyword">end</span> <span class="comment">(* end of [eval0_exp_app_tup_tail] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval0_exp_app_eval
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": evaluation is performed on a value not representing code."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALcode d2e <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">var</span> ctx <span class="keyword">=</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">var</span> env <span class="keyword">=</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> v2al_res <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_free env
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free ctx
    <span class="keyword">in</span>
      v2al_res
    <span class="keyword">end</span> <span class="comment">// end of [V2ALcode]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">(* end of [eval0_exp_app_eval] *)</span>

<span class="keyword">fn</span> eval0_exp_app_lift
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  V2ALcode <span class="keyword">(</span>lift_val_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_lift]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="21600"><span class="dyncstdec">eval1_d2exp
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2e0<span class="keyword">:</span> <span class="staexp">d2exp</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2exp</span></span></a>
<span class="comment">// end of [eval1_d2exp]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="21716"><span class="dyncstdec">eval1_d2explst <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2es<span class="keyword">:</span> <span class="staexp">d2explst n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2explst n</span></span></a>
<span class="comment">// end of [eval1_d2explst]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="21856"><span class="dyncstdec">eval1_d2explstlst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2ess<span class="keyword">:</span> <span class="staexp">d2explstlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2explstlst</span></span></a>
<span class="comment">// end of [eval1_d2explstlst]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="21997"><span class="dyncstdec">eval1_labd2explst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> ld2es<span class="keyword">:</span> <span class="staexp">labd2explst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">labd2explst</span></span></a>
<span class="comment">// end of [eval1_labd2explst]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="22138"><span class="dyncstdec">eval1_d2ec
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2c0<span class="keyword">:</span> <span class="staexp">d2ec</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2ec</span></span></a>
<span class="comment">// end of [eval1_d2ec]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="22250"><span class="dyncstdec">eval1_d2eclst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2cs<span class="keyword">:</span> <span class="staexp">d2eclst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2eclst</span></span></a>
<span class="comment">// end of [eval1_d2eclst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> eval0_var <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": the variable ["<span class="keyword">;</span> prerr d2v<span class="keyword">;</span> prerr "] is unbound."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
  <span class="keyword">fun</span> auxfind
    <span class="keyword">(</span>ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> stamp0<span class="keyword">:</span> <span class="staexp">stamp_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">v2alue</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> ctx <span class="keyword">of</span>
    <span class="keyword">|</span> EVAL0CTXcons <span class="keyword">(</span>stamp<span class="keyword">,</span> v2al<span class="keyword">,</span> <span class="keyword">!</span>ctx_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> ans<span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
          <span class="keyword">if</span> $Stamp<span class="keyword">.</span>eq_stamp_stamp <span class="keyword">(</span>stamp<span class="keyword">,</span> stamp0<span class="keyword">)</span> <span class="keyword">then</span> v2al
          <span class="keyword">else</span> auxfind <span class="keyword">(</span><span class="keyword">!</span>ctx_nxt<span class="keyword">,</span> stamp0<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">in</span>
        fold@ ctx<span class="keyword">;</span> ans
      <span class="keyword">end</span>
    <span class="keyword">|</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ ctx<span class="keyword">;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> d2v<span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [auxfind]
</span><span class="keyword">in</span>
  auxfind <span class="keyword">(</span>ctx<span class="keyword">,</span> d2var_stamp_get d2v<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">(* end of [eval0_var] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp: d2e0 = "; print_d2exp d2e0; print_newline ()
  end // end of [val]
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> d2e0<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D2Eapps <span class="keyword">(</span>d2e<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> d2e<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D2Emac d2m <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="comment">// expanding a macro in long form
</span>        eval0_exp_app_mac_long <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D2Emac]
</span>    <span class="keyword">|</span> D2Esym d2s <span class="keyword">when</span> d2sym_is_nonqua d2s <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="comment">// evaluating a predefined function (e.g., +, -, etc.)
</span>        eval0_exp_app_sym <span class="keyword">(</span>loc0<span class="keyword">,</span> d2s<span class="keyword">.</span>d2sym_sym<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D2Esym]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_errmac loc0<span class="keyword">;</span>
        prerr ": the dynamic expression ("<span class="keyword">;</span>
        $Loc<span class="keyword">.</span>prerr_location d2e<span class="keyword">.</span>d2exp_loc<span class="keyword">;</span>
        prerr ") should be a macro but it is not."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">// end of [D2Eapps]
</span>  <span class="keyword">|</span> D2Echar chr <span class="keyword">=&gt;</span> V2ALchar chr
  <span class="keyword">|</span> D2Efloat f<span class="comment">(*string*)</span> <span class="keyword">=&gt;</span> V2ALfloat f
  <span class="keyword">|</span> D2Eif <span class="keyword">(</span>_<span class="comment">(*inv*)</span><span class="keyword">,</span> d2e_cond<span class="keyword">,</span> d2e_then<span class="keyword">,</span> od2e_else<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> v2al_cond <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_cond<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> v2al_cond <span class="keyword">of</span>
      <span class="keyword">|</span> V2ALbool b <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          <span class="keyword">if</span> b <span class="keyword">then</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_then<span class="keyword">)</span>
          <span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">case+</span> od2e_else <span class="keyword">of</span>
          <span class="keyword">|</span> Some d2e_else <span class="keyword">=&gt;</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_else<span class="keyword">)</span>
          <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> V2ALunit <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="comment">// end of [V2ALbool]
</span>      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_errmac loc0<span class="keyword">;</span>
          prerr ": the expansion of the dynamic expression ("<span class="keyword">;</span>
          $Loc<span class="keyword">.</span>prerr_location d2e_cond<span class="keyword">.</span>d2exp_loc<span class="keyword">;</span>
          prerr ") should return a boolean value but it did not."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">// end of [D2Eif]
</span>  <span class="keyword">|</span> D2Eint <span class="keyword">(</span>str<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=&gt;</span> V2ALint int
  <span class="keyword">|</span> D2Emac d2m <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2as <span class="keyword">=</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// no arguments for [d2m]
</span>    <span class="keyword">in</span>
      eval0_exp_app_mac_long <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Emac]
</span>  <span class="keyword">|</span> D2Emacsyn <span class="keyword">(</span>knd<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> knd <span class="keyword">of</span>
    <span class="keyword">|</span> $Syn<span class="keyword">.</span>MACSYNKINDcross <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
        <span class="keyword">val</span> v2al_res <span class="keyword">=</span> eval0_exp_app_eval <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
      <span class="keyword">in</span>
        V2ALcode <span class="keyword">(</span>lift_val_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al_res<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [MACSYNKINDcross]
</span>    <span class="keyword">|</span> $Syn<span class="keyword">.</span>MACSYNKINDdecode <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        eval0_exp_app_eval <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [MACSYNKINDdecode]
</span>    <span class="keyword">|</span> $Syn<span class="keyword">.</span>MACSYNKINDencode <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        V2ALcode <span class="keyword">(</span>d2e<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [MACSYNKINDencode]
</span>    <span class="keyword">end</span> <span class="comment">// end of [D2Emacsyn]
</span><span class="comment">(*
  | D2Eseq '[d2e] =&gt; eval0_exp (loc0, ctx, env, d2e)
*)</span>
  <span class="keyword">|</span> D2Estring <span class="keyword">(</span>str<span class="keyword">,</span> len<span class="keyword">)</span> <span class="keyword">=&gt;</span> V2ALstring <span class="keyword">(</span>str<span class="keyword">,</span> len<span class="keyword">)</span>
  <span class="keyword">|</span> D2Erec <span class="keyword">(</span>_<span class="comment">(*recknd*)</span><span class="keyword">,</span> _<span class="comment">(*npf*)</span><span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> v2ls <span class="keyword">=</span> eval0_labexplst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      V2ALlst <span class="keyword">(</span>v2ls<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Erec]
</span>  <span class="keyword">|</span> D2Evar d2v <span class="keyword">=&gt;</span> eval0_var <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> d2v<span class="keyword">)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
     prerr_loc_errmac loc0<span class="keyword">;</span>
     prerr ": unsupported form for macro expansion: "<span class="keyword">;</span> prerr d2e0<span class="keyword">;</span>
     prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
     $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
   <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [eval0_exp]
</span>
<span class="keyword">implement</span> eval0_labexplst
  <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> ld2es <span class="keyword">of</span>
  <span class="keyword">|</span> LABD2EXPLSTcons <span class="keyword">(</span>_<span class="comment">(*lab*)</span><span class="keyword">,</span> d2e<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> v2l <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">val</span> v2ls <span class="keyword">=</span> eval0_labexplst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      list_cons <span class="keyword">(</span>v2l<span class="keyword">,</span> v2ls<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [LABD2EXPLSTcons]
</span>  <span class="keyword">|</span> LABD2EXPLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [eval0_labexplst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> d2exparg_dyn_get <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> sym<span class="keyword">:</span> <span class="staexp">sym_t</span>
  <span class="keyword">,</span> d2a<span class="keyword">:</span> <span class="staexp">d2exparg</span>
  <span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2explst n</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2a <span class="keyword">of</span>
  <span class="keyword">|</span> D2EXPARGdyn <span class="keyword">(</span>_<span class="comment">(*loc*)</span><span class="keyword">,</span> _<span class="comment">(*npf*)</span><span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">stavar</span> <span class="staexp">nd2es<span class="keyword">:</span> int</span>
      <span class="keyword">val</span> nd2es<span class="keyword">:</span> <span class="staexp">int<span class="keyword">(</span>nd2es<span class="keyword">)</span></span> <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length d2es
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span> <span class="comment">// arity checking
</span>        <span class="keyword">if</span> nd2es &lt;&gt; n <span class="keyword">then</span> <span class="keyword">begin</span>
          prerr_loc_errmac loc0<span class="keyword">;</span>
          prerr ": the dynamic symbol ["<span class="keyword">;</span>
          $Sym<span class="keyword">.</span>prerr_symbol sym<span class="keyword">;</span>
          <span class="keyword">if</span> nd2es <span class="keyword">&gt;</span> 2 <span class="keyword">then</span> prerr "] expects two arguments but is given more."<span class="keyword">;</span>
          <span class="keyword">if</span> nd2es <span class="keyword">&lt;</span> 2 <span class="keyword">then</span> prerr "] expects two arguments but is given less."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          assert <span class="keyword">(</span>nd2es <span class="keyword">=</span> n<span class="keyword">)</span> <span class="comment">// deadcode
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// [nd2es = n] holds!
</span>        <span class="keyword">end</span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>nd2es==n<span class="keyword">]</span> void</span> <span class="comment">// end of [if]
</span>    <span class="keyword">in</span>
      d2es
    <span class="keyword">end</span> <span class="comment">// end of [D2EXPARGdyn]
</span>  <span class="keyword">|</span> D2EXPARGsta _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": the dynamic symbol ["<span class="keyword">;</span>
      $Sym<span class="keyword">.</span>prerr_symbol sym<span class="keyword">;</span>
      prerr "] is applied to static argument(s): {"<span class="keyword">;</span>
      prerr_d2exparg d2a<span class="keyword">;</span> prerr "}"<span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2explst n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2EXPARGsta]
</span><span class="keyword">end</span> <span class="comment">// end of [d2exparg_dyn_get]
</span>
<span class="keyword">fn</span> symbol_is_unary <span class="keyword">(</span>sym<span class="keyword">:</span> <span class="staexp">sym_t</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> sym <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_EVALMAC <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LIFTMAC <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TILDA <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_IS_NIL <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_IS_CONS <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TUP_HEAD <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TUP_TAIL <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> false
<span class="keyword">end</span> <span class="comment">// end of [symbol_is_unary]
</span>
<span class="keyword">fn</span> symbol_is_binary <span class="keyword">(</span>sym<span class="keyword">:</span> <span class="staexp">sym_t</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> sym <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_GT <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_GTEQ <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LT <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LTEQ <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_EQ <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_NEQ <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_ADD <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_SUB <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_MUL <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_DIV <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> false
<span class="keyword">end</span> <span class="comment">// end of [symbol_is_binary]
</span>
<span class="keyword">implement</span>
eval0_exp_app_sym <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_sym: sym = "; $Sym.print_symbol sym; print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">fn</span> err <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> sym<span class="keyword">:</span> <span class="staexp">sym_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    prerr_loc_errmac loc0<span class="keyword">;</span>
    prerr ": an unrecognized symbol ["<span class="keyword">;</span>
    $Sym<span class="keyword">.</span>prerr_symbol sym<span class="keyword">;</span>
    prerr "] is encountered during macro expansion."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [err] *)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> sym <span class="keyword">of</span>
  <span class="keyword">|</span> _ <span class="keyword">when</span> symbol_is_binary sym <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">var</span> d2e10<span class="keyword">:</span> <span class="staexp">d2exp?</span> <span class="keyword">and</span> d2e20<span class="keyword">:</span> <span class="staexp">d2exp?</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span>
        <span class="keyword">:</span><span class="keyword">(</span>d2e10<span class="keyword">:</span> d2exp<span class="keyword">,</span> d2e20<span class="keyword">:</span> d2exp<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2as <span class="keyword">of</span>
        <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2a<span class="keyword">,</span> list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> d2es <span class="keyword">=</span> d2exparg_dyn_get <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">,</span> d2a<span class="keyword">,</span> 2<span class="keyword">)</span>
            <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2e1<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=</span> d2es
            <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2e2<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=</span> d2es
          <span class="keyword">in</span>
            d2e10 := d2e1<span class="keyword">;</span> d2e20 := d2e2
          <span class="keyword">end</span>
        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            prerr_loc_errmac loc0<span class="keyword">;</span>
            prerr ": the dynamic symbol ["<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol sym<span class="keyword">;</span>
            prerr "] should be applied to exactly two arguments but it is not."<span class="keyword">;</span>
            prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            d2e10 := $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            d2e20 := $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> v2al1 <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e10<span class="keyword">)</span>
      <span class="keyword">and</span> v2al2 <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e20<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> sym <span class="keyword">of</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_GT <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_gt <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_GTEQ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_gte <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LT <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_lt <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LTEQ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_lte <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_EQ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_eq <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_NEQ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_neq <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_ADD <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_add <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_SUB <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_sub <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_MUL <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_mul <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al1<span class="keyword">,</span> v2al2<span class="keyword">)</span>
        <span class="keyword">end</span>
<span class="comment">(*
      | _ when sym = $Sym.symbol_DIV =&gt; begin
          eval0_exp_app_div (loc0, v2al1, v2al2)
        end
*)</span>
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// [symbol_is_binary]
</span>  <span class="keyword">|</span> _ <span class="keyword">when</span> symbol_is_unary sym <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">var</span> d2e0<span class="keyword">:</span> <span class="staexp">d2exp?</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> <span class="keyword">:</span><span class="keyword">(</span>d2e0<span class="keyword">:</span> d2exp<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2as <span class="keyword">of</span>
        <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2a<span class="keyword">,</span> list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> d2es <span class="keyword">=</span> d2exparg_dyn_get <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">,</span> d2a<span class="keyword">,</span> 1<span class="keyword">)</span>
            <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2e<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=</span> d2es
          <span class="keyword">in</span>
            d2e0 := d2e
          <span class="keyword">end</span> <span class="comment">(* end of [list_cons] *)</span>
        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            prerr_loc_errmac loc0<span class="keyword">;</span>
            prerr ": the dynamic symbol ["<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol sym<span class="keyword">;</span>
            prerr "] should be applied to exactly one argument but it is not."<span class="keyword">;</span>
            prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            d2e0 := $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">(* end of [_] *)</span>
      <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e0<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> sym <span class="keyword">of</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_EVALMAC <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_eval <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_LIFTMAC <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_lift <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TILDA <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_neg <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_IS_NIL <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_is_nil <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_IS_CONS <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_is_cons <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TUP_HEAD <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_tup_head <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sym <span class="keyword">=</span> $Sym<span class="keyword">.</span>symbol_TUP_TAIL <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          eval0_exp_app_tup_tail <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> err <span class="keyword">(</span>loc0<span class="keyword">,</span> sym<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end [eval0_exp_app_sym]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> eval1_d2var
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">d2var_t</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> alphaenv_find <span class="keyword">(</span>env<span class="keyword">,</span> d2v<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>Some_vt d2v_new <span class="keyword">=&gt;</span> d2v_new <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2v
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2var]
</span>
<span class="keyword">fn</span> eval1_d2expopt
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> od2e<span class="keyword">:</span> <span class="staexp">d2expopt</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">d2expopt</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> od2e <span class="keyword">of</span>
  <span class="keyword">|</span> Some d2e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2expopt]
</span>
<span class="keyword">fn</span> eval1_d2exparg
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2a<span class="keyword">:</span> <span class="staexp">d2exparg</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">d2exparg</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2a <span class="keyword">of</span>
  <span class="keyword">|</span> D2EXPARGdyn <span class="keyword">(</span>_<span class="comment">(*loc_arg*)</span><span class="keyword">,</span> npf<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      D2EXPARGdyn <span class="keyword">(</span>loc0<span class="keyword">,</span> npf<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> D2EXPARGsta _ <span class="keyword">=&gt;</span> d2a
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2exparg]
</span>
<span class="keyword">fun</span> eval1_d2exparglst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp">d2exparglst</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">d2exparglst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2as <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2a<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2a <span class="keyword">=</span> eval1_d2exparg <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2a<span class="keyword">)</span>
    <span class="keyword">in</span>
      list_cons <span class="keyword">(</span>d2a<span class="keyword">,</span> eval1_d2exparglst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2exparglst]
</span>
<span class="keyword">fn</span> eval1_i2nvresstate
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">i2nvresstate</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">i2nvresstate</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> svs <span class="keyword">=</span> res<span class="keyword">.</span>i2nvresstate_svs
  <span class="keyword">val</span> gua <span class="keyword">=</span> res<span class="keyword">.</span>i2nvresstate_gua
  <span class="keyword">val</span> args <span class="keyword">=</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> res<span class="keyword">.</span>i2nvresstate_arg<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> args<span class="keyword">:</span> <span class="staexp">i2nvarglst</span><span class="keyword">)</span>
      <span class="keyword">:</span> <span class="staexp">i2nvarglst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
      <span class="keyword">|</span> list_cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> d2v <span class="keyword">=</span> eval1_d2var <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> arg<span class="keyword">.</span>i2nvarg_var<span class="keyword">)</span>
          <span class="keyword">val</span> arg <span class="keyword">=</span> i2nvarg_make <span class="keyword">(</span>d2v<span class="keyword">,</span> arg<span class="keyword">.</span>i2nvarg_typ<span class="keyword">)</span>
        <span class="keyword">in</span>
          list_cons <span class="keyword">(</span>arg<span class="keyword">,</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> args<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">}</span> <span class="comment">// end of [where]
</span><span class="keyword">in</span>
  i2nvresstate_make <span class="keyword">(</span>svs<span class="keyword">,</span> gua<span class="keyword">,</span> args<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_i2nvresstate]
</span>
<span class="comment">//
</span>
<span class="keyword">fn</span> eval1_m2atch
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> m2at<span class="keyword">:</span> <span class="staexp">m2atch</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">m2atch</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> m2at<span class="keyword">.</span>m2atch_exp<span class="keyword">)</span>
  <span class="keyword">val</span> op2t <span class="keyword">=</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> m2at<span class="keyword">.</span>m2atch_pat <span class="keyword">of</span>
    <span class="keyword">|</span> Some p2t <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2t<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">p2atopt</span>
<span class="keyword">in</span>
  m2atch_make <span class="keyword">(</span>m2at<span class="keyword">.</span>m2atch_loc<span class="keyword">,</span> d2e<span class="keyword">,</span> op2t<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_m2atch]
</span>
<span class="keyword">fun</span> eval1_m2atchlst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> m2ats<span class="keyword">:</span> <span class="staexp">m2atchlst</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">m2atchlst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> m2ats <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>m2at<span class="keyword">,</span> m2ats<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> m2at <span class="keyword">=</span> eval1_m2atch <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> m2at<span class="keyword">)</span>
    <span class="keyword">in</span>
      list_cons <span class="keyword">(</span>m2at<span class="keyword">,</span> eval1_m2atchlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> m2ats<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_m2atchlst]
</span>
<span class="keyword">fn</span> eval1_c2lau <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> c2l<span class="keyword">:</span> <span class="staexp">c2lau n</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">c2lau n</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">)</span>
  <span class="keyword">val</span> p2ts <span class="keyword">=</span> eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> c2l<span class="keyword">.</span>c2lau_pat<span class="keyword">)</span>
  <span class="keyword">val</span> gua <span class="keyword">=</span> eval1_m2atchlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2l<span class="keyword">.</span>c2lau_gua<span class="keyword">)</span>
  <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2l<span class="keyword">.</span>c2lau_exp<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">)</span>
<span class="keyword">in</span>
  c2lau_make <span class="keyword">(</span>c2l<span class="keyword">.</span>c2lau_loc<span class="keyword">,</span> p2ts<span class="keyword">,</span> gua<span class="keyword">,</span> c2l<span class="keyword">.</span>c2lau_seq<span class="keyword">,</span> c2l<span class="keyword">.</span>c2lau_neg<span class="keyword">,</span> d2e<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_c2lau]
</span>
<span class="keyword">fn</span> eval1_c2laulst <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> c2ls<span class="keyword">:</span> <span class="staexp">c2laulst n</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">c2laulst n</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> c2ls<span class="keyword">:</span> <span class="staexp">c2laulst n</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>c2laulst? &gt;&gt; c2laulst n</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> c2ls <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>c2l<span class="keyword">,</span> c2ls<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> c2l <span class="keyword">=</span> eval1_c2lau <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2l<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := list_cons <span class="staexp"><span class="keyword">{</span>c2lau n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>c2l<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2ls<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">c2laulst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2ls<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_c2laulst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval1_d2exp: loc0 = ";
    $Loc.print_location loc0; print_newline ()
  end (* end of [val] *)
  val () = begin
    print "eval1_d2exp: d2e0 = "; print_d2exp d2e0; print_newline ()
  end (* end of [val] *)
*)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> d2e0<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> D2Eann_funclo <span class="keyword">(</span>d2e<span class="keyword">,</span> fcr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_ann_funclo <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> fcr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eann_funclo]
</span>  <span class="keyword">|</span> D2Eann_seff <span class="keyword">(</span>d2e<span class="keyword">,</span> s2fe<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_ann_seff <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> s2fe<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eann_seff]
</span>  <span class="keyword">|</span> D2Eann_type <span class="keyword">(</span>d2e<span class="keyword">,</span> s2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_ann_type <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> s2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eann_type]
</span>  <span class="keyword">|</span> D2Eapps <span class="keyword">(</span>d2e<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> d2e<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
      <span class="keyword">|</span> D2Emac d2m <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          <span class="keyword">if</span> d2mac_kind_get d2m <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// [d2m] is short
</span>            <span class="comment">// expanding a macro in short form
</span>            eval0_exp_app_mac_short <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
            prerr_loc_errmac loc0<span class="keyword">;</span>
            prerr ": the dynamic symbol ["<span class="keyword">;</span> prerr d2m<span class="keyword">;</span> prerr "] ("<span class="keyword">;</span>
            $Loc<span class="keyword">.</span>prerr_location d2e0<span class="keyword">.</span>d2exp_loc<span class="keyword">;</span>
            prerr ") refers to a macro definition in long form"<span class="keyword">;</span>
            prerr "; it should be called inside the syntax ,(...)"<span class="keyword">;</span>
            prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="comment">// end of [D2Emac]
</span>      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> d2as <span class="keyword">=</span> eval1_d2exparglst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">case+</span> d2e<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
          <span class="keyword">|</span> D2Eapps <span class="keyword">(</span>d2e1<span class="keyword">,</span> d2as1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
              <span class="keyword">val</span> d2as1 <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_append <span class="keyword">(</span>d2as1<span class="keyword">,</span> d2as<span class="keyword">)</span>
            <span class="keyword">in</span>
              d2exp_apps <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e1<span class="keyword">,</span> d2as1<span class="keyword">)</span>
            <span class="keyword">end</span>
          <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> d2exp_apps <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> d2as<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">// end of [D2Eapps]
</span>  <span class="keyword">|</span> D2Earrinit <span class="keyword">(</span>s2e_elt<span class="keyword">,</span> od2e_asz<span class="keyword">,</span> d2es_elt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> od2e_asz <span class="keyword">=</span> eval1_d2expopt <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> od2e_asz<span class="keyword">)</span>
      <span class="keyword">val</span> d2es_elt <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es_elt<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_arrinit <span class="keyword">(</span>loc0<span class="keyword">,</span> s2e_elt<span class="keyword">,</span> od2e_asz<span class="keyword">,</span> d2es_elt<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Earrinit]
</span>  <span class="keyword">|</span> D2Earrsize <span class="keyword">(</span>os2e<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_arrsize <span class="keyword">(</span>loc0<span class="keyword">,</span> os2e<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Earrsize]
</span>  <span class="keyword">|</span> D2Earrsub <span class="keyword">(</span>d2s<span class="keyword">,</span> d2e_arr<span class="keyword">,</span> _<span class="comment">(*loc*)</span><span class="keyword">,</span> d2ess_ind<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e_arr <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_arr<span class="keyword">)</span>
      <span class="keyword">val</span> d2ess_ind <span class="keyword">=</span> eval1_d2explstlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2ess_ind<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_arrsub <span class="keyword">(</span>loc0<span class="keyword">,</span> d2s<span class="keyword">,</span> d2e_arr<span class="keyword">,</span> loc0<span class="keyword">,</span> d2ess_ind<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Earrsub]
</span>  <span class="keyword">|</span> D2Eassgn <span class="keyword">(</span>d2e1<span class="keyword">,</span> d2e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e1 <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e1<span class="keyword">)</span>
      <span class="keyword">val</span> d2e2 <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e2<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_assgn <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e1<span class="keyword">,</span> d2e2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eassgn]
</span>  <span class="keyword">|</span> D2Ecaseof <span class="keyword">(</span>knd<span class="keyword">,</span> res<span class="keyword">,</span> n<span class="keyword">,</span> d2es<span class="keyword">,</span> c2ls<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> res <span class="keyword">=</span> eval1_i2nvresstate <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> res<span class="keyword">)</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
      <span class="keyword">val</span> c2ls <span class="keyword">=</span> eval1_c2laulst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> c2ls<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_caseof <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> res<span class="keyword">,</span> n<span class="keyword">,</span> d2es<span class="keyword">,</span> c2ls<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Ecaseof]
</span>  <span class="keyword">|</span> D2Econ <span class="keyword">(</span>d2c<span class="keyword">,</span> s2es<span class="keyword">,</span> npf<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_con <span class="keyword">(</span>loc0<span class="keyword">,</span> d2c<span class="keyword">,</span> s2es<span class="keyword">,</span> npf<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Econ]
</span>  <span class="keyword">|</span> D2Ecrypt <span class="keyword">(</span>knd<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_crypt <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Ecrypt]
</span>  <span class="keyword">|</span> D2Ecst d2c <span class="keyword">=&gt;</span> d2exp_cst <span class="keyword">(</span>loc0<span class="keyword">,</span> d2c<span class="keyword">)</span>
  <span class="keyword">|</span> D2Ecstsp <span class="keyword">(</span>csp<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2exp_cstsp <span class="keyword">(</span>loc0<span class="keyword">,</span> csp<span class="keyword">)</span>
  <span class="keyword">|</span> D2Ederef d2e <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_deref <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Ederef]
</span>  <span class="keyword">|</span> D2Eeffmask <span class="keyword">(</span>eff<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_effmask <span class="keyword">(</span>loc0<span class="keyword">,</span> eff<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eeffmask]
</span>  <span class="keyword">|</span> D2Eextval <span class="keyword">(</span>s2e<span class="keyword">,</span> str<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2exp_extval <span class="keyword">(</span>loc0<span class="keyword">,</span> s2e<span class="keyword">,</span> str<span class="keyword">)</span>
  <span class="keyword">|</span> D2Eexist <span class="keyword">(</span>s2as<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_exist <span class="keyword">(</span>loc0<span class="keyword">,</span> s2as<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eexist]
</span>  <span class="keyword">|</span> D2Efix <span class="keyword">(</span>knd<span class="keyword">,</span> d2v<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">)</span>
      <span class="keyword">val</span> d2v_new <span class="keyword">=</span> eval1_d2var <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> d2v<span class="keyword">)</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_fix <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> d2v_new<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Efix]
</span>  <span class="keyword">|</span> D2Efoldat <span class="keyword">(</span>s2as<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_foldat <span class="keyword">(</span>loc0<span class="keyword">,</span> s2as<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Efoldat]
</span>  <span class="keyword">|</span> D2Efreeat <span class="keyword">(</span>s2as<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_freeat <span class="keyword">(</span>loc0<span class="keyword">,</span> s2as<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Efreeat]
</span>  <span class="keyword">|</span> D2Eif <span class="keyword">(</span>res<span class="keyword">,</span> d2e_cond<span class="keyword">,</span> d2e_then<span class="keyword">,</span> od2e_else<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> res <span class="keyword">=</span> eval1_i2nvresstate <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> res<span class="keyword">)</span>
      <span class="keyword">val</span> d2e_cond <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_cond<span class="keyword">)</span>
      <span class="keyword">val</span> d2e_then <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_then<span class="keyword">)</span>
      <span class="keyword">val</span> od2e_else <span class="keyword">=</span> eval1_d2expopt <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> od2e_else<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_if <span class="keyword">(</span>loc0<span class="keyword">,</span> res<span class="keyword">,</span> d2e_cond<span class="keyword">,</span> d2e_then<span class="keyword">,</span> od2e_else<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eif]
</span>  <span class="keyword">|</span> D2Eint _ <span class="keyword">=&gt;</span> d2e0
  <span class="keyword">|</span> D2Elam_dyn <span class="keyword">(</span>
      lin<span class="keyword">,</span> npf<span class="keyword">,</span> p2ts_arg<span class="keyword">,</span> d2e_body
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">)</span>
      <span class="keyword">val</span> p2ts_arg <span class="keyword">=</span> eval1_p2atlst <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> p2ts_arg<span class="keyword">)</span>
      <span class="keyword">val</span> d2e_body <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_body<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_lam_dyn <span class="keyword">(</span>loc0<span class="keyword">,</span> lin<span class="keyword">,</span> npf<span class="keyword">,</span> p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elam_dyn]
</span>  <span class="keyword">|</span> D2Elazy_delay <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_lazy_delay <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elazy_delay]
</span>  <span class="keyword">|</span> D2Elazy_vt_delay <span class="keyword">(</span>d2e1<span class="keyword">,</span> d2e2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e1 <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e1<span class="keyword">)</span>
      <span class="keyword">val</span> d2e2 <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e2<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_lazy_vt_delay <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e1<span class="keyword">,</span> d2e2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elazy_vt_delay]
</span>  <span class="keyword">|</span> D2Elet <span class="keyword">(</span>d2cs<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">)</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> eval1_d2eclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_let <span class="keyword">(</span>loc0<span class="keyword">,</span> d2cs<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elet]
</span>  <span class="keyword">|</span> D2Elst <span class="keyword">(</span>lin<span class="keyword">,</span> os2e<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_lst <span class="keyword">(</span>loc0<span class="keyword">,</span> lin<span class="keyword">,</span> os2e<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elst]
</span>  <span class="keyword">|</span> D2Emacsyn <span class="keyword">(</span>knd<span class="keyword">,</span> d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> v2al <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> knd <span class="keyword">of</span>
        <span class="keyword">|</span> $Syn<span class="keyword">.</span>MACSYNKINDcross <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
          <span class="keyword">in</span>
            V2ALcode <span class="keyword">(</span>lift_val_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [MACSYNKINDcross]
</span>        <span class="keyword">|</span> $Syn<span class="keyword">.</span>MACSYNKINDdecode <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            prerr_loc_errmac loc0<span class="keyword">;</span>
            prerr ": invalid use of macro syntax: "<span class="keyword">;</span>
            prerr d2e0<span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>v2alue<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> v2al <span class="keyword">of</span>
      <span class="keyword">|</span> V2ALcode d2e_new <span class="keyword">=&gt;</span> d2e_new <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_errmac loc0<span class="keyword">;</span>
          prerr ": the expansion of this dynamic expression ("<span class="keyword">;</span>
          $Loc<span class="keyword">.</span>prerr_location d2e<span class="keyword">.</span>d2exp_loc<span class="keyword">;</span>
          prerr ") should return a value representing code (abstract syntax tree)"<span class="keyword">;</span>
          prerr ", but it did not do so."<span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
<span class="comment">(*
          prerr "d2e = "; prerr_d2exp d2e; prerr_newline ();
          prerr "v2al = "; prerr_v2alue v2al; prerr_newline ();
*)</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">// end of [D2Emacsyn]
</span>  <span class="keyword">|</span> D2Eptrof <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_ptrof <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eptrof]
</span>  <span class="keyword">|</span> D2Eraise <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_raise <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eraise]
</span>  <span class="keyword">|</span> D2Erec <span class="keyword">(</span>recknd<span class="keyword">,</span> npf<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> ld2es <span class="keyword">=</span> eval1_labd2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_rec <span class="keyword">(</span>loc0<span class="keyword">,</span> recknd<span class="keyword">,</span> npf<span class="keyword">,</span> ld2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Erec]
</span>  <span class="keyword">|</span> D2Eseq d2es <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_seq <span class="keyword">(</span>loc0<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eseq]
</span>  <span class="keyword">|</span> D2Esif <span class="keyword">(</span>res<span class="keyword">,</span> s2e_cond<span class="keyword">,</span> d2e_then<span class="keyword">,</span> d2e_else<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> res <span class="keyword">=</span> eval1_i2nvresstate <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> res<span class="keyword">)</span>
      <span class="keyword">val</span> d2e_then <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_then<span class="keyword">)</span>
      <span class="keyword">val</span> d2e_else <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e_else<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_sif <span class="keyword">(</span>loc0<span class="keyword">,</span> res<span class="keyword">,</span> s2e_cond<span class="keyword">,</span> d2e_then<span class="keyword">,</span> d2e_else<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Esif]
</span>  <span class="keyword">|</span> D2Estring _ <span class="keyword">=&gt;</span> d2e0
  <span class="keyword">|</span> D2Estruct ld2es <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> ld2es <span class="keyword">=</span>
        eval1_labd2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span>
      <span class="comment">// end of [val]
</span>    <span class="keyword">in</span>
      d2exp_struct <span class="keyword">(</span>loc0<span class="keyword">,</span> ld2es<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Estruct]
</span>  <span class="keyword">|</span> D2Esym d2s <span class="keyword">=&gt;</span> d2e0 <span class="comment">// this is static binding
</span><span class="comment">(*
//
// HX-2010-03-09: should dynamic binding be supported?
//
  | D2Esym d2s =&gt; let
      val q = d2s.d2sym_qua and id = d2s.d2sym_sym
      val ans = $TRAN2ENV.the_d2expenv_find_qua (q, id)
    in
      case ans of
      | ~Some_vt d2i =&gt; (case+ d2i of
        | D2ITEMsymdef d2is =&gt; let // reload symdef list
            val () = begin
              print "eval1_d2exp: D2Esym: d2is = "; print_d2itemlst d2is; print_newline ()
            end // end of [val]
            val d2s_new = d2sym_make (loc0, q, id, d2is) in
            d2exp_sym (loc0, d2s_new)
          end // end of [D2ITEMsymdef]
        | _ =&gt; d2e0 // end of [_]
        ) // end of [Some_vt]
      | ~None_vt () =&gt; d2e0
    end // end of [D2Esym]
*)</span>
  <span class="keyword">|</span> D2Etmpid <span class="keyword">(</span>d2e<span class="keyword">,</span> ts2ess<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_tmpid <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> ts2ess<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Etmpid]
</span>  <span class="keyword">|</span> D2Evar <span class="keyword">(</span>d2v<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2v_new <span class="keyword">=</span> eval1_d2var <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> d2v<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_var <span class="keyword">(</span>loc0<span class="keyword">,</span> d2v_new<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Evar]
</span>  <span class="keyword">|</span> D2Eviewat <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_viewat <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Eviewat]
</span>  <span class="keyword">|</span> D2Ewhere <span class="keyword">(</span>d2e<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_push <span class="keyword">(</span>env<span class="keyword">)</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> eval1_d2eclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span>
      <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_pop <span class="keyword">(</span>env<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2exp_where <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Elet]
</span><span class="comment">(*
  | _ =&gt; begin
      prerr_loc_errmac loc0;
      prerr ": unsupported form for macro expansion: ";
      prerr d2e0; prerr_newline ();
      $Err.abort {d2exp} ()
    end // end of [_]
*)</span>
<span class="comment">// (*
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">(*
      val () = begin
        print "eval1_d2exp(aft): d2e0 = "; print_d2exp d2e0; print_newline ()
      end // end of [val]
*)</span>
    <span class="keyword">in</span>
      d2e0 <span class="comment">// location is not changed; it should be changed recursively!
</span>    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="comment">// *)
</span><span class="keyword">end</span> <span class="comment">// end of [eval1_d2exp]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> d2es<span class="keyword">:</span> <span class="staexp">d2explst n</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>d2explst? &gt;&gt; d2explst n</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> d2es <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2e<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := list_cons <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>d2e<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">d2explst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2explst]
</span>
<span class="keyword">implement</span>
eval1_d2explstlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2ess<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> d2ess <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2es<span class="keyword">,</span> d2ess<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2es <span class="keyword">=</span> eval1_d2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2es<span class="keyword">)</span>
    <span class="keyword">in</span>
      list_cons <span class="keyword">(</span>d2es<span class="keyword">,</span> eval1_d2explstlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2ess<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2explstlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
eval1_labd2explst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> ld2es<span class="keyword">:</span> <span class="staexp">labd2explst</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>labd2explst? &gt;&gt; labd2explst</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> ld2es <span class="keyword">of</span>
    <span class="keyword">|</span> LABD2EXPLSTcons <span class="keyword">(</span>l<span class="keyword">,</span> d2e<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := LABD2EXPLSTcons <span class="keyword">(</span>l<span class="keyword">,</span> d2e<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> LABD2EXPLSTcons <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> LABD2EXPLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := LABD2EXPLSTnil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">labd2explst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_labd2explst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> eval1_v2aldeclst
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2cs<span class="keyword">:</span> <span class="staexp">v2aldeclst</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">v2aldeclst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> p2ts <span class="keyword">=</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
        loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span> d2cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v2aldec<span class="keyword">,</span> n<span class="keyword">)</span></span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
      <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> p2t <span class="keyword">=</span> eval1_p2at <span class="keyword">(</span>loc0<span class="keyword">,</span> env<span class="keyword">,</span> d2c<span class="keyword">.</span>v2aldec_pat<span class="keyword">)</span>
        <span class="keyword">in</span>
          list_vt_cons <span class="keyword">(</span>p2t<span class="keyword">,</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">}</span> <span class="comment">// end of [where]
</span>  <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
        loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span><span class="keyword">,</span>
        p2ts<span class="keyword">:</span> <span class="staexp">list_vt <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> d2cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v2aldec<span class="keyword">,</span> n<span class="keyword">)</span></span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v2aldec<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> p2ts <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons <span class="keyword">(</span>p2t<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=</span> d2cs
          <span class="keyword">val</span> def <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2c<span class="keyword">.</span>v2aldec_def<span class="keyword">)</span>
          <span class="keyword">val</span> d2c <span class="keyword">=</span> v2aldec_make <span class="keyword">(</span>loc0<span class="keyword">,</span> p2t<span class="keyword">,</span> def<span class="keyword">,</span> d2c<span class="keyword">.</span>v2aldec_ann<span class="keyword">)</span>
        <span class="keyword">in</span>
          list_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> p2ts<span class="keyword">,</span> d2cs<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">}</span> <span class="comment">// end of [where]
</span><span class="keyword">in</span>
  d2cs
<span class="keyword">end</span> <span class="comment">// end of [eval1_v2aldeclst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
eval1_d2ec <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2c0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> d2c0<span class="keyword">.</span>d2ec_node <span class="keyword">of</span>
  <span class="keyword">|</span> D2Cnone <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2ec_none <span class="keyword">(</span>loc0<span class="keyword">)</span>
  <span class="keyword">|</span> D2Clist d2cs <span class="keyword">=&gt;</span> d2ec_list <span class="keyword">(</span>loc0<span class="keyword">,</span> eval1_d2eclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> D2Cvaldecs <span class="keyword">(</span>knd<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> eval1_v2aldeclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_valdecs <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Cvaldecs]
</span>  <span class="keyword">|</span> D2Cvaldecs_rec <span class="keyword">(</span>d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> eval1_v2aldeclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_valdecs_rec <span class="keyword">(</span>loc0<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D2Cvaldecs_rec]
</span>  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": this form of declaration ("<span class="keyword">;</span>
      $Loc<span class="keyword">.</span>prerr_location d2c0<span class="keyword">.</span>d2ec_loc<span class="keyword">;</span>
      prerr ") is not supported in macro expansion."<span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2ec<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [eval1_d2ec]
</span>
<span class="keyword">implement</span>
eval1_d2eclst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
    <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> d2cs<span class="keyword">:</span> <span class="staexp">d2eclst</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>d2eclst? &gt;&gt; d2eclst</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2c <span class="keyword">=</span> eval1_d2ec <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2c<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := list_cons <span class="staexp"><span class="keyword">{</span>d2ec<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>d2c<span class="keyword">,</span> ?<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>_<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ res
      <span class="keyword">end</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">d2eclst?</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2cs<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval1_d2eclst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> eval0ctx_extend_arg <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> knd<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">(*1/0: long/short*)</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> d2vs<span class="keyword">:</span> <span class="staexp">d2varlst n</span><span class="keyword">,</span> d2es<span class="keyword">:</span> <span class="staexp">d2explst n</span>
  <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">eval0ctx</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">eval0ctx</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn</span> aux <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
    <span class="keyword">,</span> d2e<span class="keyword">:</span> <span class="staexp">d2exp</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
  <span class="keyword">in</span>
    V2ALcode <span class="keyword">(</span>d2e<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">fun</span> auxlst <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> ld2es<span class="keyword">:</span> <span class="staexp">labd2explst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2aluelst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ld2es <span class="keyword">of</span>
    <span class="keyword">|</span> LABD2EXPLSTcons <span class="keyword">(</span>_<span class="comment">(*lab*)</span><span class="keyword">,</span> d2e<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> v2al <span class="keyword">=</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        list_cons <span class="keyword">(</span>v2al<span class="keyword">,</span> auxlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">|</span> LABD2EXPLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [auxlst]
</span><span class="keyword">in</span>
  <span class="keyword">case+</span> d2vs <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2v<span class="keyword">,</span> d2vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2e<span class="keyword">,</span> d2es<span class="keyword">)</span> <span class="keyword">=</span> d2es
      <span class="keyword">val</span> v2al<span class="keyword">:</span> <span class="staexp">v2alue</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> knd <span class="keyword">of</span>
        <span class="keyword">|</span> 0 <span class="comment">(*short*)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2e<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
          <span class="keyword">|</span> D2Erec <span class="keyword">(</span>_<span class="comment">(*recknd*)</span><span class="keyword">,</span> _<span class="comment">(*npf*)</span><span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
              <span class="keyword">val</span> v2als <span class="keyword">=</span> auxlst <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> ld2es<span class="keyword">)</span> <span class="keyword">in</span> V2ALlst v2als
            <span class="keyword">end</span> <span class="comment">// end of [D2Erec]
</span>          <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> aux <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [0(*short*)]
</span>        <span class="keyword">|</span> _ <span class="comment">(*long*)</span> <span class="keyword">=&gt;</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> res <span class="keyword">=</span> eval0ctx_add <span class="keyword">(</span>res<span class="keyword">,</span> d2v<span class="keyword">,</span> v2al<span class="keyword">)</span>
    <span class="keyword">in</span>
      eval0ctx_extend_arg <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2vs<span class="keyword">,</span> d2es<span class="keyword">,</span> res<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval0ctx_extend_arg]
</span>
<span class="comment">// ------------------------------------
</span>
<span class="keyword">fun</span> eval0ctx_extend_arglst <span class="staexp"><span class="keyword">{</span>narg<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> d2m<span class="keyword">:</span> <span class="staexp">d2mac_t</span>
  <span class="keyword">,</span> knd<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">(* 1/0: long/short *)</span>
  <span class="keyword">,</span> ctx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>eval0ctx</span>
  <span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>alphaenv</span>
  <span class="keyword">,</span> args<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>macarg<span class="keyword">,</span> narg<span class="keyword">)</span></span>
  <span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2exparg<span class="keyword">,</span> narg<span class="keyword">)</span></span>
  <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">eval0ctx</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">eval0ctx</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2a<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=</span> d2as
      <span class="keyword">var</span> d2es<span class="keyword">:</span> <span class="staexp">d2explst</span> <span class="keyword">=</span> list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> d2a <span class="keyword">of</span>
        <span class="keyword">|</span> D2EXPARGdyn <span class="keyword">(</span>_<span class="comment">(*loc*)</span><span class="keyword">,</span> _<span class="comment">(*npf*)</span><span class="keyword">,</span> d2es1<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2es := d2es1
        <span class="keyword">|</span> D2EXPARGsta _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            prerr_loc_errmac loc0<span class="keyword">;</span>
            prerr ": the macro function ["<span class="keyword">;</span> prerr d2m<span class="keyword">;</span>
            prerr "] should not be applied to static arguments."<span class="keyword">;</span>
            prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
            $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [D2EXPARGsta]
</span>      <span class="keyword">val</span> d2es <span class="keyword">=</span> <span class="keyword">(</span>d2es<span class="keyword">:</span> <span class="staexp">d2explst</span><span class="keyword">)</span> <span class="comment">// handle a complaint by [ATS/Geizella]
</span>      <span class="keyword">val</span> nd2vs <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> arg <span class="keyword">of</span>
        <span class="keyword">|</span> MACARGone d2v <span class="keyword">=&gt;</span> <span class="keyword">@(</span>1<span class="keyword">,</span> <span class="keyword">'[</span>d2v<span class="keyword">]</span><span class="keyword">)</span> <span class="keyword">|</span> MACARGlst <span class="keyword">(</span>n<span class="keyword">,</span> d2vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">@(</span>n<span class="keyword">,</span> d2vs<span class="keyword">)</span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>nat<span class="keyword">]</span> <span class="keyword">(</span>int n<span class="keyword">,</span> d2varlst n<span class="keyword">)</span></span>
      <span class="keyword">val</span> n <span class="keyword">=</span> nd2vs<span class="keyword">.</span>0 <span class="keyword">and</span> d2vs <span class="keyword">=</span> nd2vs<span class="keyword">.</span>1
      <span class="keyword">val</span> nd2es <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length <span class="keyword">(</span>d2es<span class="keyword">)</span>
      <span class="keyword">stavar</span> <span class="staexp">n<span class="keyword">:</span> int <span class="keyword">and</span> nd2es<span class="keyword">:</span> int</span>
      <span class="keyword">val</span> n<span class="keyword">:</span> <span class="staexp">int n</span> <span class="keyword">=</span> n <span class="keyword">and</span> nd2es<span class="keyword">:</span> <span class="staexp">int nd2es</span> <span class="keyword">=</span> nd2es
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span> <span class="comment">// arity checking
</span>        <span class="keyword">if</span> <span class="keyword">(</span>n &lt;&gt; nd2es<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
          prerr_loc_errmac loc0<span class="keyword">;</span>
          prerr ": expansion of the macro ["<span class="keyword">;</span> prerr d2m<span class="keyword">;</span>
          prerr "] encounters an arity error."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          assert <span class="keyword">(</span>n <span class="keyword">=</span> nd2es<span class="keyword">)</span> <span class="comment">// deadcode
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// [n = nd2es] holds!
</span>        <span class="keyword">end</span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n == nd2es<span class="keyword">]</span> void</span> <span class="comment">// end of [if]
</span>      <span class="keyword">val</span> res <span class="keyword">=</span> eval0ctx_extend_arg <span class="keyword">(</span>loc0<span class="keyword">,</span> knd<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2vs<span class="keyword">,</span> d2es<span class="keyword">,</span> res<span class="keyword">)</span>
    <span class="keyword">in</span>
      eval0ctx_extend_arglst <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> knd<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> args<span class="keyword">,</span> d2as<span class="keyword">,</span> res<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
<span class="keyword">end</span> <span class="comment">// end of [eval0ctx_extend_arglst]
</span>
<span class="keyword">implement</span> <span class="comment">// expanding macros in long form
</span>eval0_exp_app_mac_long <span class="staexp"><span class="keyword">{</span>narg<span class="keyword">}</span></span> <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_long: d2m = "; print d2m; print_newline ()
  end
*)</span>
  <span class="keyword">val</span> narg <span class="keyword">=</span> d2mac_narg_get <span class="keyword">(</span>d2m<span class="keyword">)</span><span class="keyword">;</span> <span class="keyword">val</span> args <span class="keyword">=</span> d2mac_arglst_get <span class="keyword">(</span>d2m<span class="keyword">)</span>
  <span class="keyword">stavar</span> <span class="staexp">nd2as<span class="keyword">:</span> int</span><span class="keyword">;</span> <span class="keyword">val</span> nd2as<span class="keyword">:</span> <span class="staexp">int nd2as</span> <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length d2as
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_long: narg = "; print narg; print_newline ();
    print "eval0_exp_app_mac_long: nd2as = "; print nd2as; print_newline ();
  end // end of [val]
*)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span> <span class="comment">// checking for improper application
</span>    <span class="keyword">if</span> narg &lt;&gt; nd2as <span class="keyword">then</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": the macro function ["<span class="keyword">;</span> prerr d2m<span class="keyword">;</span>
      <span class="keyword">if</span> narg <span class="keyword">&gt;</span> nd2as <span class="keyword">then</span> prerr "] is applied insufficiently."<span class="keyword">;</span>
      <span class="keyword">if</span> nd2as <span class="keyword">&lt;</span> narg <span class="keyword">then</span> prerr "] is overly applied."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      assert <span class="keyword">(</span>narg <span class="keyword">=</span> nd2as<span class="keyword">)</span> <span class="comment">// deadcode
</span>    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// [narg = nd2as] holds!
</span>    <span class="keyword">end</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>narg==nd2as<span class="keyword">]</span> void</span> <span class="comment">// end of [if]
</span>  <span class="keyword">val</span> ctx_new <span class="keyword">=</span> eval0ctx_extend_arglst <span class="keyword">(</span>
    loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> 1<span class="comment">(*long*)</span><span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> args<span class="keyword">,</span> d2as<span class="keyword">,</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">// end of [eval0ctx_extend_arglst]
</span><span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_long: ctx_new = "; print_newline (); print ctx_new
  end // end of [val]
*)</span>
  <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx_new<span class="keyword">,</span> env<span class="keyword">,</span> d2mac_def_get d2m<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free ctx_new
<span class="keyword">in</span>
  v2al
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_mac_long]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> <span class="comment">// expanding macros in short form
</span>eval0_exp_app_mac_short <span class="staexp"><span class="keyword">{</span>narg<span class="keyword">}</span></span> <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_short: d2m = "; print d2m; print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">val</span> narg <span class="keyword">=</span> d2mac_narg_get <span class="keyword">(</span>d2m<span class="keyword">)</span>
  <span class="keyword">val</span> args <span class="keyword">=</span> d2mac_arglst_get <span class="keyword">(</span>d2m<span class="keyword">)</span>
  <span class="keyword">stavar</span> <span class="staexp">nd2as<span class="keyword">:</span> int</span><span class="keyword">;</span> <span class="keyword">val</span> nd2as<span class="keyword">:</span> <span class="staexp">int <span class="keyword">(</span>nd2as<span class="keyword">)</span></span> <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length d2as
<span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_short: narg = "; print narg; print_newline ();
    print "eval0_exp_app_mac_short: nd2as = "; print nd2as; print_newline ();
  end // end of [val]
*)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
    <span class="keyword">if</span> narg <span class="keyword">&gt;</span> nd2as <span class="keyword">then</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": the macro function ["<span class="keyword">;</span> prerr d2m<span class="keyword">;</span>
      prerr "] is applied insufficiently."<span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      assert <span class="keyword">(</span>narg &lt;= nd2as<span class="keyword">)</span> <span class="comment">// deadcode
</span>    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// [narg &lt;= nd2as] holds!
</span>    <span class="keyword">end</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>narg &lt;= nd2as<span class="keyword">]</span> void</span> <span class="comment">// end of [if]
</span>  <span class="keyword">var</span> d2as2<span class="keyword">:</span> <span class="staexp">d2exparglst</span> <span class="keyword">=</span> d2as
  <span class="keyword">val</span> d2as1 <span class="keyword">=</span> aux <span class="keyword">(</span>narg<span class="keyword">,</span> d2as2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i1<span class="keyword">,</span> i2<span class="keyword">:</span>nat <span class="keyword">|</span> i1 &lt;= i2<span class="keyword">}</span></span> 
      <span class="keyword">(</span>i1<span class="keyword">:</span> <span class="staexp">int i1</span><span class="keyword">,</span> d2as<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>list <span class="keyword">(</span>d2exparg<span class="keyword">,</span> i2<span class="keyword">)</span> &gt;&gt; list <span class="keyword">(</span>d2exparg<span class="keyword">,</span> i2-i1<span class="keyword">)</span></span><span class="keyword">)</span>
      <span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2exparg<span class="keyword">,</span> i1<span class="keyword">)</span></span> <span class="keyword">=</span>
      <span class="keyword">if</span> i1 <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>d2a1<span class="keyword">,</span> d2as1<span class="keyword">)</span> <span class="keyword">=</span> d2as<span class="keyword">;</span> <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2as := d2as1
      <span class="keyword">in</span>
        list_cons <span class="keyword">(</span>d2a1<span class="keyword">,</span> aux <span class="keyword">(</span>i1-1<span class="keyword">,</span> d2as<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        list_nil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> ctx_new <span class="keyword">=</span> eval0ctx_extend_arglst <span class="keyword">(</span>
    loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> 0<span class="comment">(*short*)</span><span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> args<span class="keyword">,</span> d2as1<span class="keyword">,</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">// end of [eval0ctx_extend_arglst]
</span><span class="comment">(*
  val () = begin
    print "eval0_exp_app_mac_short: ctx_new =\n"; print ctx_new
  end // end of [val]
*)</span>
  <span class="keyword">val</span> d2e <span class="keyword">=</span> eval1_d2exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx_new<span class="keyword">,</span> env<span class="keyword">,</span> d2mac_def_get d2m<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free ctx_new
<span class="keyword">in</span>
  <span class="keyword">case+</span> d2as2 <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2e<span class="keyword">.</span>d2exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D2Eapps <span class="keyword">(</span>d2e_fun<span class="keyword">,</span> d2as1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2as_arg <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_append <span class="keyword">(</span>d2as1<span class="keyword">,</span> d2as2<span class="keyword">)</span>
      <span class="keyword">in</span>
        d2exp_apps <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e_fun<span class="keyword">,</span> d2as_arg<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D2Eapps]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span>  d2exp_apps <span class="keyword">(</span>loc0<span class="keyword">,</span> d2e<span class="keyword">,</span> d2as2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2e
<span class="keyword">end</span> <span class="comment">// end of [eval0_exp_app_mac_short]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
macro_eval_cross <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc0 <span class="keyword">=</span> d2e<span class="keyword">.</span>d2exp_loc
  <span class="keyword">var</span> ctx <span class="keyword">=</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> env <span class="keyword">=</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_free <span class="keyword">(</span>env<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free <span class="keyword">(</span>ctx<span class="keyword">)</span>
<span class="keyword">in</span>
  lift_val_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> v2al<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [macro_eval_cross]
</span>
<span class="keyword">implement</span>
macro_eval_decode <span class="keyword">(</span>d2e<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc0 <span class="keyword">=</span> d2e<span class="keyword">.</span>d2exp_loc
  <span class="keyword">var</span> ctx <span class="keyword">=</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> env <span class="keyword">=</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> v2al <span class="keyword">=</span> eval0_exp <span class="keyword">(</span>loc0<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2e<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_free <span class="keyword">(</span>env<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free <span class="keyword">(</span>ctx<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> v2al <span class="keyword">of</span>
  <span class="keyword">|</span> V2ALcode d2e_new <span class="keyword">=&gt;</span> d2e_new
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prerr_loc_errmac loc0<span class="keyword">;</span>
      prerr ": the expansion of this macro should yield code (abstract syntax tree)"<span class="keyword">;</span>
      prerr ", but a value that does not represent code is returned instead."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [_]
</span><span class="keyword">end</span> <span class="comment">// end of [macro_eval_decode]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
macro_eval_app_short <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> d2as<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> ctx <span class="keyword">=</span> EVAL0CTXnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> env <span class="keyword">=</span> ALPHAENVnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> d2e <span class="keyword">=</span> eval0_exp_app_mac_short <span class="keyword">(</span>loc0<span class="keyword">,</span> d2m<span class="keyword">,</span> ctx<span class="keyword">,</span> env<span class="keyword">,</span> d2as<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> alphaenv_free <span class="keyword">(</span>env<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eval0ctx_free <span class="keyword">(</span>ctx<span class="keyword">)</span>
<span class="keyword">in</span>
  d2e
<span class="keyword">end</span> <span class="comment">// end of [macro_eval_app_short]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_macro.dats] *)</span>
</pre>
</body>
</html>
