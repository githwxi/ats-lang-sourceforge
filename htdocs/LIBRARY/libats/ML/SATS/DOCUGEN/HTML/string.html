
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/libats/ML/string</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/libats/ML/string</h1>


The functions declared in this package are primarily for processing
C-style strings in functional programming.



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#itoa">itoa</a></li>
<li><a href="#string_sing">string_sing</a></li>
<li><a href="#string_copy">string_copy</a></li>
<li><a href="#string_make_substring">string_make_substring</a></li>
<li><a href="#string_append">string_append</a></li>
<li><a href="#stringlst_concat">stringlst_concat</a></li>
<li><a href="#string_explode">string_explode</a></li>
<li><a href="#string_implode">string_implode</a></li>
<li><a href="#string_tabulate">string_tabulate</a></li>
<li><a href="#string_foreach">string_foreach</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#+">+</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="itoa">itoa</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
itoa <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>

This function is for turning integers into their string representations.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_sing">string_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_sing <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">charNZ</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>

Given a non-null character, this function returns a singleton string
consisting of the character.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_copy">string_copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_copy<span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>
Given a string, this function returns a copy of it.<h3>Example</h3>

The following code tests that <span class="patsyntaxdynexp">string_copy</span> indeed returns a copy
of a given string:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_0.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> <span class="dynstr">"abcdefg"</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>str <span class="keyword">=</span> string_copy <span class="keyword">(</span>str<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_make_substring">string_make_substring</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_make_substring
<span class="keyword">(</span>
  x0<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> start<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> len<span class="keyword">:</span> <span class="staexp">size_t</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span> <span class="comment">// end-of-function</span></pre>
<h3>Description</h3>

Given a string str of length n and integers st and ln, this function
returns a string consisting of chars str[st], str[st+1], ...,
str[st+min(n-st,ln)-1] if st is less than n. Otherwise, it returns the
empty string.

<h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">substring_copy</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_1.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> <span class="dynstr">"abcdefg"</span></span>
  <span class="dynexp"><span class="keyword">val</span> str2 <span class="keyword">=</span> substring_copy <span class="keyword">(</span>str<span class="keyword">,</span> g1int2uint<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span><span class="keyword">,</span> string_length<span class="keyword">(</span>str<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>str <span class="keyword">=</span> str2<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_append">string_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_append
<span class="keyword">(</span>
  x1<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span> <span class="comment">// end of [string_append]</span></pre>
<h3>Description</h3>

This function, which overload the symbol <span class="patsyntaxdynexp">+</span>, returns the
concatenation of two given strings.

<h3>Example</h3>

The following code shows a typical way of combining strings:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_2.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> Hello <span class="keyword">=</span> <span class="dynstr">"H"</span>+<span class="dynstr">"e"</span>+<span class="dynstr">"l"</span>+<span class="dynstr">"l"</span>+<span class="dynstr">"o"</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print <span class="keyword">(</span>Hello + <span class="dynstr">", world!\n"</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

Note that the evaluation of the expression
<span class="patsyntaxdynexp">"H" + "e" + "l" + "l" + "o"</span>
generates the following intermediate strings "H", "He", "Hel", and
"Hell", which all become garbage once the evaluation returns the string
"Hello".

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="stringlst_concat">stringlst_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stringlst_concat<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>

Given a list xs of strings, this function returns the concatenation of
xs[0], xs[1], ,,,, xs[n-1], where n is the length of xs and the notation
xs[i] refers element i in xs.  <h3>Example</h3>

The following code shows a way to form the string "Hello" by
concatenating a list of singleton strings:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_3.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> Hello <span class="keyword">=</span>
stringlst_concat
<span class="keyword">(</span>
  <span class="keyword">(</span>list0<span class="keyword">)</span><span class="keyword">$arrpsz</span><span class="keyword">{</span><span class="staexp">string</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynstr">"H"</span><span class="keyword">,</span><span class="dynstr">"e"</span><span class="keyword">,</span><span class="dynstr">"l"</span><span class="keyword">,</span><span class="dynstr">"l"</span><span class="keyword">,</span><span class="dynstr">"o"</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [val] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> print <span class="keyword">(</span>Hello + <span class="dynstr">", world!\n"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

Note that the call to <span class="patsyntaxdynexp">stringlst_concat</span> constructs the string
"Hello" <em>without</em> generating any intermediate substrings.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_explode">string_explode</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_explode<span class="keyword">(</span>x0<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a string str of length n, this function returns a list consisting
of str[0], str[1], ..., and str[n-1], where each str[i] refers to char i in
str. <h3>Example</h3>

The following code checks that the length of the list obtained from calling
<span class="patsyntaxdynexp">string_explode</span> on a given string equals the length of the string:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_4.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> <span class="dynstr">"abcdefg"</span></span>
  <span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span> string_explode <span class="keyword">(</span>str<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>string_length <span class="keyword">(</span>str<span class="keyword">)</span> <span class="keyword">=</span> g0i2u<span class="keyword">(</span>list0_length <span class="keyword">(</span>cs<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_implode">string_implode</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_implode<span class="keyword">(</span>cs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">string</span></span></pre>
<h3>Description</h3>

Given a list cs of chars, this functions returns a string consisting of
cs[0], cs[1], ..., and cs[n-1], where n is the length of cs and each cs[i]
refers to char i in cs. Note that the length of the returned string is n
only if there is no null char in cs.

<h3>Example</h3>

The following code checks that the string obtained from calling
<span class="patsyntaxdynexp">string_implode</span> on the list returned from a call to
<span class="patsyntaxdynexp">string_explode</span> on a given string equals the given string:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_5.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> <span class="dynstr">"abcdefg"</span></span>
  <span class="dynexp"><span class="keyword">val</span> cs <span class="keyword">=</span> string_explode <span class="keyword">(</span>str<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> str2 <span class="keyword">=</span> string_implode <span class="keyword">(</span>cs<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>str <span class="keyword">=</span> str2<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_tabulate">string_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_tabulate
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  n0<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> fopr<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">sizeLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">charNZ</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">string</span></span> <span class="comment">// end of [string_tabulate]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="string_foreach">string_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
string_foreach
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function traverses its first argument (a string) and applies to each
encountered character its second argument (a closure-function).  <h3>Example</h3>

The following code prints a given string onto the standard output channel:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_string_6.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/string.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> str <span class="keyword">=</span> <span class="dynstr">"abcdefg"</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> string_foreach <span class="keyword">(</span>str<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>c<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_char <span class="keyword">(</span>c<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="+">+</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> + <span class="keyword">with</span> string_append <span class="keyword">of</span> 0</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

