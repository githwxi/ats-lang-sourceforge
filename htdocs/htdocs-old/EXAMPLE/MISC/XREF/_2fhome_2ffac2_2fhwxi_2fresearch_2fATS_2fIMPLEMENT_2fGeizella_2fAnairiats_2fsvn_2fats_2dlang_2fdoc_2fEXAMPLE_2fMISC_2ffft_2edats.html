<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>

<span class="comment">(*
**
** This is a primitive irrational-base discrete weighted transform taken
** from pseudocode found in: "Prime Numbers: A Computational Perspective"
**
** The code was originally written by Rick Lavoie and translated to ATS
** by Hongwei Xi (November, 2005)
**
** Absolutely no optimization has gone into this code; written for clarity,
** not speed.
**
*)</span>

<span class="comment">(*
**
** The code is ported to ATS/Geizella by Hongwei Xi (July 2007)
**
** test: 2 ^ 44497 - 1 is a prime! (BITSIZE = 16)
** time: 357.479u 0.234s 5:59.57 99.4%	0+0k 0+0io 0pf+0w
**
** test: 2 ^ 110503 - 1 is a prime! (BITSIZE = 16) 
** time: 2171.782u 2.094s 36:18.67 99.7% 0+0k 0+0io 0pf+0w
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="extern">%{^
static inline
ats_double_type
double_of_double (ats_double_type x) { return x ; }
%}</span> <span class="comment">// end of [%{^]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"libc/SATS/math.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"libc/SATS/stdio.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anonymous*)</span> <span class="keyword">=</span> "prelude/DATS/array.dats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><a name="976"><span class="stacstdec">real <span class="keyword">=</span> double</span></a></span>

<span class="keyword">macdef</span> <span class="neuexp">PI <span class="keyword">=</span> 3.1415926535897932384626</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1040"><span class="dyncstdec">real_of_double <span class="keyword">(</span>d<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">real</span></span></a> <span class="keyword">=</span> "double_of_double"
<span class="keyword">#define</span> <span class="neuexp">d2r real_of_double</span>

<span class="comment">// This is an experimental effort to differentiate imaginary from real
</span>
<span class="keyword">abst@ype</span> <span class="staexp"><a name="1205"><span class="stacstdec">imag <span class="keyword">=</span> <span class="keyword">$extype</span> "ats_double_type"</span></a></span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1250"><span class="dyncstdec">imag_of_double <span class="keyword">(</span>d<span class="keyword">:</span> <span class="staexp">double</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">imag</span></span></a>
  <span class="keyword">=</span> "double_of_double"

<span class="keyword">#define</span> <span class="neuexp">d2i imag_of_double</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1348"><span class="dyncstdec">add_imag_imag <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">imag</span></span></a>
  <span class="keyword">=</span> "atspre_add_double_double"
<span class="neuexp"><span class="keyword">overload</span> + <span class="keyword">with</span> add_imag_imag</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1460"><span class="dyncstdec">sub_imag_imag <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">imag</span></span></a>
  <span class="keyword">=</span> "atspre_sub_double_double"
<span class="neuexp"><span class="keyword">overload</span> - <span class="keyword">with</span> sub_imag_imag</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1572"><span class="dyncstdec">mul_imag_imag <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">real</span></span></a>
  <span class="keyword">=</span> "atspre_mul_double_double"

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1654"><span class="dyncstdec">mul_real_imag <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">real</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">imag</span></span></a>
  <span class="keyword">=</span> "atspre_mul_double_double"

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="1736"><span class="dyncstdec">mul_imag_real <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">imag</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">real</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">imag</span></span></a>
  <span class="keyword">=</span> "atspre_mul_double_double"

<span class="neuexp"><span class="keyword">overload</span> * <span class="keyword">with</span> mul_imag_imag</span>
<span class="neuexp"><span class="keyword">overload</span> * <span class="keyword">with</span> mul_real_imag</span>
<span class="neuexp"><span class="keyword">overload</span> * <span class="keyword">with</span> mul_imag_real</span>

<span class="comment">//
</span>
<span class="keyword">#define</span> <span class="neuexp">i2d double_of_int</span>

<span class="comment">//
</span>
<span class="keyword">fn</span> compute_signal_sum <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span></span></span> <span class="keyword">|</span> A<span class="keyword">:</span> <span class="staexp">ptr l</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">real</span> <span class="keyword">=</span>
  <span class="keyword">let</span>
     <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
         <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span></span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">real</span>
       <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">real</span> <span class="keyword">=</span>
       <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> loop <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> res + A[<span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">)</span> <span class="keyword">else</span> res
  <span class="keyword">in</span>
     loop <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> 0<span class="keyword">,</span> d2r 0.0<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [compute_signal_sum]
</span>
<span class="keyword">fn</span> convolve_signal <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_i<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">|</span>
   R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> t_r <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> t_i <span class="keyword">=</span> I[<span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> t_rr <span class="keyword">=</span> t_r * t_r <span class="keyword">and</span> t_ii <span class="keyword">=</span> t_i * t_i <span class="keyword">and</span> t_ri <span class="keyword">=</span> t_r * t_i
    <span class="keyword">in</span>
      R[<span class="prfexp">i</span><span class="keyword">]</span> := t_rr - t_ii<span class="keyword">;</span> I[<span class="prfexp">i</span><span class="keyword">]</span> := t_ri + t_ri<span class="keyword">;</span> loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="comment">// this is empty
</span>    <span class="keyword">end</span> 
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [convolve_signal]
</span>
<span class="keyword">fn</span> round_signal <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_i<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">|</span>
   R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">begin</span>
      R[<span class="prfexp">i</span><span class="keyword">]</span> := floor <span class="keyword">(</span>R[<span class="prfexp">i</span><span class="keyword">]</span> + d2r 0.5<span class="keyword">)</span><span class="keyword">;</span> I[<span class="prfexp">i</span><span class="keyword">]</span> := d2i <span class="keyword">(</span>0.0<span class="keyword">)</span><span class="keyword">;</span> loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [round_signal]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> forward_fft <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span> l_i<span class="keyword">,</span> l_w<span class="keyword">:</span>addr<span class="keyword">}</span></span>
   <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span> <span class="keyword">,</span>
    <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">,</span>
    <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span> <span class="keyword">|</span>
    R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> W<span class="keyword">:</span> <span class="staexp">ptr l_w</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">real</span> <span class="keyword">=</span> <span class="keyword">let</span>

  <span class="keyword">fun</span> aux0 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span>R[<span class="prfexp">i</span><span class="keyword">]</span> := R[<span class="prfexp">i</span><span class="keyword">]</span> * W[<span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">;</span> aux0 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> i+1<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span>

  <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">,</span> a_r<span class="keyword">:</span> <span class="staexp">real</span><span class="keyword">,</span> a_i<span class="keyword">:</span> <span class="staexp">imag</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> im <span class="keyword">=</span> i + m
  <span class="keyword">in</span>
    <span class="keyword">if</span> im <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> t1_r <span class="keyword">=</span> R[<span class="prfexp">im</span><span class="keyword">]</span> <span class="keyword">and</span> t1_i <span class="keyword">=</span> I[<span class="prfexp">im</span><span class="keyword">]</span>
      <span class="keyword">val</span> t2_r <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> t2_i <span class="keyword">=</span> I[<span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> := t2_r + t1_r
      <span class="keyword">and</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> I[<span class="prfexp">i</span><span class="keyword">]</span> := t2_i + t1_i
      <span class="keyword">val</span> t1_r <span class="keyword">=</span> t2_r - t1_r <span class="keyword">and</span> t1_i <span class="keyword">=</span> t2_i - t1_i
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">im</span><span class="keyword">]</span> := a_r * t1_r - a_i * t1_i
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> I[<span class="prfexp">im</span><span class="keyword">]</span> := a_r * t1_i + a_i * t1_r
    <span class="keyword">in</span>
      aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> im + m<span class="keyword">,</span> m<span class="keyword">,</span> a_r<span class="keyword">,</span> a_i<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="comment">// this is empty
</span>    <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux1]
</span>
  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>j<span class="keyword">,</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> j<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">int m</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> j <span class="keyword">&lt;</span> m <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> theta <span class="keyword">=</span> d2r <span class="keyword">(</span>PI * <span class="keyword">(</span>i2d j<span class="keyword">)</span> / <span class="keyword">(</span>i2d m<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> j<span class="keyword">,</span> m<span class="keyword">,</span> d2r <span class="keyword">(</span>cos theta<span class="keyword">)</span><span class="keyword">,</span> d2i <span class="keyword">~</span><span class="keyword">(</span>sin theta<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> j+1<span class="keyword">,</span> m<span class="keyword">)</span>
    <span class="keyword">end</span>

  <span class="keyword">fun</span> aux3 <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">|</span> m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> m &gt;= 1 <span class="keyword">then</span> <span class="keyword">(</span>aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> 0<span class="keyword">,</span> m<span class="keyword">)</span><span class="keyword">;</span> aux3 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> nhalf m<span class="keyword">)</span><span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux0 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
  <span class="keyword">val</span> sum <span class="keyword">=</span> compute_signal_sum <span class="keyword">(</span><span class="prfexp">pf_r</span> <span class="keyword">|</span> R<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">in</span>
  aux3 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> nhalf n<span class="keyword">)</span><span class="keyword">;</span> sum
<span class="keyword">end</span> <span class="comment">// end of [forward_fft]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> inverse_fft <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span> l_i<span class="keyword">,</span> l_w<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span> <span class="keyword">,</span>
   <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">,</span>
   <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span> <span class="keyword">|</span>
   R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> W<span class="keyword">:</span> <span class="staexp">ptr l_w</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">real</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">,</span> a_r<span class="keyword">:</span> <span class="staexp">real</span><span class="keyword">,</span> a_i<span class="keyword">:</span> <span class="staexp">imag</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> im <span class="keyword">=</span> i + m
  <span class="keyword">in</span>
    <span class="keyword">if</span> im <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> c_r <span class="keyword">=</span> R[<span class="prfexp">im</span><span class="keyword">]</span> <span class="keyword">and</span> c_i <span class="keyword">=</span> I[<span class="prfexp">im</span><span class="keyword">]</span>
      <span class="keyword">val</span> t1_r <span class="keyword">=</span> c_r * a_r - c_i * a_i
      <span class="keyword">and</span> t1_i <span class="keyword">=</span> c_r * a_i + c_i * a_r
      <span class="keyword">val</span> t2_r <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> t2_i <span class="keyword">=</span> I[<span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> := t2_r + t1_r <span class="keyword">and</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> I[<span class="prfexp">i</span><span class="keyword">]</span> := t2_i + t1_i
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">im</span><span class="keyword">]</span> := t2_r - t1_r <span class="keyword">and</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> I[<span class="prfexp">im</span><span class="keyword">]</span> := t2_i - t1_i
    <span class="keyword">in</span>
      aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> im + m<span class="keyword">,</span> m<span class="keyword">,</span> a_r<span class="keyword">,</span> a_i<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>j<span class="keyword">,</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">|</span>
     j<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> j <span class="keyword">&lt;</span> m <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> theta <span class="keyword">=</span> d2r <span class="keyword">(</span>PI * <span class="keyword">(</span>i2d j<span class="keyword">)</span> / <span class="keyword">(</span>i2d m<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> j<span class="keyword">,</span> m<span class="keyword">,</span> d2r <span class="keyword">(</span>cos theta<span class="keyword">)</span><span class="keyword">,</span> d2i <span class="keyword">(</span>sin theta<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> j+1<span class="keyword">,</span> m<span class="keyword">)</span>
    <span class="keyword">end</span>

  <span class="keyword">fun</span> aux3 <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> m<span class="keyword">:</span> <span class="staexp">int m</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> m <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span>aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> 0<span class="keyword">,</span> m<span class="keyword">)</span><span class="keyword">;</span> aux3 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> m+m<span class="keyword">)</span><span class="keyword">)</span>

  <span class="keyword">fun</span> aux4 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> nf<span class="keyword">:</span> <span class="staexp">real</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span>R[<span class="prfexp">i</span><span class="keyword">]</span> := R[<span class="prfexp">i</span><span class="keyword">]</span> / nf<span class="keyword">;</span> aux4 <span class="keyword">(</span><span class="prfexp">pf_r</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> nf<span class="keyword">)</span><span class="keyword">)</span>

  <span class="keyword">fun</span> aux5 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span>R[<span class="prfexp">i</span><span class="keyword">]</span> := R[<span class="prfexp">i</span><span class="keyword">]</span> / W[<span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">;</span> aux5 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> i+1<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux3 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> 1<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux4 <span class="keyword">(</span><span class="prfexp">pf_r</span> <span class="keyword">|</span> 0<span class="keyword">,</span> d2r <span class="keyword">(</span>i2d n<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">val</span> sum <span class="keyword">=</span> compute_signal_sum <span class="keyword">(</span><span class="prfexp">pf_r</span> <span class="keyword">|</span> R<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux5 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">in</span>
  sum
<span class="keyword">end</span> <span class="comment">// end of [inverse_fft]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> modular_reduce <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_b<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span> <span class="keyword">|</span>
   R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">ptr l_b</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> carry<span class="keyword">:</span> <span class="staexp">real</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">real</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> temp <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> + carry
      <span class="keyword">val</span> bi <span class="keyword">=</span> B[<span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> := fmod <span class="keyword">(</span>temp<span class="keyword">,</span> bi<span class="keyword">)</span>
    <span class="keyword">in</span>
      aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> floor <span class="keyword">(</span>temp / bi<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      carry <span class="comment">// return value
</span>    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>
  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> carry<span class="keyword">:</span> <span class="staexp">real</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span>
      <span class="keyword">if</span> carry <span class="keyword">=</span> d2r 0.0 <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="keyword">val</span> temp <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> + carry
        <span class="keyword">val</span> bi <span class="keyword">=</span> B[<span class="prfexp">i</span><span class="keyword">]</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> := fmod <span class="keyword">(</span>temp<span class="keyword">,</span> bi<span class="keyword">)</span>
      <span class="keyword">in</span>
        aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> floor <span class="keyword">(</span>temp / bi<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="keyword">begin</span>
      aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> 0<span class="keyword">,</span> carry<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>
  <span class="keyword">val</span> carry <span class="keyword">=</span> aux1 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> 0<span class="keyword">,</span> d2r 0.0<span class="keyword">)</span>
<span class="keyword">in</span>
  aux2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> 0<span class="keyword">,</span> carry<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [modular_reduce]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> subtract2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_b<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span> <span class="keyword">|</span>
   R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">ptr l_b</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span>
    <span class="keyword">,</span> <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> carry<span class="keyword">:</span> <span class="staexp">real</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span>
      <span class="keyword">if</span> carry <span class="keyword">=</span> d2r 0.0 <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="keyword">val</span> ri <span class="keyword">=</span> R[<span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> bi <span class="keyword">=</span> B[<span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> carry <span class="keyword">&gt;</span> ri <span class="keyword">then</span>
          <span class="keyword">(</span>R[<span class="prfexp">i</span><span class="keyword">]</span> := bi - carry + ri<span class="keyword">;</span> aux <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> d2r 1.0<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="keyword">val</span> t <span class="keyword">=</span> ri - carry
        <span class="keyword">in</span>
          R[<span class="prfexp">i</span><span class="keyword">]</span> := fmod <span class="keyword">(</span>t<span class="keyword">,</span> bi<span class="keyword">)</span><span class="keyword">;</span>
          aux <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> i+1<span class="keyword">,</span> floor <span class="keyword">(</span>t / bi<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        <span class="comment">// this is empty
</span>      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>   <span class="comment">// end of [if]
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> 0<span class="keyword">,</span> d2r 2.0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [substract2]
</span>
<span class="comment">//
</span>
<span class="keyword">#define</span> <span class="neuexp">BITSIZE 16</span>

<span class="keyword">fun</span> compute_optimal_signal_size <span class="keyword">(</span>exponent<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intGt 0</span> <span class="keyword">=</span>
  <span class="keyword">let</span>
     <span class="keyword">fun</span> aux <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">intGt 0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intGt 0</span> <span class="keyword">=</span>
       <span class="keyword">if</span> i <span class="keyword">&lt;</span> BITSIZE <span class="keyword">then</span> p <span class="keyword">else</span> aux <span class="keyword">(</span>nhalf i<span class="keyword">,</span> p + p<span class="keyword">)</span>
  <span class="keyword">in</span>
     aux <span class="keyword">(</span>exponent<span class="keyword">,</span> 1<span class="keyword">)</span>
  <span class="keyword">end</span>

<span class="comment">//
</span>
<span class="keyword">fun</span> compute_base_signal <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_b<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span> <span class="keyword">|</span> B<span class="keyword">:</span> <span class="staexp">ptr l_b</span><span class="keyword">,</span> exponent<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
  <span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
    <span class="keyword">(</span><span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> e <span class="keyword">=</span> i2d exponent
      <span class="keyword">val</span> en <span class="keyword">=</span> e / <span class="keyword">(</span>i2d n<span class="keyword">)</span>
      <span class="keyword">val</span> eni <span class="keyword">=</span> en * <span class="keyword">(</span>i2d i<span class="keyword">)</span>
    <span class="keyword">in</span>
      B[<span class="prfexp">i</span><span class="keyword">]</span> := pow <span class="keyword">(</span>d2r 2.0<span class="keyword">,</span> d2r <span class="keyword">(</span>ceil <span class="keyword">(</span>eni + en<span class="keyword">)</span> - ceil <span class="keyword">(</span>eni<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      aux <span class="keyword">(</span><span class="prfexp">pf_b</span> <span class="keyword">|</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span><span class="prfexp">pf_b</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [compute_base_signal]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> compute_weight_signal <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_w<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span>
  <span class="keyword">|</span> W<span class="keyword">:</span> <span class="staexp">ptr l_w</span><span class="keyword">,</span> exponent<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span><span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> e <span class="keyword">=</span> i2d exponent
      <span class="keyword">val</span> en <span class="keyword">=</span> e / <span class="keyword">(</span>i2d n<span class="keyword">)</span>
      <span class="keyword">val</span> eni <span class="keyword">=</span> en * <span class="keyword">(</span>i2d i<span class="keyword">)</span>
    <span class="keyword">in</span>
      W[<span class="prfexp">i</span><span class="keyword">]</span> := pow <span class="keyword">(</span>d2r 2.0<span class="keyword">,</span> d2r <span class="keyword">(</span>ceil eni - eni<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      aux <span class="keyword">(</span><span class="prfexp">pf_w</span> <span class="keyword">|</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span><span class="prfexp">pf_w</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [compute_weight_signal]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> check_zero_signal <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span></span></span> <span class="keyword">|</span> A<span class="keyword">:</span> <span class="staexp">ptr l</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span></span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">if</span> A[<span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">=</span> d2r 0.0 <span class="keyword">then</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> i+1<span class="keyword">)</span> <span class="keyword">else</span> false<span class="keyword">)</span>
    <span class="keyword">else</span> true
<span class="keyword">in</span>
  aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [check_zero_signal]
</span>
<span class="comment">//
</span>
<span class="keyword">fun</span> do_iteration <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_i<span class="keyword">,</span>l_b<span class="keyword">,</span>l_w<span class="keyword">:</span>addr<span class="keyword">}</span></span>
   <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">,</span> 
    <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span> <span class="keyword">|</span>
    R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">ptr l_b</span><span class="keyword">,</span> W<span class="keyword">:</span> <span class="staexp">ptr l_w</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> sum_in <span class="keyword">=</span> forward_fft <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> W<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> convolve_signal <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> sum_out <span class="keyword">=</span> inverse_fft <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> W<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> diff <span class="keyword">=</span> abs <span class="keyword">(</span>sum_in * sum_in - sum_out<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> diff <span class="keyword">&gt;</span> d2r 1.0 <span class="keyword">then</span> <span class="keyword">begin</span>
    print "Possible error: difference = "<span class="keyword">;</span> print diff<span class="keyword">;</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
   <span class="keyword">end</span><span class="keyword">;</span>
   round_signal <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
   modular_reduce <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> R<span class="keyword">,</span> B<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
   subtract2 <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> R<span class="keyword">,</span> B<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [do_iteration]
</span>
<span class="keyword">#define</span> <span class="neuexp">STRIDE 100</span>

<span class="keyword">fun</span> main_loop <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l_r<span class="keyword">,</span>l_i<span class="keyword">,</span>l_b<span class="keyword">,</span>l_w<span class="keyword">:</span>addr<span class="keyword">}</span></span>
   <span class="keyword">(</span><span class="prfexp">pf_r<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_r<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_i<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>imag<span class="keyword">,</span> n<span class="keyword">,</span> l_i<span class="keyword">)</span></span></span> <span class="keyword">,</span> 
    <span class="prfexp">pf_b<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_b<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_w<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>array_v <span class="keyword">(</span>real<span class="keyword">,</span> n<span class="keyword">,</span> l_w<span class="keyword">)</span></span></span> <span class="keyword">|</span>
    R<span class="keyword">:</span> <span class="staexp">ptr l_r</span><span class="keyword">,</span> I<span class="keyword">:</span> <span class="staexp">ptr l_i</span><span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">ptr l_b</span><span class="keyword">,</span> W<span class="keyword">:</span> <span class="staexp">ptr l_w</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span>
    i<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">,</span> limit<span class="keyword">:</span> <span class="staexp">Nat</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> limit <span class="keyword">then</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> <span class="keyword">(</span>i mod STRIDE <span class="keyword">=</span> 0<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">(</span>print '.'<span class="keyword">;</span> fflush_stdout <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
    do_iteration <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span><span class="keyword">,</span> <span class="prfexp">pf_b</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> B<span class="keyword">,</span> W<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
    main_loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span><span class="keyword">,</span> <span class="prfexp">pf_b</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> B<span class="keyword">,</span> W<span class="keyword">,</span> n<span class="keyword">,</span> i+1<span class="keyword">,</span> limit<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span>
<span class="comment">// Here are the first few Mersenne primes:
</span><span class="comment">// 2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607,
</span><span class="comment">// 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213,
</span><span class="comment">// 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091,
</span><span class="comment">// 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593,
</span><span class="comment">// 13466917, ...
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*

implement{a} array_ptr_alloc (n) =
  array_ptr_alloc_tsz {a} (n, sizeof&lt;a&gt;)

*)</span>

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anonymous*)</span> <span class="keyword">=</span> "prelude/DATS/array.dats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// The following function tests whether 2^exponent-1 is a prime:
</span><span class="keyword">fun</span> is_mersenne_prime <span class="keyword">(</span>exponent<span class="keyword">:</span> <span class="staexp">intGte 2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> n <span class="keyword">=</span> compute_optimal_signal_size <span class="keyword">(</span>exponent<span class="keyword">)</span>
  <span class="keyword">val</span> n_sz <span class="keyword">=</span> size1_of_int1 n
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc_r</span><span class="keyword">,</span> <span class="prfexp">pf_r</span> <span class="keyword">|</span> R<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n_sz<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_initialize_elt&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>R<span class="keyword">,</span> n_sz<span class="keyword">,</span> d2r 0.0<span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc_i</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> I<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">imag</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n_sz<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_initialize_elt&lt;<span class="staexp">imag</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>I<span class="keyword">,</span> n_sz<span class="keyword">,</span> d2i 0.0<span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc_b</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> B<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n_sz<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_initialize_elt&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>B<span class="keyword">,</span> n_sz<span class="keyword">,</span> d2r 0.0<span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc_w</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> W<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n_sz<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_initialize_elt&lt;<span class="staexp">real</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>W<span class="keyword">,</span> n_sz<span class="keyword">,</span> d2r 0.0<span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> compute_base_signal <span class="keyword">(</span><span class="prfexp">pf_b</span> <span class="keyword">|</span> B<span class="keyword">,</span> exponent<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> compute_weight_signal <span class="keyword">(</span><span class="prfexp">pf_w</span> <span class="keyword">|</span> W<span class="keyword">,</span> exponent<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> R[<span class="prfexp">0</span><span class="keyword">]</span> := d2r 4.0
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> main_loop <span class="keyword">(</span><span class="prfexp">pf_r</span><span class="keyword">,</span> <span class="prfexp">pf_i</span><span class="keyword">,</span> <span class="prfexp">pf_b</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> R<span class="keyword">,</span> I<span class="keyword">,</span> B<span class="keyword">,</span> W<span class="keyword">,</span> n<span class="keyword">,</span> 0<span class="keyword">,</span> exponent - 2<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> check_zero_signal <span class="keyword">(</span><span class="prfexp">pf_r</span> <span class="keyword">|</span> R<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">in</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>real<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc_r</span><span class="keyword">,</span> <span class="prfexp">pf_r</span> <span class="keyword">|</span> R<span class="keyword">)</span><span class="keyword">;</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>imag<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc_i</span><span class="keyword">,</span> <span class="prfexp">pf_i</span> <span class="keyword">|</span> I<span class="keyword">)</span><span class="keyword">;</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>real<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc_b</span><span class="keyword">,</span> <span class="prfexp">pf_b</span> <span class="keyword">|</span> B<span class="keyword">)</span><span class="keyword">;</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>real<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc_w</span><span class="keyword">,</span> <span class="prfexp">pf_w</span> <span class="keyword">|</span> W<span class="keyword">)</span><span class="keyword">;</span>
  ans
<span class="keyword">end</span> <span class="comment">// end of [is_mersenne_prime]
</span>
<span class="comment">//
</span>
<span class="keyword">fn</span> usage <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  print "A natural number argument &gt;= 2 is needed."<span class="keyword">;</span>
  print_newline <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span>

<span class="keyword">implement</span> main <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> argc &lt;= 1 <span class="keyword">then</span> <span class="keyword">(</span>usage <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> exit <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span>1<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assert <span class="keyword">(</span>argc <span class="keyword">&gt;</span> 1<span class="keyword">)</span>
  <span class="keyword">val</span> exp <span class="keyword">=</span> int1_of <span class="keyword">(</span>argv<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">1</span><span class="keyword">]</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> exp &lt;= 1 <span class="keyword">then</span> <span class="keyword">(</span>usage <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> exit <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span>1<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>  assert <span class="keyword">(</span>exp <span class="keyword">&gt;</span> 1<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> is_mersenne_prime exp <span class="keyword">then</span> <span class="keyword">begin</span>
    printf <span class="keyword">(</span>"2 ^ %i - 1 is a prime!\n"<span class="keyword">,</span> <span class="keyword">@(</span>exp<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    printf <span class="keyword">(</span>"2 ^ %i - 1 is a composite.\n"<span class="keyword">,</span> <span class="keyword">@(</span>exp<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [main]
</span>
<span class="comment">////

/* FFT.c
Very primitive implementation of the irrational-base discrete weighted transform.
Written by Rick Lavoie
Taken from pseudocode found in "Prime Numbers: A Computational Perspective"

Absolutely no optimization has gone into this code. It's written for clarity, not speed.
*/
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;

#define PI 3.1415926535897932384626

// Displays the contents of a signal
int display_signal(double* real, double* imag, unsigned int signal_size)
{
	unsigned int i;

	if (imag == NULL) { // Pass NULL as the second parameter if we just want the real part
		for (i = 0; i &lt; signal_size; i++)
			printf("%.2f ", real[i]);
	} else {
		for (i = 0; i &lt; signal_size; i++) 
			printf("%.2f+%.2fi ", real[i], imag[i]);
	}

	printf("\n");
	return 0;
}

// Adds together the values of a signal. Used for error-checking
double compute_signal_sum(double* real, unsigned int signal_size)
{
	unsigned int i;
	double running_total = 0.0;

	for (i = 0; i &lt; signal_size; i++) 
		running_total += real[i]; 
	
	return running_total;
}

// Computes the forward fast fourier transform of a complex signal. Uses Gentleman-Sande decimation
// in frequency variant. weight is a weight signal, and signal_size is the size of the signal. real
// and imag are the signal to be transformed. Bitscrambling is not done.
double forward_fast_fourier(double* real, double* imag, double* weight, unsigned int signal_size)
{
	unsigned int m, j, i;
	double a_real, a_imag, temp1_real, temp1_imag, temp2_real, temp2_imag;
	double sum;
	
	for (m = 0; m &lt; signal_size; m++) // Initially multiply the input by the weights
		real[m] *= weight[m];
	
	sum = compute_signal_sum(real, signal_size);

	// Taken straight from "Prime Numbers"
	for (m = signal_size/2; m &gt;= 1; m = m/2) {
		for (j = 0; j &lt; m; j++) {
			a_real = cos((2.0*PI*j*signal_size/(2*m))/signal_size);
			a_imag = -sin((2.0*PI*j*signal_size/(2*m))/signal_size);
			for (i = j; i &lt; signal_size; i += 2*m) {
				temp1_real = real[i+m];
				temp1_imag = imag[i+m];
				temp2_real = real[i];
				temp2_imag = imag[i];
				real[i] = temp2_real + temp1_real;
				imag[i] = temp2_imag + temp1_imag;
				temp1_real = temp2_real - temp1_real;
				temp1_imag = temp2_imag - temp1_imag;
				real[i+m] = (a_real * temp1_real) - (a_imag * temp1_imag);
				imag[i+m] = (a_real * temp1_imag) + (a_imag * temp1_real);
			}
		}
	}

	return sum;
}

// Computes the inverse fast fourier transform. Uses Cooley-Turkey decimation in time. Parameters
// are the same as the forward transform. Bitscrambling is not done, because the use of the two
// different decimations cancels them out.
double inverse_fast_fourier(double* real, double* imag, double* weight, unsigned int signal_size)
{
	unsigned int m, j, i;
	double a_real, a_imag, temp1_real, temp1_imag, temp2_real, temp2_imag;
	double sum;
		
	for (m = 1; m &lt; signal_size; m = 2*m) {
		for (j = 0; j &lt; m; j++) {
			a_real = cos((2.0*PI*j*signal_size/(2*m))/signal_size);
			a_imag = sin((2.0*PI*j*signal_size/(2*m))/signal_size);
			for (i = j; i &lt; signal_size; i += 2*m) {
				temp1_real = (real[i+m] * a_real) - (imag[i+m] * a_imag);
				temp1_imag = (real[i+m] * a_imag) + (imag[i+m] * a_real);
				temp2_real = real[i];
				temp2_imag = imag[i];
				real[i] = temp2_real + temp1_real;
				imag[i] = temp2_imag + temp1_imag;
				real[i+m] = temp2_real - temp1_real;
				imag[i+m] = temp2_imag - temp1_imag;
			}
		}
	}

	for (m = 0; m &lt; signal_size; m++) // Divide by the signal_size to re-normalize the signal
		real[m] = real[m] / signal_size;
	
	sum = compute_signal_sum(real, signal_size);
	
	for (m = 0; m &lt; signal_size; m++)  // Adjust by the weights
		real[m] = real[m] / weight[m];
	
	return sum;
}

// Convulves a transformed signal. IE, square the signal dyadically.
int convulve_signal(double* real, double* imag, unsigned int signal_size)
{
	unsigned int i;
	double temp_real, temp_imag;

	for (i = 0; i &lt; signal_size; i++) {
		temp_real = real[i];
		temp_imag = imag[i];
		real[i] = (temp_real * temp_real) - (temp_imag * temp_imag); // Complex multiplication
		imag[i] = (temp_real * temp_imag) + (temp_real * temp_imag);
	}

	return 0;
}

// Rounds the floating point signal to closest integers.
int round_signal(double* real, double* imag, unsigned int signal_size)
{
	unsigned int i;

	// I'll eventually add a check to see if we're not rounding too far
	for (i = 0; i &lt; signal_size; i++) 
		real[i] = floor(real[i] + 0.5);
	
	return 0;
}

// Reduces the signal into their appropriate bases. base is the base signal. 
int modular_reduce(double* real, double* base, unsigned int signal_size)
{
	unsigned int i;
	double carry = 0;
	double temp;

	for (i = 0; i &lt; signal_size; i++) {
		temp = real[i] + carry;
		real[i] = fmod(temp, base[i]);
		carry = floor(temp/base[i]);
	}
	
	while (carry != 0) {
		for (i = 0; i &lt; signal_size; i++) {
			if (carry == 0)
				break;
			temp = real[i] + carry;
			real[i] = fmod(temp, base[i]);
			carry = floor(temp/base[i]);
		}
	}
	
	return 0;
}

// Subtracts 2 from the signal. This is part of the Lucas-Lehmer test. This code won't work
// if the base is less than 2.
int subtract_2(double* real, double* base, unsigned int signal_size)
{
	unsigned int i;
	double carry = 2; // Subtract 2
	double temp;

	for (i = 0; i &lt; signal_size; i++) {
		if (carry == 0) // No more carry, so we can exit early
			break;
		else if (carry &gt; real[i]) { // If real[i] is less than the carry
			real[i] = base[i] - (carry - real[i]);
			carry = 1;
		} else {
			temp = real[i] - carry; // Subtract the carry
			real[i] = fmod(temp, base[i]); // Modular adjust
			carry = floor(temp/base[i]); // Get the carry
		}
	}

	return 0;
}

// Computes the optimal size of a signal, given an exponent
unsigned int compute_optimal_signal_size(unsigned int exponent)
{
	unsigned int temp = 1;
	// "Prime Numbers" says to find a signal_length such that Floor[2^(exponent/temp)] is
	// an "appropriate" size;
	while (1) { 
		if ((double)exponent/temp &lt; 16) // I have no clue how to decide what's an ideal bitsize
			break; // so I'm just using 16 bits and hope it's adequate
		temp *= 2;
	}

	return temp;
}

// Computes the base signal for an exponent
int compute_base_signal(double* base, unsigned int exponent, unsigned int signal_size)
{
	unsigned int i;
	// "Prime Numbers" says base[i-1] = 2^(Ceil[exponent*i/signal_size] - Ceil[exponent*(i-1)/signal_size]);
	// Running i from 1 to signal_size;
	for (i = 1; i &lt;= signal_size; i++) 
		base[i-1] = pow(2, ceil((double)exponent*i/signal_size)-ceil((double)exponent*(i-1)/signal_size));

	return 0;
}

// Computes the weight signal for an exponent
int compute_weight_signal(double* weight, unsigned int exponent, unsigned int signal_size)
{
	unsigned int i;
	double temp;
	// "Prime Numbers" says weight[i] = 2^(Ceil[exponent*i/signal_size]-(exponent*i/signal_size))
	for (i = 0; i &lt; signal_size; i++) {
		temp = ((double)exponent*i)/signal_size;
		weight[i] = pow(2, ceil(temp) - temp);
	}

	return 0;
}

int check_zero_signal(double* signal, unsigned int signal_size)
{
	int is_zero = 1;
	unsigned int i;

	for (i = 0; i &lt; signal_size; i++) {
		if (signal[i] != 0) {
			is_zero = 0;
			break;
		}
	}

	return is_zero;
}

// Performs one Lucas-Lehmer iteration using the IBDWT algorithm
int do_iteration(double* real, double* imag, double* weight, double* base, unsigned int signal_size)
{
	double sum_in, sum_out, difference;
		
	// I know that you can "embed" the real signal into the complex, but for clarity I'm avoiding that
	sum_in = forward_fast_fourier(real, imag, weight, signal_size);

	// Square the elements
	convulve_signal(real, imag, signal_size);

	// Invert the signal
	sum_out = inverse_fast_fourier(real, imag, weight, signal_size);

	// What's the difference between sum_in^2 and sum_out
	difference = fabs((sum_in * sum_in) - sum_out);
	if (difference &gt; 10)  // Uh oh, an error, they're not matching
		printf("**POSSIBLE ERROR**: SUMIN and SUMOUT differ by %.2f\n", difference);
		
	// Round the signal to integers
	round_signal(real, imag, signal_size);
	memset(imag, 0, signal_size*sizeof(double));

	// Modular reduce them to their variable base
	modular_reduce(real, base, signal_size); 
	// Subtract 2
	subtract_2(real, base, signal_size);

	return 0;
}

int main(int argc, char* argv[])
{

  double* real; // Real part of the signal
  double* imag; // Imaginary part of the signal
  unsigned int signal_size; // Signal length
  unsigned int exponent; // Exponent for the LL test (Change as needed)
  double* base; // Variable base of the signal
  double* weight; // Weight signal
  unsigned int i;

  exponent = atoi(argv[1]);

  // Find out the appropriate size for this exponent
  signal_size = compute_optimal_signal_size(exponent);

  // Allocate memory
  base = malloc(sizeof(double)*signal_size);
  weight = malloc(sizeof(double)*signal_size);
  real = malloc(sizeof(double)*signal_size);
  imag = malloc(sizeof(double)*signal_size);

  // Clear memory and compute the signals
  memset(real, 0, sizeof(double) * signal_size);
  memset(imag, 0, sizeof(double) * signal_size);
  compute_base_signal(base, exponent, signal_size);
  compute_weight_signal(weight, exponent, signal_size);

  real[0] = 4; // LL test starts with 4
  for (i = 0; i &lt; exponent-2; i++) {
    do_iteration(real, imag, weight, base, signal_size);
    if (i % 100 == 0)
      printf("%i\r\n", i);
  }

  if (check_zero_signal(real, signal_size) == 1)
    printf("PRIME!!!\n");
  else
    printf("Not Prime\n");

  // Clear memory
  free(base);
  free(weight);
  free(real);
  free(imag);
  return 0;
}

(* ****** ****** *)

(* end of [fft.dats] *)
</span></pre>
</body>
</html>
