
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/array</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/array</h1>


<p>
The type for a plain ungarnished array containing N elements of type T is
denoted by the special syntax <span class="patsyntaxstaexp">@[T][N]</span>. The size of this
array-type is N times the size of T and its linearity coincides with the
linearity of T, that is, the type <span class="patsyntaxstaexp">@[T][N]</span> is linear if and only
if T is linear.  It should be noted that a value of this form of array-type
can be passed to a function call only as a call-by-reference parameter
(unless certain special arrangement is made for it to be passed as a
call-by-value parameter).
</p><!--para-->

<p>
Please see <a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/SATS/array.sats">array.sats</a> and
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/array.dats">array.dats</a>
(plus
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/array_bsearch.dats">array_bsearch.dats</a>,
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/array_quicksort.dats">array_quicksort.dats</a>)
for the SATS file
and DATS files in ATSLIB where the functions in this package are declared
and implemented.
</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#array_v">array_v</a></li>
<li><a href="#ArraySubscriptExn">ArraySubscriptExn</a></li>
<li><a href="#lemma_array_param">lemma_array_param</a></li>
<li><a href="#lemma_array_v_param">lemma_array_v_param</a></li>
<li><a href="#array_v_nil">array_v_nil</a></li>
<li><a href="#array_v_unnil">array_v_unnil</a></li>
<li><a href="#array_v_unnil_nil">array_v_unnil_nil</a></li>
<li><a href="#array_v_cons">array_v_cons</a></li>
<li><a href="#array_v_uncons">array_v_uncons</a></li>
<li><a href="#array_v_sing">array_v_sing</a></li>
<li><a href="#array_v_unsing">array_v_unsing</a></li>
<li><a href="#array_getref_at">array_getref_at</a></li>
<li><a href="#array_get_at">array_get_at</a></li>
<li><a href="#array_get_at_gint">array_get_at_gint</a></li>
<li><a href="#array_get_at_guint">array_get_at_guint</a></li>
<li><a href="#array_set_at">array_set_at</a></li>
<li><a href="#array_set_at_gint">array_set_at_gint</a></li>
<li><a href="#array_set_at_guint">array_set_at_guint</a></li>
<li><a href="#array_exch_at">array_exch_at</a></li>
<li><a href="#array_exch_at_gint">array_exch_at_gint</a></li>
<li><a href="#array_exch_at_guint">array_exch_at_guint</a></li>
<li><a href="#array_interchange">array_interchange</a></li>
<li><a href="#array_subcirculate">array_subcirculate</a></li>
<li><a href="#array_ptr_alloc">array_ptr_alloc</a></li>
<li><a href="#array_ptr_free">array_ptr_free</a></li>
<li><a href="#array_ptr_tabulate">array_ptr_tabulate</a></li>
<li><a href="#array_tabulate$fopr">array_tabulate$fopr</a></li>
<li><a href="#fprint_array">fprint_array</a></li>
<li><a href="#fprint_array$sep">fprint_array$sep</a></li>
<li><a href="#fprint_array_sep">fprint_array_sep</a></li>
<li><a href="#array_foreach">array_foreach</a></li>
<li><a href="#array_foreach_env">array_foreach_env</a></li>
<li><a href="#array_foreach$cont">array_foreach$cont</a></li>
<li><a href="#array_foreach$fwork">array_foreach$fwork</a></li>
<li><a href="#array_foreach_funenv">array_foreach_funenv</a></li>
<li><a href="#array_foreach_fun">array_foreach_fun</a></li>
<li><a href="#array_foreach2">array_foreach2</a></li>
<li><a href="#array_foreach2_env">array_foreach2_env</a></li>
<li><a href="#array_foreach2$cont">array_foreach2$cont</a></li>
<li><a href="#array_foreach2$fwork">array_foreach2$fwork</a></li>
<li><a href="#array_rforeach">array_rforeach</a></li>
<li><a href="#array_rforeach_env">array_rforeach_env</a></li>
<li><a href="#array_rforeach$cont">array_rforeach$cont</a></li>
<li><a href="#array_rforeach$fwork">array_rforeach$fwork</a></li>
<li><a href="#array_initize">array_initize</a></li>
<li><a href="#array_initize$init">array_initize$init</a></li>
<li><a href="#array_initize_elt">array_initize_elt</a></li>
<li><a href="#array_initize_list">array_initize_list</a></li>
<li><a href="#array_initize_rlist">array_initize_rlist</a></li>
<li><a href="#array_initize_list_vt">array_initize_list_vt</a></li>
<li><a href="#array_initize_rlist_vt">array_initize_rlist_vt</a></li>
<li><a href="#array_uninitize">array_uninitize</a></li>
<li><a href="#array_uninitize$clear">array_uninitize$clear</a></li>
<li><a href="#array_bsearch">array_bsearch</a></li>
<li><a href="#array_bsearch$ford">array_bsearch$ford</a></li>
<li><a href="#array_bsearch_stdlib">array_bsearch_stdlib</a></li>
<li><a href="#array_quicksort">array_quicksort</a></li>
<li><a href="#array_quicksort$cmp">array_quicksort$cmp</a></li>
<li><a href="#array_quicksort_stdlib">array_quicksort_stdlib</a></li>
<li><a href="#array_mapto">array_mapto</a></li>
<li><a href="#array_mapto$fwork">array_mapto$fwork</a></li>
<li><a href="#array_map2to">array_map2to</a></li>
<li><a href="#array_map2to$fwork">array_map2to$fwork</a></li>
<li><a href="#array_permute">array_permute</a></li>
<li><a href="#array_permute$randint">array_permute$randint</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#[]">[]</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="array_v">array_v</a></h2>
<h3>Synopsis</h3>
<p><pre class="patsyntax"><span class="keyword">viewtypedef</span> <span class="staexp">array_v <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span> <span class="keyword">viewt@ype</span></span><span class="keyword">,</span> <span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span> int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span></pre>
</p><h3>Description</h3>

Given a type T, an address L and an integer N, the view
<span class="patsyntaxstaexp">array_v(T, L, N)</span> means that a value of the type
<span class="patsyntaxstaexp">@[T][N]</span> is stored at the location L. An equivalent
definition of <span class="patsyntaxstaexp">array_v</span> can be given as follows:

<pre class="patsyntax"><span class="keyword">dataview</span> <span class="staexp">array_v
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> l<span class="keyword">:</span>addr<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">array_v_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="comment">(*none*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    array_v_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [array_v]</span>
</pre>


where <span class="patsyntaxstaexp">array_v</span> is (recursively) defined as a dataview.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ArraySubscriptExn">ArraySubscriptExn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">exception</span>
<span class="dynexp">ArraySubscriptExn <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

By convention, this exception is raised to indicate a situation where the
index involved in array subscripting is out-of-bounds.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_array_param">lemma_array_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_array_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function establishes that the integer n in any array-type
<span class="patsyntaxstaexp">@[T][n]</span> is a natural number.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_array_v_param">lemma_array_v_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_array_v_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function establishes that the integer n in any array-view
<span class="patsyntaxstaexp">array_v(T, l, n)</span> is a natural number.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_nil">array_v_nil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
array_v_nil <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This proof function generates a proof of empty array-view.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_unnil">array_v_unnil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
array_v_unnil <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function consumes a proof of empty array-view.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_unnil_nil">array_v_unnil_nil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
array_v_unnil_nil <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This proof function consumes a proof of empty array-view and then generates
a proof of empty array-view. It is a combination of array_v_unnil and array_v_nil.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_cons">array_v_cons</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
array_v_cons <span class="keyword">:</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This proof function composes a proof of at-view and
a proof of array-view of size n to form a proof of array-view of size n+1.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_uncons">array_v_uncons</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
array_v_uncons <span class="keyword">:</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
<span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="staexp">+</span><span class="staexp">sizeof</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function is the inverse of <span class="patsyntaxprfexp">array_v_cons</span>: It
decomposes a proof of array-view of size n into a proof of at-view and a
proof of array-view of size n-1, where n is positive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_sing">array_v_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
array_v_sing
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This proof function turns a proof of at-view into a proof of array-view of
size 1.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_v_unsing">array_v_unsing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
array_v_unsing
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span></pre>
<h3>Description</h3>

This proof function is the inverse of <span class="patsyntaxprfexp">array_v_sing</span>: It turns a
proof of array-view of size 1 into a proof of at-view.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_getref_at">array_getref_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_getref_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the pointer to array-cell i of the given array A,
that is, the pointer equal to addr@(A)+i*sizeof&lt;a&gt;, where addr@(A)
refers to the starting address of A.  <h3>Example</h3>
A typical use of
<span class="patsyntaxdynexp">array_getref_at</span> is given in the following example:
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_0.dats"><span class="comment">//</span>
<span class="neuexp"><span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
array_get_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p <span class="keyword">=</span> array_getref_at&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_get <span class="keyword">(</span>p<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_get_at]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
array_set_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p <span class="keyword">=</span> array_getref_at&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_set <span class="keyword">(</span>p<span class="keyword">,</span> x<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_set_at]</span>
</pre>


Note that unsafe functions
<span class="patsyntaxdynexp">cptr_get</span> and <span class="patsyntaxdynexp">cptr_set</span>
are called here to read from and write through the pointer p.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_get_at">array_get_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_get_at <span class="keyword">with</span> array_get_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_get_at <span class="keyword">with</span> array_get_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_get_at_gint">array_get_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_get_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1intLt</span><span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">a</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, returns the value
stored in array-cell i of the given array A.  Note that the type for values
stored in A is nonlinear.  <h3>Example</h3>

The following code computes the sum of the doubles stored in a given array:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_1.dats"><span class="dynexp"><span class="keyword">fn</span> tally<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">double</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="comment">(*none*)</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">double</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">double</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="comment">(*none*)</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> i <span class="keyword">then</span> loop <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">,</span> res + <span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">)</span> <span class="keyword">else</span> res</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> <span class="dynexp">0</span><span class="comment">(*i*)</span><span class="keyword">,</span> <span class="dynexp">0.0</span><span class="comment">(*res*)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [tally]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_get_at_guint">array_get_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_get_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uintLt</span><span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">a</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, is like
<span class="patsyntaxdynexp">array_get_at_gint</span> except that the index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_set_at">array_set_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_set_at <span class="keyword">with</span> array_set_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_set_at <span class="keyword">with</span> array_set_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_set_at_gint">array_set_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_set_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1intLt</span><span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, stores a value
into array-cell i of the given array A, overwriting the original
value. Note that the type of values stored in A is nonlinear.  <h3>Example</h3>

The following code doubles the integer value of each array-cell in a given
array:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_2.dats"><span class="dynexp"><span class="keyword">fn</span> doubling<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">int</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">int</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> i <span class="keyword">then</span> <span class="keyword">(</span><span class="dynexp">A[i<span class="keyword">]</span></span> := <span class="dynexp">2</span> * <span class="dynexp">A[i<span class="keyword">]</span></span><span class="keyword">;</span> loop <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [doubling]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_set_at_guint">array_set_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_set_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uintLt</span><span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, is like
<span class="patsyntaxdynexp">array_set_at_gint</span> except that the index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_exch_at">array_exch_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_exch_at <span class="keyword">with</span> array_exch_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> array_exch_at <span class="keyword">with</span> array_exch_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_exch_at_gint">array_exch_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_exch_at_gint<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1intLt</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function exchanges the value in array-cell i of the given array A and the
value in its second argument. Note that the type of these values can be linear.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_exch_at_guint">array_exch_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> array_exch_at_guint<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uintLt</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function, which is like <span class="patsyntaxdynexp">array_exch_at_gint</span> except that the
index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_interchange">array_interchange</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_interchange
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_interchange]</span></pre>
<h3>Description</h3>

Given an array and two valid indices i and j, this function interchanges
the values in array-cell i and array-cell j.  Note that the type of these
values can be linear.  <h3>Example</h3>

The following code implements the standard insertion sort:
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_3.dats"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
insertion_sort
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop1
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> i1 <span class="keyword">=</span> pred <span class="keyword">(</span>i<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> gcompare_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="dynexp"><span class="keyword">.</span><span class="keyword">[</span>i1<span class="keyword">]</span></span><span class="keyword">,</span> A<span class="dynexp"><span class="keyword">.</span><span class="keyword">[</span>i<span class="keyword">]</span></span><span class="keyword">)</span></span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    <span class="keyword">(</span>
      array_interchange <span class="keyword">(</span>A<span class="keyword">,</span> i1<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">;</span> loop1 <span class="keyword">(</span>A<span class="keyword">,</span> i1<span class="keyword">)</span>
    <span class="keyword">)</span> <span class="comment">// end of [if]</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop2
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">(</span>loop1 <span class="keyword">(</span>A<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">;</span> loop2 <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> succ<span class="keyword">(</span>i<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
  <span class="keyword">if</span> n &gt;= <span class="dynexp">2</span> <span class="keyword">then</span> loop2 <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> g1i2u<span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="comment">(*exit*)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insertion_sort]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_subcirculate">array_subcirculate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_subcirculate
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">sizeLt</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_subcirculate]</span></pre>
<h3>Description</h3>

Given an array A and two valid indices i and j, this function circulates
the values stored in array-cells between cell i and cell j, inclusive.  If
i is less than j, then A[k] moves into A[k+1] for k ranging from i up to
j-1 and A[j] moves into A[i]. If i is greater than j, then A[k] moves into
A[k-1] for k ranging from i down to j+1, and A[j] moves into A[i].
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_ptr_alloc">array_ptr_alloc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_ptr_alloc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span>
<span class="keyword">(</span>
  <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [array_ptr_alloc] *)</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_ptr_free">array_ptr_free</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span><span class="comment">(*void*)</span><span class="keyword">}</span></span>
array_ptr_free
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span><span class="keyword">,</span> <span class="prfexp"><span class="staexp">mfree_gc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end-of-function</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_ptr_tabulate">array_ptr_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_ptr_tabulate
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">array_v</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_tabulate$fopr">array_tabulate$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_tabulate$fopr<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_array">fprint_array</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint_array <span class="keyword">with</span> fprint_array_int</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint_array <span class="keyword">with</span> fprint_array_size</span></pre>
<h3>Description</h3>

This function prints the elements in a given array to the output
channel provided as its first argument, and it calls the function
<span class="patsyntaxdynexp">fprint_array$sep</span> before printing an element as long as the
element is not the first one.  Note that printing each array element is
handled by calling the function <span class="patsyntaxdynexp">fprint_ref</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_array$sep">fprint_array$sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span><span class="comment">(*void*)</span><span class="keyword">}</span></span>
fprint_array$sep <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_array_sep">fprint_array_sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_array_sep<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">,</span> A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_array_sep]</span></pre>
<h3>Description</h3>

This function prints the elements in a given array to the output channel
provided as its first argument, interspersing the string <span class="patsyntaxdynexp">sep</span>
between the printed array elements. Note that printing each array element is
handled by calling the function <span class="patsyntaxdynexp">fprint_ref</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach">array_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_foreach]</span></pre>
<h3>Description</h3>

This function traverses a given array from left to right, applying to each
encountered array-cell the function implemented by
<span class="patsyntaxdynexp">array_foreach$fwork</span>.  The traversal stops if the function
implemented by <span class="patsyntaxdynexp">array_foreach$cont</span> returns false, and the return
value of <span class="patsyntaxdynexp">array_foreach</span> indicates the number of processed
array-cells.  <h3>Example</h3>

The following code implements a function that searches for the index of the
first array-cell in a given array that contains an element satisfing the
predicate provided as the third argument of the function:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_4.dats"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
array_find<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">sizeLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span>
array_foreach$cont&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">~</span>p<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span>
array_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="comment">(*nothing*)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> array_foreach <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> i <span class="keyword">then</span> Some_vt <span class="keyword">(</span>i<span class="keyword">)</span> <span class="keyword">else</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_find]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach_env">array_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach_env<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_foreach_env]</span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">array_foreach</span>
except for taking an additional argument that serves as an environment.
<h3>Example</h3>

The following code implements the standard fold-from-left operation on a
given array:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_5.dats"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> array_foldleft<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">res</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">res</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">res</span> <span class="keyword">=</span> ini
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
array_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">res</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := f <span class="keyword">(</span>env<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> _<span class="comment">(*asz*)</span> <span class="keyword">=</span> array_foreach_env <span class="keyword">(</span>A<span class="keyword">,</span> asz<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  env
<span class="keyword">end</span></span> <span class="comment">// end of [array_foldleft]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach$cont">array_foreach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach$cont <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach$fwork">array_foreach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach_funenv">array_foreach_funenv</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_foreach_funenv
  <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>view<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>vt<span class="keyword">:</span>vtype<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>fe<span class="keyword">:</span>eff<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfv<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">v</span></span>
<span class="keyword">|</span> A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">v</span> <span class="keyword">|</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">vt</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp"><span class="keyword">fun</span></span><span class="keyword">,</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">vt</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">array_foreach</span> except that the function
to be applied to each array-cell is provided as an argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach_fun">array_foreach_fun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_foreach_fun
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>fe<span class="keyword">:</span>eff<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp"><span class="keyword">fun</span></span><span class="keyword">,</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_foreach_fun]</span></pre>
<h3>Description</h3>

This function is a special case of <span class="patsyntaxdynexp">array_foreach_funenv</span> in that
the provided function does not take an argument as its environment.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach2">array_foreach2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach2
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a1</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> A2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a2</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_foreach2]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach2_env">array_foreach2_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach2_env
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a1</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> A2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a2</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span>
<span class="keyword">,</span> asz<span class="keyword">:</span><span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">env</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_foreach2_env]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach2$cont">array_foreach2$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach2$cont
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a1</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a2</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_foreach2$fwork">array_foreach2$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_foreach2$fwork
  <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a1</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a2</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_rforeach">array_rforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_rforeach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_rforeach]</span></pre>
<h3>Description</h3>

This function traverses a given array from right to left, applying to each
encountered array-cell the function implemented by
<span class="patsyntaxdynexp">array_rforeach$fwork</span>. The traversal stops is the function
implemented by <span class="patsyntaxdynexp">array_rforeach$cont</span> returns false, and the
return value of <span class="patsyntaxdynexp">array_rforeach</span> indicates the number of
processed array-cells.  <h3>Example</h3>

The following code implements a function that searches for the index of the
last array-cell in a given array that contains an element satisfing the
predicate provided as the third argument of the function:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_6.dats"><span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
array_rfind<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">bool</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">sizeLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span>
array_rforeach$cont&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">~</span>p<span class="keyword">(</span>x<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span>
array_rforeach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="comment">(*nothing*)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> array_rforeach <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> i <span class="keyword">then</span> Some_vt <span class="keyword">(</span>pred<span class="keyword">(</span>n<span class="keyword">)</span>-i<span class="keyword">)</span> <span class="keyword">else</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [array_rfind]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_rforeach_env">array_rforeach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_rforeach_env<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [array_rforeach_env]</span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">array_rforeach</span>
except for taking an additional argument that serves as an environment.  <h3>Example</h3>

The following code implements the standard fold-from-right operation on a
given array:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_7.dats">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> array_foldright<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">res</span><span class="keyword">,</span> snk<span class="keyword">:</span> <span class="staexp">res</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">res</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">res</span> <span class="keyword">=</span> snk
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
array_rforeach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">res</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := f <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> _<span class="comment">(*asz*)</span> <span class="keyword">=</span> array_rforeach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="keyword">,</span> asz<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  env
<span class="keyword">end</span></span> <span class="comment">// end of [array_foldright]</span>
</pre>


Please note that <span class="patsyntaxdynexp">array_rforeach_env</span> is given a
tail-recursive implementation in ATSLIB.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_rforeach$cont">array_rforeach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_rforeach$cont<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_rforeach$fwork">array_rforeach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_rforeach$fwork<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize">array_initize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_initize<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize$init">array_initize$init</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_initize$init <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize_elt">array_initize_elt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
array_initize_elt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> elt<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize_elt]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize_list">array_initize_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
array_initize_list<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize_list]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize_rlist">array_initize_rlist</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
array_initize_rlist<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize_rlist]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize_list_vt">array_initize_list_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_initize_list_vt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize_list_vt]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_initize_rlist_vt">array_initize_rlist_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_initize_rlist_vt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_initize_rlist_vt]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_uninitize">array_uninitize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_uninitize
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_uninitize]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_uninitize$clear">array_uninitize$clear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_uninitize$clear<span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_bsearch">array_bsearch</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_bsearch
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_bsearch$ford">array_bsearch$ford</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_bsearch$ford <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_bsearch_stdlib">array_bsearch_stdlib</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_bsearch_stdlib
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> key<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span></span> <span class="comment">(* found/~found : ~null/null *)</span></pre>
<h3>Description</h3>

This function is a wrapper around the function <span class="patsyntaxdynexp">bsearch</span> declared
in stdlib.h of libc.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_quicksort">array_quicksort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_quicksort
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end-of-function</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_quicksort$cmp">array_quicksort$cmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_quicksort$cmp<span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span><span class="comment">(*sgn*)</span></pre>
<h3>Description</h3>

This function is called in the implementation of
<span class="patsyntaxdynexp">array_quicksort</span> to perform comparison test on array elements,
and its default implementation is based on <span class="patsyntaxdynexp">gcompare_ref</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_8.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
array_quicksort$cmp <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gcompare_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_quicksort_stdlib">array_quicksort_stdlib</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_quicksort_stdlib
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_quicksort_stdlib]</span></pre>
<h3>Description</h3>

This function is a wrapper around the function <span class="patsyntaxdynexp">qsort</span> declared
in stdlib.h of libc.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_mapto">array_mapto</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_mapto<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">b</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">array</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_mapto]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_mapto$fwork">array_mapto$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_mapto$fwork<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">b</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_map2to">array_map2to</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_map2to<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> B<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> C<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">c</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">array</span> <span class="keyword">(</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [array_map2to]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_map2to$fwork">array_map2to$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> array_map2to$fwork<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">b</span><span class="keyword">,</span> z<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">c</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">c</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_permute">array_permute</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
array_permute<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="keyword">@[</span><span class="staexp">a</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function permutes the contents of a given array according to the
random number generator implemented by <span class="patsyntaxdynexp">array_permute$randint</span>.
<h3>Example</h3>

The following code creates an array of integers 1, 2, 3, 4, and 5, and then
permutes the array contents to obtain an array of integers 5, 1, 2, 3, and
4:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_array_9.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">{</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> N 5</span>
<span class="dynexp"><span class="keyword">val</span> asz <span class="keyword">=</span> g1i2u <span class="keyword">(</span>N<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> array_ptr_alloc&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>asz<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
array_initize$init&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>i<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> x := g0u2i<span class="keyword">(</span>i<span class="keyword">)</span>+<span class="dynexp">1</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_initize&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> asz<span class="keyword">)</span></span> <span class="comment">// array: 1, 2, ..., N-1, N</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
<span class="keyword">)</span> <span class="keyword">=</span> fprint_array_sep <span class="keyword">(</span>out<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> asz<span class="keyword">,</span> <span class="dynstr">","</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
array_permute$randint&lt;<span class="keyword">&gt;</span> <span class="keyword">(</span>n<span class="keyword">)</span> <span class="keyword">=</span> pred<span class="keyword">(</span>n<span class="keyword">)</span></span> <span class="comment">// this is not random</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_permute&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> asz<span class="keyword">)</span></span> <span class="comment">// array: N, 1, 2, ..., N-1</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
<span class="keyword">)</span> <span class="keyword">=</span> fprint_array_sep <span class="keyword">(</span>out<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> asz<span class="keyword">,</span> <span class="dynstr">","</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_free <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [main0]</span>
</pre>

Note that the created array is properly freed before the code exits.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="array_permute$randint">array_permute$randint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="comment">(*void*)</span><span class="keyword">}</span></span>
array_permute$randint<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> array_get_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> array_get_at_guint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> array_set_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> array_set_at_guint <span class="keyword">of</span> 0</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

