<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: February 2008
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">// 
</span><span class="comment">// ats_solver_fm:  solving linear constraints with the Fourier-Motzkin
</span><span class="comment">// variable elimination method. This implementation is largely adopted
</span><span class="comment">// from an earlier implementation for DML (done in 1998)
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extern">%{^
#include "ats_solver_fm.cats"
%}</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">fn</span> prerr_interror <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr "INTERNAL ERROR (ats_solver_fm)"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Lst <span class="keyword">=</span> "ats_list.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_solver_fm.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> i0nt_0 <span class="keyword">=</span> i0nt_of_int 0
<span class="keyword">implement</span> i0nt_1 <span class="keyword">=</span> i0nt_of_int 1
<span class="keyword">implement</span> i0nt_neg_1 <span class="keyword">=</span> i0nt_of_int <span class="keyword">(</span>~1<span class="keyword">)</span>

<span class="keyword">implement</span> print_i0nt <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_i0nt<span class="keyword">,</span> x<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
fprint_intvec <span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> <span class="keyword">(</span>i <span class="keyword">&lt;</span> n<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> ", "<span class="keyword">)</span><span class="keyword">;</span>
      fprint_i0nt <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">;</span> aux <span class="keyword">(</span>out<span class="keyword">,</span> vec<span class="keyword">,</span> n<span class="keyword">,</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>out<span class="keyword">,</span> vec<span class="keyword">,</span> n<span class="keyword">,</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_intvec]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
print_intvec <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> ptr_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  fprint_intvec <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stdout<span class="keyword">,</span> vec<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
  stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [print_intvec]
</span>
<span class="keyword">implement</span>
prerr_intvec <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stderr</span> <span class="keyword">|</span> ptr_stderr<span class="keyword">)</span> <span class="keyword">=</span> stderr_get <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  fprint_intvec <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stderr<span class="keyword">,</span> vec<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
  stderr_view_set <span class="keyword">(</span><span class="prfexp">pf_stderr</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [prerr_intvec]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> intvec_ptr_alloc <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> <span class="keyword">(</span>intvec n<span class="keyword">)</span>? @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span> <span class="keyword">=</span>
  array_ptr_alloc_tsz <span class="staexp"><span class="keyword">{</span>i0nt<span class="keyword">}</span></span> <span class="keyword">(</span>size1_of_int1 n<span class="keyword">,</span> sizeof&lt;<span class="staexp">i0nt</span><span class="keyword">&gt;</span><span class="keyword">)</span>

<span class="keyword">fn</span> intvec_ptr_free <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_gc<span class="keyword">:</span> <span class="staexp">free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span></span></span><span class="keyword">,</span> <span class="prfexp">pf_arr<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>intvec n<span class="keyword">)</span>? @ l</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr l</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>i0nt<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
<span class="comment">// end of [intvec_ptr_free]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">local</span>

<span class="keyword">assume</span> <span class="staexp">intvecptr_t <span class="keyword">(</span>n<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">@(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span>
<span class="comment">// end of [intvecptr_t]
</span>
<span class="keyword">in</span>

<span class="keyword">implement</span>
fprint_intvecptr <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> ivp<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">prval</span> <span class="prfexp">pf_arr <span class="keyword">=</span> ivp<span class="keyword">.</span>1</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intvec <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span><span class="keyword">(</span>ivp<span class="keyword">.</span>2<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ivp<span class="keyword">.</span>1 := pf_arr</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [fprint_intvecptr]
</span>
<span class="keyword">end</span> <span class="comment">// end of [local]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> icstr_free <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>ic<span class="keyword">:</span> <span class="staexp">icstr n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> ic <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>ICvec <span class="keyword">(</span>_<span class="keyword">,</span> ivp<span class="keyword">)</span> <span class="keyword">=&gt;</span> intvecptr_free <span class="keyword">(</span>ivp<span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">~</span>ICveclst <span class="keyword">(</span>_<span class="keyword">,</span> ics<span class="keyword">)</span> <span class="keyword">=&gt;</span> icstrlst_free ics
<span class="keyword">end</span> <span class="comment">// end of [icstr_free]
</span>
<span class="keyword">implement</span>
icstrlst_free <span class="keyword">(</span>ics<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ics <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons <span class="keyword">(</span>ic<span class="keyword">,</span> ics<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>icstr_free ic<span class="keyword">;</span> icstrlst_free ics<span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [icstrlst_free]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
fprint_icstr <span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> ic<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">macdef</span> <span class="neuexp">prstr <span class="keyword">(</span>s<span class="keyword">)</span> <span class="keyword">=</span> fprint1_string <span class="keyword">(</span>pf_mod <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">,(</span>s<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> ic <span class="keyword">of</span>
  <span class="keyword">|</span> ICvec <span class="keyword">(</span>knd<span class="keyword">,</span> <span class="keyword">!</span>ivp<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "ICvec("<span class="keyword">;</span> prstr "knd="<span class="keyword">;</span>
      fprint1_int <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> knd<span class="keyword">)</span><span class="keyword">;</span>
      prstr "; "<span class="keyword">;</span>
      fprint_intvecptr <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>ivp<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
      prstr ")"<span class="keyword">;</span>
      fprint_newline <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">)</span><span class="keyword">;</span>
      fold@ ic
    <span class="keyword">end</span> <span class="comment">// end of [ICvec]
</span>  <span class="keyword">|</span> ICveclst <span class="keyword">(</span>knd<span class="keyword">,</span> <span class="keyword">!</span>ics<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      prstr "ICveclst("<span class="keyword">;</span> prstr "knd="<span class="keyword">;</span>
      fprint1_int <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> knd<span class="keyword">)</span><span class="keyword">;</span>
      prstr "; "<span class="keyword">;</span>
      fprint_icstrlst <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>ics<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
      prstr ")"<span class="keyword">;</span>
      fprint_newline <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">)</span><span class="keyword">;</span>
      fold@ ic
    <span class="keyword">end</span> <span class="comment">// end of [ICveclst]
</span><span class="keyword">end</span> <span class="comment">// end of [fprint_icstr]
</span>
<span class="keyword">implement</span>
fprint_icstrlst <span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> ics<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ics <span class="keyword">of</span>
  <span class="keyword">|</span> list_vt_cons <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint_icstr <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>ic<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
      fprint_icstrlst <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
      fold@ ics
    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]
</span>  <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fold@ ics
<span class="keyword">end</span> <span class="comment">// end of [fprint_icstrlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
print_icstr <span class="keyword">(</span>ic<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> ptr_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  fprint_icstr <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stdout<span class="keyword">,</span> ic<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
  stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [print_icstr]
</span>
<span class="keyword">implement</span>
print_icstrlst <span class="keyword">(</span>ics<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> ptr_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  fprint_icstrlst <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stdout<span class="keyword">,</span> ics<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
  stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [print_icstrlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">local</span>

<span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>ic<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>icstr n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> ic <span class="keyword">of</span>
  <span class="keyword">|</span> ICvec <span class="keyword">(</span><span class="keyword">!</span>knd<span class="keyword">,</span> _<span class="comment">(*ivp*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>knd := 0 - <span class="keyword">(</span><span class="keyword">!</span>knd<span class="keyword">)</span><span class="keyword">;</span> fold@ ic<span class="keyword">)</span>
  <span class="keyword">|</span> ICveclst <span class="keyword">(</span><span class="keyword">!</span>knd<span class="keyword">,</span> <span class="keyword">!</span>ics<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">!</span>knd := 1 - <span class="keyword">!</span>knd<span class="keyword">;</span> auxlst <span class="keyword">(</span><span class="keyword">!</span>ics<span class="keyword">)</span><span class="keyword">;</span> fold@ ic<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [aux]
</span>
<span class="keyword">and</span> auxlst <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>s<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>ics<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>icstrlst <span class="keyword">(</span>n<span class="keyword">,</span> s<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> ics <span class="keyword">of</span>
  <span class="keyword">|</span> list_vt_cons <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>aux <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> auxlst <span class="keyword">(</span><span class="keyword">!</span>ics_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ ics<span class="keyword">)</span>
  <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fold@ ics
<span class="keyword">end</span> <span class="comment">// end of [auxlst]
</span>
<span class="keyword">in</span> <span class="comment">// in of [local]
</span>
<span class="keyword">implement</span> icstr_negate <span class="keyword">(</span>ic<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>aux ic<span class="keyword">;</span> ic<span class="keyword">)</span>
<span class="keyword">implement</span> icstrlst_negate <span class="keyword">(</span>ics<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>auxlst ics<span class="keyword">;</span> ics<span class="keyword">)</span>

<span class="keyword">end</span> <span class="comment">// end of [local]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataviewtype</span> <span class="staexp"><a name="6345"><span class="stacstdec">intveclst <span class="keyword">(</span>int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>pos</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">}</span>
    INTVECLSTcons <span class="staexp"><span class="keyword">(</span>n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">,</span> intveclst n<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>pos</span><span class="keyword">}</span> INTVECLSTnil <span class="staexp"><span class="keyword">(</span>n<span class="keyword">)</span></span>
<span class="comment">// end of [intveclst]
</span>
<span class="keyword">fun</span> intveclst_free <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp">intveclst n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> vecs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLSTcons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> vecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span><span class="keyword">;</span> intveclst_free <span class="keyword">(</span>vecs_nxt<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [INTVECLSTcons]
</span>  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intveclst_free]
</span>
<span class="keyword">fun</span> fprint_intveclst <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_mod<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span> w<span class="keyword">)</span></span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> vecs <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span>  <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>vecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intvec <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>pf_arr := pf<span class="keyword">)</span></span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intveclst <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>vecs_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ <span class="keyword">(</span>vecs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [INTVECLSTcons]
</span>  <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ vecs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_intveclst]
</span>
<span class="keyword">fun</span> print_intveclst <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> ptr_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intveclst <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stdout<span class="keyword">,</span> vecs<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="comment">// nothing
</span><span class="keyword">end</span> <span class="comment">// end of [print_intveclst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">UNKNOWN <span class="keyword">(</span>0<span class="keyword">)</span></span>
<span class="keyword">#define</span> <span class="neuexp">TAUTOLOGY <span class="keyword">(</span>1<span class="keyword">)</span></span>
<span class="keyword">#define</span> <span class="neuexp">CONTRADICTION <span class="keyword">(</span>~1<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> intvec_coeff_gcd <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">i0nt</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> gcd<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>i0nt</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> vi &lt;&gt; 0 <span class="keyword">then</span>
        <span class="keyword">if</span> vi &lt;&gt; 1 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>gcd := gcd_i0nt_i0nt <span class="keyword">(</span>vi<span class="keyword">,</span> gcd<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> gcd &lt;&gt; 1 <span class="keyword">then</span> aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> gcd<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          gcd := vi <span class="comment">// return now!
</span>        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">else</span> <span class="keyword">begin</span>
        aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> gcd<span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">var</span> gcd<span class="keyword">:</span> <span class="staexp">i0nt</span> <span class="keyword">=</span> i0nt_of_int 0  
<span class="keyword">in</span>
  aux <span class="keyword">(</span>vec<span class="keyword">,</span> n-1<span class="keyword">,</span> gcd<span class="keyword">)</span><span class="keyword">;</span> gcd
<span class="keyword">end</span> <span class="comment">// end of [intvec_coeff_gcd]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="8452"><span class="dyncstdec">intvec_normalize_gte <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>

<span class="keyword">implement</span>
intvec_normalize_gte <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>max<span class="keyword">(</span>i+1<span class="keyword">,</span>0<span class="keyword">)</span><span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> gcd<span class="keyword">:</span> <span class="staexp">i0nt</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> i &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> vi &lt;&gt; 0 <span class="keyword">then</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := <span class="keyword">(</span>vi / gcd<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> gcd<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">val</span> gcd <span class="keyword">=</span> intvec_coeff_gcd <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> gcd <span class="keyword">&gt;</span> 1 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> v0 <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span>
<span class="comment">(*
    val () = begin
      print "intvec_normalize_gte: gcd = "; print_i0nt gcd; print_newline ();
      print "intvec_normalize_gte: v0_old = "; print_i0nt v0; print_newline ();
    end
*)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux <span class="keyword">(</span>vec<span class="keyword">,</span> n-1<span class="keyword">,</span> gcd<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> 0 <span class="keyword">of</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> v0 &gt;= 0 <span class="keyword">=&gt;</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := v0 / gcd
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := succ <span class="keyword">(</span>v0 - gcd<span class="keyword">)</span> / gcd
    <span class="keyword">end</span> <span class="comment">// end of [val]
</span><span class="comment">(*
    val v0 = vec.[0]
    val () = begin
      print "intvec_normalize_gte: v0_new = "; print_i0nt v0; print_newline ()
    end
*)</span>
  <span class="keyword">in</span>
    <span class="comment">// empty    
</span>  <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_normalize_gte]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="9517"><span class="dyncstdec">intvec_normalize_eq
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intvec_normalize_eq]
</span>
<span class="keyword">implement</span>
intvec_normalize_eq <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>max<span class="keyword">(</span>i+1<span class="keyword">,</span>0<span class="keyword">)</span><span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> gcd<span class="keyword">:</span> <span class="staexp">i0nt</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> i &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> vi &lt;&gt; 0 <span class="keyword">then</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := <span class="keyword">(</span>vi / gcd<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> gcd<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">val</span> gcd <span class="keyword">=</span> intvec_coeff_gcd <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> gcd <span class="keyword">&gt;</span> 1 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> v0 <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> mod_i0nt_i0nt <span class="keyword">(</span>v0<span class="keyword">,</span> gcd<span class="keyword">)</span> <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">(</span>aux <span class="keyword">(</span>vec<span class="keyword">,</span> n-1<span class="keyword">,</span> gcd<span class="keyword">)</span><span class="keyword">;</span> 0<span class="keyword">)</span>
    <span class="keyword">else</span> ~1 <span class="comment">// a contradiction
</span>  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    0 <span class="comment">// there is nothing to be done
</span>  <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_normalize_eq]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="10253"><span class="dyncstdec">intvec_inspect_gte <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span></span></a>
<span class="comment">// end of [intvec_inspect_gte]
</span>
<span class="keyword">implement</span>
intvec_inspect_gte <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> &lt;&gt; 0 <span class="keyword">then</span> UNKNOWN <span class="keyword">else</span> aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> &gt;= 0 <span class="keyword">then</span> TAUTOLOGY <span class="keyword">else</span> CONTRADICTION
    <span class="keyword">end</span>
  <span class="keyword">val</span> sgn <span class="keyword">=</span> aux <span class="keyword">(</span>vec<span class="keyword">,</span> n - 1<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> sgn <span class="keyword">=</span> 0 <span class="keyword">then</span> intvec_normalize_gte <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span>
<span class="keyword">in</span>
  sgn
<span class="keyword">end</span> <span class="comment">// end of [intvec_inspect_gte]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="10777"><span class="dyncstdec">intveclst_inspect_gte
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intveclst_inspect_gte]
</span>
<span class="keyword">implement</span>
intveclst_inspect_gte <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> vecs <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLSTcons <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp"><span class="keyword">!</span>pf_gc</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>vecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
      <span class="keyword">val</span> sgn <span class="keyword">=</span> intvec_inspect_gte <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn &lt;&gt; 0 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// tautology
</span>        intvec_ptr_free <span class="keyword">(</span><span class="prfexp"><span class="keyword">!</span>pf_gc</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span><span class="keyword">;</span> 
        <span class="keyword">let</span> <span class="keyword">val</span> tmp <span class="keyword">=</span> <span class="keyword">!</span>vecs_nxt <span class="keyword">in</span> free@ <span class="keyword">{</span>n<span class="keyword">}</span> <span class="keyword">(</span>vecs<span class="keyword">)</span><span class="keyword">;</span> vecs := tmp <span class="keyword">end</span><span class="keyword">;</span>
        <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> intveclst_inspect_gte <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> ~1
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="keyword">val</span> ans <span class="keyword">=</span> intveclst_inspect_gte <span class="keyword">(</span><span class="keyword">!</span>vecs_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">in</span>
        fold@ vecs<span class="keyword">;</span> ans
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ vecs<span class="keyword">;</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intveclst_inspect_gte]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="11599"><span class="dyncstdec">intvec_inspect_eq <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span></span></a>
<span class="comment">// end of [intvec_inspect_eq]
</span>
<span class="keyword">implement</span>
intvec_inspect_eq <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>i<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Sgn</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> &lt;&gt; 0 <span class="keyword">then</span> UNKNOWN <span class="keyword">else</span> aux <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> <span class="keyword">=</span> 0 <span class="keyword">then</span> TAUTOLOGY <span class="keyword">else</span> CONTRADICTION
    <span class="keyword">end</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span>vec<span class="keyword">,</span> n - 1<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_inspect_eq]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* 
** HX:
** the function returns the index of the coefficient with minimum
** non-zero absolute value
*)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="12159"><span class="dyncstdec">intvec_absmin_coeff_index_get
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>1<span class="keyword">,</span> n<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intvec_absmin_coeff_index_get]
</span>
<span class="keyword">implement</span>
intvec_absmin_coeff_index_get <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>i0<span class="keyword">:</span> nat <span class="keyword">|</span> 1 &lt;= i0<span class="keyword">;</span> i &lt;= i0<span class="keyword">;</span> i0 <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> i0<span class="keyword">:</span> <span class="staexp">int i0</span><span class="keyword">,</span> c0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>i0nt</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>1<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">if</span> c0 <span class="keyword">=</span> 1 <span class="keyword">then</span> i0
    <span class="keyword">else</span> <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">if</span> vi &gt;= 0 <span class="keyword">then</span> vi <span class="keyword">else</span> <span class="keyword">~</span>vi<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">i0nt</span>
      <span class="keyword">var</span> flag<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0
<span class="comment">(*
      val () = begin
        print "aux1: i = "; print i; print_newline ();
        print "aux1: vi = "; print_i0nt vi; print_newline ();
        print "aux1: i0 = "; print i0; print_newline ();
        print "aux1: c0 = "; print_i0nt c0; print_newline ();
      end
*)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
        <span class="keyword">if</span> vi <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">if</span> c0 <span class="keyword">&gt;</span> vi <span class="keyword">then</span> <span class="keyword">(</span>c0 := vi<span class="keyword">;</span> flag := 1<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> flag <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
        aux1 <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span>  i<span class="keyword">,</span> c0<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        aux1 <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> i0<span class="keyword">,</span> c0<span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      i0 <span class="comment">// the vec.[i0] should not be zero!
</span>    <span class="keyword">end</span>
  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span> nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>i<span class="keyword">&gt;.</span></span> 
    <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>1<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> vi <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
        <span class="keyword">let</span> <span class="keyword">var</span> c0<span class="keyword">:</span> <span class="staexp">i0nt</span> <span class="keyword">=</span>  vi <span class="keyword">in</span> aux1 <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> i<span class="keyword">,</span> c0<span class="keyword">)</span> <span class="keyword">end</span>
      <span class="keyword">else</span> <span class="keyword">if</span> vi <span class="keyword">&lt;</span> 0 <span class="keyword">then</span>
        <span class="keyword">let</span> <span class="keyword">var</span> c0<span class="keyword">:</span> <span class="staexp">i0nt</span> <span class="keyword">=</span> <span class="keyword">~</span>vi <span class="keyword">in</span> aux1 <span class="keyword">(</span>vec<span class="keyword">,</span> i-1<span class="keyword">,</span> i<span class="keyword">,</span> c0<span class="keyword">)</span> <span class="keyword">end</span>
      <span class="keyword">else</span> aux2 <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> i-1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      prerr_interror <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      prerr ": intvec_absmin_coeff_index_get: all coefficients are zero: "<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      prerr "vec = "<span class="keyword">;</span> prerr <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">val</span> ind <span class="keyword">=</span> aux2 <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> n - 1<span class="keyword">)</span>
<span class="comment">(*
  val () = let
    val vind = vec.[ind] in
    if vind &lt; ~1 orelse vind &gt; 1 then begin
      print "intvec_absmin_coeff_index_get: vec = ";
      print (vec, n); print_newline ();
      print "intvec_absmin_coeff_index_get: ind = ";
      print ind; print_newline ();
      print "intvec_absmin_coeff_index_get: vind = ";
      print_i0nt vind; print_newline ();
    end // end of [if]
  end // end of [val]
*)</span>
<span class="keyword">in</span>
  ind
<span class="keyword">end</span> <span class="comment">// end of [intvec_absmin_coeff_index_get]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="14309"><span class="dyncstdec">intvec_copy <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span></span></a>
  <span class="keyword">=</span> "ats_solver_fm_intvec_copy"
<span class="comment">// end of [intvec_copy]
</span>
<span class="keyword">implement</span>
intvec_copy <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_alloc <span class="keyword">(</span>n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> array_ptr_copy_tsz <span class="staexp"><span class="keyword">{</span>i0nt<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> size1_of_int1 n<span class="keyword">,</span> sizeof&lt;<span class="staexp">i0nt</span><span class="keyword">&gt;</span><span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">@(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_copy]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="14726"><span class="dyncstdec">intvecptr_copy <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intvecptr_t n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span></span></a>
  <span class="keyword">=</span> "ats_solver_fm_intvec_copy"
<span class="comment">// end of [intvecptr_copy]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="14937"><span class="dyncstdec">intvec_negate <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>

<span class="keyword">implement</span>
intvec_negate <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> i <span class="keyword">=</span> n - 1 <span class="keyword">in</span>
  <span class="keyword">while*</span> <span class="comment">// going downward
</span>    <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">~1 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">i+1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>i &gt;= 0<span class="keyword">)</span> <span class="keyword">begin</span>
      vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := <span class="keyword">~</span><span class="keyword">(</span>vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">)</span> <span class="keyword">;</span> i := i - 1 <span class="keyword">;</span>
    <span class="keyword">end</span> <span class="comment">// end of [while]
</span><span class="keyword">end</span> <span class="comment">// end of [intvec_negate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="15282"><span class="dyncstdec">intvec_scale <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">i0nt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></a>

<span class="keyword">implement</span>
intvec_scale <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> c<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
<span class="comment">//
</span><span class="keyword">if</span> <span class="keyword">(</span>c &lt;&gt; 1<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="keyword">var</span> i <span class="keyword">=</span> n - 1
<span class="keyword">in</span>
  <span class="keyword">while*</span> <span class="comment">// going downward
</span>    <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">~1 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">i+1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>i &gt;= 0<span class="keyword">)</span> <span class="keyword">begin</span>
      vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := c * vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">;</span> i := i - 1 <span class="keyword">;</span>
    <span class="keyword">end</span> <span class="comment">// end of [while]
</span><span class="keyword">end</span> <span class="comment">// end if [if]
</span><span class="comment">//
</span><span class="keyword">end</span> <span class="comment">// end of [intvec_scale]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="15685"><span class="dyncstdec">intvec_copy_and_scale <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">i0nt</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intvec_copy_and_scale]
</span>
<span class="keyword">implement</span>
intvec_copy_and_scale <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> c<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">if</span> c &lt;&gt; 1 <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="comment">// this could be done in one-loop, but ...
</span>    <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> intvec_copy <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_scale <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">,</span> c<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">@(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    intvec_copy <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_copy_and_scale]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX: [vec1 := vec1 + vec2]
</span><span class="comment">//
</span><span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="16242"><span class="dyncstdec">intvec_add_by <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec1<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> vec2<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intvec_add_by]
</span>
<span class="keyword">implement</span>
intvec_add_by <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec1<span class="keyword">,</span> vec2<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> i <span class="keyword">=</span> n - 1
<span class="keyword">in</span>
  <span class="keyword">while*</span> <span class="comment">// going downward
</span>    <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">~1 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">i+1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>i &gt;= 0<span class="keyword">)</span> <span class="keyword">begin</span>
      vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> + vec2<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">;</span> i := i - 1 <span class="keyword">;</span>
    <span class="keyword">end</span> <span class="comment">// end of [while]
</span><span class="keyword">end</span> <span class="comment">// end of [intvec_add_by]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX: [vec1 := vec1 - vec2]
</span><span class="comment">//
</span><span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="16685"><span class="dyncstdec">intvec_sub_by <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec1<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> vec2<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intvec_sub_by]
</span>
<span class="keyword">implement</span>
intvec_sub_by <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec1<span class="keyword">,</span> vec2<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> i <span class="keyword">=</span> n - 1
<span class="keyword">in</span>
  <span class="keyword">while*</span> <span class="comment">// going downward
</span>    <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">~1 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">i+1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>i &gt;= 0<span class="keyword">)</span> <span class="keyword">begin</span>
      vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> - vec2<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">;</span> i := i - 1 <span class="keyword">;</span>
    <span class="keyword">end</span> <span class="comment">// end of [while]
</span><span class="keyword">end</span> <span class="comment">// end of [intvec_sub_by]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX: [vec1 := vec1 + c * vec2]
</span><span class="comment">//
</span><span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="17138"><span class="dyncstdec">intvec_add_by_scale <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec1<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> vec2<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">i0nt</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intvec_add_by_scale]
</span>
<span class="keyword">implement</span> intvec_add_by_scale <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vec1<span class="keyword">,</span> vec2<span class="keyword">,</span> n<span class="keyword">,</span> c<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">if</span> c <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// do nothing
</span>  <span class="keyword">else</span> <span class="keyword">if</span> c <span class="keyword">=</span> 1 <span class="keyword">then</span> <span class="keyword">begin</span>
    intvec_add_by <span class="keyword">(</span>vec1<span class="keyword">,</span> vec2<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">var</span> i <span class="keyword">=</span> n - 1<span class="keyword">;</span> <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">while*</span> <span class="comment">// going downward
</span>      <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">~1 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">i+1</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>i &gt;= 0<span class="keyword">)</span> <span class="keyword">begin</span>
        vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> := vec1<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> + c * vec2<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">;</span> i := i - 1 <span class="keyword">;</span>
      <span class="keyword">end</span> <span class="comment">// end of [while]
</span>  <span class="keyword">in</span>
    <span class="comment">// empty
</span>  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [intvec_add_by_scale]
</span>  
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="17751"><span class="dyncstdec">intvec_combine_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 <span class="keyword">&lt;</span> i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>_pos<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> _neg<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span> <span class="keyword">(</span>free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l <span class="keyword">|</span> ptr l<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intvec_combine_at]
</span>
<span class="keyword">implement</span>
intvec_combine_at <span class="keyword">(</span>vec_pos<span class="keyword">,</span> vec_neg<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> c_pos <span class="keyword">=</span> vec_pos<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> c_neg <span class="keyword">=</span> <span class="keyword">~</span><span class="keyword">(</span>vec_neg<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> intvec_copy_and_scale <span class="keyword">(</span>vec_neg<span class="keyword">,</span> n<span class="keyword">,</span> c_pos<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_add_by_scale <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> vec_pos<span class="keyword">,</span> n<span class="keyword">,</span> c_neg<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">@(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_combine_at]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">//
</span><span class="comment">// HX: [~1] is returned if contradiction is reached; otherwise, [0] is returned
</span><span class="comment">//
</span><span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="18362"><span class="dyncstdec">intveclst_split_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 <span class="keyword">&lt;</span> i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intveclst_split_at]
</span>
<span class="keyword">implement</span>
intveclst_split_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">}</span></span> <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span><span class="keyword">stadef</span> <span class="staexp"><a name="18563"><span class="stacstdec">ivs <span class="keyword">=</span> intveclst</span></a></span>
<span class="comment">//
</span><span class="keyword">fun</span> auxbeg <span class="comment">// split [vecs] into three groups
</span>  <span class="keyword">(</span>poss<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> neus<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> negs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> vecs<span class="keyword">:</span> <span class="staexp">ivs n</span><span class="keyword">)</span>
  <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> fst <span class="keyword">=</span> vecs
<span class="keyword">in</span>
  <span class="keyword">case+</span> fst <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp"><span class="keyword">!</span>pf_gc</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span><span class="keyword">;</span> <span class="keyword">val</span> vi <span class="keyword">=</span> p<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">;</span> <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
      <span class="keyword">val</span> vecs <span class="keyword">=</span> <span class="keyword">!</span>nxt
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
        <span class="keyword">if</span> vi <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
          <span class="keyword">!</span>nxt := poss<span class="keyword">;</span> poss := fst<span class="keyword">;</span> fold@ poss
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> vi <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span>
          <span class="keyword">!</span>nxt := negs<span class="keyword">;</span> negs := fst<span class="keyword">;</span> fold@ negs
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          <span class="keyword">!</span>nxt := neus<span class="keyword">;</span> neus := fst<span class="keyword">;</span> fold@ neus
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">in</span>
      auxbeg <span class="keyword">(</span>poss<span class="keyword">,</span> neus<span class="keyword">,</span> negs<span class="keyword">,</span> vecs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [INTVECLSTcons]
</span>  <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [auxbeg]
</span><span class="comment">//
</span><span class="keyword">fun</span> auxcomb <span class="comment">// [~1] is returned if contradiction is reached
</span>  <span class="keyword">(</span>neus<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> neg<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> poss<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> poss <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>poss_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
      <span class="keyword">val</span> <span class="keyword">@(</span><span class="prfexp">pf_new_gc</span><span class="keyword">,</span> <span class="prfexp">pf_new_arr</span> <span class="keyword">|</span> p_new<span class="keyword">)</span> <span class="keyword">=</span> intvec_combine_at <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> neg<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span>
      <span class="keyword">val</span> sgn <span class="keyword">=</span> intvec_inspect_gte <span class="keyword">(</span><span class="keyword">!</span>p_new<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
        <span class="keyword">if</span> sgn &lt;&gt; 0 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// tautology or contradiction
</span>          intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_new_gc</span><span class="keyword">,</span> <span class="prfexp">pf_new_arr</span> <span class="keyword">|</span> p_new<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
          neus := INTVECLSTcons <span class="keyword">(</span><span class="prfexp">pf_new_gc</span><span class="keyword">,</span> <span class="prfexp">pf_new_arr</span> <span class="keyword">|</span> p_new<span class="keyword">,</span> neus<span class="keyword">)</span>
        <span class="keyword">end</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> <span class="keyword">(</span>sgn &gt;= 0<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
        <span class="keyword">let</span> <span class="keyword">val</span> ans <span class="keyword">=</span> auxcomb <span class="keyword">(</span>neus<span class="keyword">,</span> neg<span class="keyword">,</span> <span class="keyword">!</span>poss_nxt<span class="keyword">)</span> <span class="keyword">in</span> fold@ poss<span class="keyword">;</span> ans <span class="keyword">end</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        fold@ <span class="keyword">(</span>poss<span class="keyword">)</span><span class="keyword">;</span> ~1
      <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">// end of [INTVECLSTcons]
</span>  <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ <span class="keyword">(</span>poss<span class="keyword">)</span><span class="keyword">;</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [auxcomb]
</span><span class="comment">//
</span><span class="comment">// HX: [~1] is returned if contradiction is reached
</span><span class="comment">//
</span><span class="keyword">fun</span> auxcomblst
  <span class="keyword">(</span>neus<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> poss<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>ivs n</span><span class="keyword">,</span> negs<span class="keyword">:</span> <span class="staexp">ivs n</span><span class="keyword">)</span>
  <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> negs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLSTcons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> negs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> ans <span class="keyword">=</span> auxcomb <span class="keyword">(</span>neus<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> poss<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> ans &gt;= 0 <span class="keyword">then</span> <span class="keyword">begin</span>
        auxcomblst <span class="keyword">(</span>neus<span class="keyword">,</span> poss<span class="keyword">,</span> negs_nxt<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
        intveclst_free <span class="keyword">(</span>negs_nxt<span class="keyword">)</span><span class="keyword">;</span> ans
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="keyword">end</span> <span class="comment">// end of [auxcomblst]
</span><span class="comment">//
</span><span class="keyword">var</span> poss<span class="keyword">:</span> <span class="staexp">ivs n</span> <span class="keyword">=</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">and</span> neus<span class="keyword">:</span> <span class="staexp">ivs n</span> <span class="keyword">=</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">and</span> negs<span class="keyword">:</span> <span class="staexp">ivs n</span> <span class="keyword">=</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> auxbeg <span class="keyword">(</span>poss<span class="keyword">,</span> neus<span class="keyword">,</span> negs<span class="keyword">,</span> vecs<span class="keyword">)</span>
<span class="keyword">val</span> ans <span class="keyword">=</span> auxcomblst <span class="keyword">(</span>neus<span class="keyword">,</span> poss<span class="keyword">,</span> negs<span class="keyword">)</span>
<span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intveclst_free poss
<span class="comment">//
</span><span class="keyword">in</span>
  vecs := neus<span class="keyword">;</span> ans
<span class="keyword">end</span> <span class="comment">// end of [intveclst_split_at]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="21029"><span class="dyncstdec">intveclst_solve
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp">intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span></span></a>
<span class="comment">// end of [intveclst_solve]
</span>
<span class="keyword">implement</span>
intveclst_solve <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux_solve
    <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> vecs <span class="keyword">of</span>
    <span class="keyword">|</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp">_</span><span class="comment">(*pf_gc*)</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>vecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
        <span class="keyword">val</span> i <span class="comment">(* 0 &lt; i &lt; n *)</span> <span class="keyword">=</span> intvec_absmin_coeff_index_get <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>pf_arr := pf<span class="keyword">;</span> fold@ vecs<span class="keyword">)</span></span>
        <span class="keyword">val</span> ans <span class="keyword">=</span> intveclst_split_at <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> ans &gt;= 0 <span class="keyword">then</span> aux_solve <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">else</span> ~1
      <span class="keyword">end</span>
    <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ vecs<span class="keyword">;</span> 0<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux_solve]
</span><span class="comment">(*
  val () = begin
    print "intveclst_solve: vecs =\n"; print_intveclst (vecs, n); print_newline ();
  end // end of [val]
*)</span>
  <span class="keyword">var</span> vecs<span class="keyword">:</span> <span class="staexp">intveclst n</span> <span class="keyword">=</span> vecs
  <span class="keyword">val</span> ans <span class="keyword">=</span> aux_solve <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intveclst_free vecs
<span class="keyword">in</span>
  ans
<span class="keyword">end</span> <span class="comment">// end of [intveclst_solve]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="21965"><span class="dyncstdec">intvec_elim_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 <span class="keyword">&lt;</span> i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> vec_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intvec_elim_at]
</span>
<span class="keyword">implement</span>
intvec_elim_at <span class="keyword">(</span>vec<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> vi <span class="keyword">=</span> vec<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span> <span class="keyword">and</span> vi_eq <span class="keyword">=</span> vec_eq<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> vi <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    <span class="keyword">if</span> vi_eq &gt;= 0 <span class="keyword">then</span> <span class="keyword">begin</span>
      intvec_scale <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> vi_eq<span class="keyword">)</span><span class="keyword">;</span> intvec_add_by_scale <span class="keyword">(</span>vec<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">~</span>vi<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      intvec_scale <span class="keyword">(</span>vec<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">~</span>vi_eq<span class="keyword">)</span><span class="keyword">;</span> intvec_add_by_scale <span class="keyword">(</span>vec<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> vi<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_elim_at]
</span>
<span class="keyword">extern</span>
<span class="keyword">fun</span> <a name="22485"><span class="dyncstdec">intveclst_elim_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 <span class="keyword">&lt;</span> i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst n</span><span class="keyword">,</span> vec_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intveclst_elim_at]
</span>
<span class="keyword">implement</span>
intveclst_elim_at <span class="keyword">(</span>vecs<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> vecs <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> p<span class="keyword">,</span> <span class="keyword">!</span>vecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elim_at <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intveclst_elim_at <span class="keyword">(</span><span class="keyword">!</span>vecs_nxt<span class="keyword">,</span> vec_eq<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ vecs
    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fold@ vecs
<span class="keyword">end</span> <span class="comment">// end of [intveclst_elim_at]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataviewtype</span> <span class="staexp"><a name="23052"><span class="stacstdec">intveclst1 <span class="keyword">(</span>int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>pos</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">}</span> INTVECLST1cons <span class="staexp"><span class="keyword">(</span>n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>
      free_gc_v <span class="keyword">(</span>i0nt<span class="keyword">,</span> n<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">,</span> intvec n @ l
    <span class="keyword">|</span> int<span class="comment">(*stamp*)</span><span class="keyword">,</span> ptr l<span class="keyword">,</span> intBtw <span class="keyword">(</span>0<span class="keyword">,</span> n<span class="keyword">)</span> <span class="comment">(*0:gte/1+:eq*)</span><span class="keyword">,</span> intveclst1 n
    <span class="keyword">)</span></span> <span class="comment">// end of [INTVECLST1cons]
</span>  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>pos</span><span class="keyword">}</span> INTVECLST1mark <span class="staexp"><span class="keyword">(</span>n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">intveclst1 n</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>pos</span><span class="keyword">}</span> INTVECLST1nil <span class="staexp"><span class="keyword">(</span>n<span class="keyword">)</span></span>

<span class="keyword">fun</span> intveclst1_free <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>v1ecs<span class="keyword">:</span> <span class="staexp">intveclst1 n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> v1ecs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1cons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> _<span class="keyword">,</span> p<span class="keyword">,</span> _<span class="keyword">,</span> v1ecs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span><span class="keyword">;</span> intveclst1_free <span class="keyword">(</span>v1ecs<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1mark <span class="keyword">(</span>v1ecs<span class="keyword">)</span> <span class="keyword">=&gt;</span> intveclst1_free v1ecs
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intveclst_free]
</span>
<span class="keyword">fun</span> intveclst1_backtrack <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>v1ecs<span class="keyword">:</span> <span class="staexp">intveclst1 n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intveclst1 n</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v1ecs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1cons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> _<span class="keyword">,</span> p<span class="keyword">,</span> _<span class="keyword">,</span> v1ecs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span><span class="keyword">;</span> intveclst1_backtrack v1ecs
    <span class="keyword">end</span>
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1mark <span class="keyword">(</span>v1ecs<span class="keyword">)</span> <span class="keyword">=&gt;</span> v1ecs
  <span class="keyword">|</span> <span class="keyword">~</span>INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intveclst1_backtrack]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span> fprint_intveclst1 <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf_mod<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span> w<span class="keyword">)</span></span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span>
  <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v1ecs <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLST1cons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span>  <span class="keyword">|</span> stamp<span class="keyword">,</span> p<span class="keyword">,</span> i<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprintf1_exn <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> "(%i;%i): "<span class="keyword">,</span> <span class="keyword">@(</span>stamp<span class="keyword">,</span>i<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intvec <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>pf_arr := pf<span class="keyword">)</span></span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intveclst1 <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ <span class="keyword">(</span>v1ecs<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLST1mark <span class="keyword">(</span><span class="keyword">!</span>v1ecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_intveclst1 <span class="keyword">(</span><span class="prfexp">pf_mod</span> <span class="keyword">|</span> out<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ <span class="keyword">(</span>v1ecs<span class="keyword">)</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ v1ecs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_intveclst1]
</span>
<span class="keyword">fun</span> print_intveclst1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> ptr_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  fprint_intveclst1 <span class="keyword">(</span><span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>ptr_stdout<span class="keyword">,</span> v1ecs<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span>
  stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [print_intveclst1]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="25094"><span class="dyncstdec">intvec_elimlst_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>stamp<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> vec<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intvec n</span><span class="keyword">,</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>
<span class="comment">// end of [intvec_elimlst_at]
</span>
<span class="keyword">implement</span>
intvec_elimlst_at <span class="keyword">(</span>stamp0<span class="keyword">,</span> vec<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> v1ecs_eq <span class="keyword">of</span>
  <span class="keyword">|</span> INTVECLST1cons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> stamp<span class="keyword">,</span> p<span class="keyword">,</span> i<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_eq_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> stamp0 &lt;= stamp <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="comment">// Note: elimination must be done in the reverse order!
</span>        <span class="comment">// It was done incorrectly and a bug occurred.
</span>        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>stamp0<span class="keyword">,</span> vec<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_eq_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assert <span class="keyword">(</span>i <span class="keyword">&gt;</span> 0<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elim_at <span class="keyword">(</span>vec<span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">,</span> i<span class="keyword">)</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
      <span class="keyword">in</span>
        fold@ v1ecs_eq
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>stamp0<span class="keyword">,</span> vec<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_eq_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
      <span class="keyword">in</span>
        fold@ v1ecs_eq
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLST1mark <span class="keyword">(</span><span class="keyword">!</span>v1ecs_eq_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>stamp0<span class="keyword">,</span> vec<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_eq_nxt<span class="keyword">,</span> n<span class="keyword">)</span>
    <span class="keyword">in</span>
      fold@ v1ecs_eq
    <span class="keyword">end</span>
  <span class="keyword">|</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ v1ecs_eq<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [intvec_elimlst_at]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span> <a name="26155"><span class="dyncstdec">intveclst_make <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span><span class="keyword">,</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intveclst n</span></span></a>
<span class="comment">// end of [intveclst_make]
</span>
<span class="keyword">implement</span>
intveclst_make <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop <span class="keyword">(</span>
      v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span>
    <span class="keyword">,</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>intveclst1 n</span>
    <span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
    <span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span>intveclst n?<span class="keyword">)</span> &gt;&gt; intveclst n</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> v1ecs <span class="keyword">of</span>
    <span class="keyword">|</span> INTVECLST1cons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp"><span class="keyword">!</span>pf_arr</span> <span class="keyword">|</span> stamp<span class="keyword">,</span> p<span class="keyword">,</span> _<span class="keyword">,</span> <span class="keyword">!</span>v1ecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> <span class="keyword">!</span>pf_arr</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_new_gc</span><span class="keyword">,</span> <span class="prfexp">pf_new_arr</span> <span class="keyword">|</span> p_new<span class="keyword">)</span> <span class="keyword">=</span> intvec_copy <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>pf_arr := pf</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>stamp<span class="keyword">,</span> <span class="keyword">!</span>p_new<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := INTVECLSTcons <span class="keyword">(</span><span class="prfexp">pf_new_gc</span><span class="keyword">,</span> <span class="prfexp">pf_new_arr</span> <span class="keyword">|</span> p_new<span class="keyword">,</span> ?<span class="keyword">)</span>
        <span class="keyword">val+</span> INTVECLSTcons <span class="keyword">(</span><span class="prfexp">_</span><span class="keyword">,</span> <span class="prfexp">_</span> <span class="keyword">|</span> _<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span> <span class="keyword">=</span> res
      <span class="keyword">in</span>
        loop <span class="keyword">(</span><span class="keyword">!</span>v1ecs_nxt<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>res_nxt<span class="keyword">)</span><span class="keyword">;</span> fold@ v1ecs<span class="keyword">;</span> fold@ res
      <span class="keyword">end</span> <span class="comment">// end of [INTVECLST1mark]
</span>    <span class="keyword">|</span> INTVECLST1mark <span class="keyword">(</span><span class="keyword">!</span>v1ecs_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        loop <span class="keyword">(</span><span class="keyword">!</span>v1ecs_nxt<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">;</span> fold@ v1ecs
      <span class="keyword">end</span>
    <span class="keyword">|</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        res := INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> fold@ v1ecs
      <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [loop]
</span>  <span class="keyword">var</span> vecs<span class="keyword">:</span> <span class="staexp">intveclst n</span> <span class="comment">// uninitialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> vecs<span class="keyword">)</span>
<span class="keyword">in</span>
  vecs
<span class="keyword">end</span> <span class="comment">// end of [intveclst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
icstrlst_solve <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>ics<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span><span class="keyword">fun</span> aux_main <span class="staexp"><span class="keyword">{</span>s<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    stamp<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst1 n</span>
  <span class="keyword">,</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst1 n</span>
  <span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
  <span class="keyword">,</span> ics<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>icstrlst <span class="keyword">(</span>n<span class="keyword">,</span> s<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ics <span class="keyword">of</span>
  <span class="keyword">|</span> list_vt_cons <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">!</span>ic <span class="keyword">of</span>
    <span class="keyword">|</span> ICvec <span class="keyword">(</span>knd<span class="keyword">,</span> <span class="keyword">!</span>ivp<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> knd <span class="keyword">of</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> knd <span class="keyword">=</span> 2<span class="comment">(*gte*)</span> orelse knd<span class="comment">(*lt*)</span> <span class="keyword">=</span> ~2 <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">@(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> intvecptr_copy <span class="keyword">(</span><span class="keyword">!</span>ivp<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
            <span class="keyword">if</span> knd <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// knd = ~2(*lt*)
</span>              intvec_negate <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">;</span> p<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := pred <span class="keyword">(</span>p<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span><span class="keyword">)</span>
            <span class="keyword">end</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>0<span class="comment">(*stamp*)</span><span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> sgn <span class="keyword">=</span> intvec_inspect_gte <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// tautology
</span>            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
            <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
          <span class="keyword">in</span>
            fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// contradiction
</span>            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
          <span class="keyword">in</span>
            fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ~1<span class="comment">(*solved*)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs :=
              INTVECLST1cons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> stamp<span class="keyword">,</span> p<span class="keyword">,</span> 0<span class="comment">(*dummy*)</span><span class="keyword">,</span> v1ecs<span class="keyword">)</span>
            <span class="keyword">var</span> vecs <span class="keyword">=</span> intveclst_make <span class="keyword">(</span>v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span>
            <span class="keyword">val</span> ans1 <span class="keyword">=</span> intveclst_inspect_gte <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span>
            <span class="keyword">val</span> ans<span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span>
              <span class="keyword">if</span> ans1 &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
                <span class="keyword">val</span> ans2 <span class="keyword">=</span> intveclst_solve <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span>
              <span class="keyword">in</span>
                <span class="keyword">if</span> ans2 &gt;= 0 <span class="keyword">then</span>
                  aux_main <span class="keyword">(</span>stamp+1<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
                <span class="keyword">else</span> ~1
              <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
                <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intveclst_free <span class="keyword">(</span>vecs<span class="keyword">)</span>
              <span class="keyword">in</span>
                ~1 <span class="comment">// a contradiction is reached!
</span>              <span class="keyword">end</span>
          <span class="keyword">in</span>
            fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans
          <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">// end of [2(*gte*) and ~2(*lt*)]
</span>      <span class="keyword">|</span> _ <span class="keyword">when</span> knd <span class="keyword">=</span> 1<span class="comment">(*eq*)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> intvecptr_copy <span class="keyword">(</span><span class="keyword">!</span>ivp<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_elimlst_at <span class="keyword">(</span>0<span class="comment">(*stamp*)</span><span class="keyword">,</span> <span class="keyword">!</span>p<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> sgn <span class="keyword">=</span> intvec_inspect_eq <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// tautology
</span>            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
            <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
          <span class="keyword">in</span>
            fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans           
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// contradiction
</span>            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
          <span class="keyword">in</span>
            fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ~1<span class="comment">(*solved*)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
            <span class="keyword">val</span> i <span class="keyword">=</span> intvec_absmin_coeff_index_get <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
            <span class="keyword">var</span> vi<span class="keyword">:</span> <span class="staexp">i0nt</span> <span class="keyword">=</span> p<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">;</span> <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> vi <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> vi := <span class="keyword">~</span>vi
            <span class="keyword">var</span> ans<span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> 0
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> vi <span class="keyword">&gt;</span> 1 <span class="keyword">then</span> ans := intvec_normalize_eq <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">,</span> n<span class="keyword">)</span>
            <span class="keyword">var</span> vecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>intveclst n<span class="keyword">)</span>?</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
              <span class="keyword">if</span> <span class="keyword">:</span><span class="keyword">(</span>vecs<span class="keyword">:</span> intveclst n<span class="keyword">)</span> <span class="keyword">=&gt;</span> ans &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
                <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs_eq :=
                  INTVECLST1cons <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> stamp<span class="keyword">,</span> p<span class="keyword">,</span> i<span class="keyword">,</span> v1ecs_eq<span class="keyword">)</span>
                <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>vecs := intveclst_make <span class="keyword">(</span>v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span>
              <span class="keyword">in</span>
                ans := intveclst_inspect_gte <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span>
              <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
                <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> vecs := INTVECLSTnil <span class="keyword">(</span><span class="keyword">)</span>
              <span class="keyword">in</span>
                intvec_ptr_free <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p<span class="keyword">)</span>
              <span class="keyword">end</span>
          <span class="keyword">in</span>
            <span class="keyword">if</span> ans &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
              <span class="keyword">val</span> ans1 <span class="keyword">=</span> intveclst_solve <span class="keyword">(</span>vecs<span class="keyword">,</span> n<span class="keyword">)</span>
              <span class="keyword">val</span> ans2<span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span>
                <span class="keyword">if</span> ans1 &gt;= 0 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// continue
</span>                  aux_main <span class="keyword">(</span>stamp+1<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
                  ~1 <span class="comment">// constradiction has been reached
</span>                <span class="keyword">end</span>
            <span class="keyword">in</span>
              fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans2
            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
              <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intveclst_free vecs
            <span class="keyword">in</span>
              fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ~1<span class="comment">(*solved*)</span>
            <span class="keyword">end</span> <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="comment">// end of [1(*eq*)]
</span>      <span class="keyword">|</span> _ <span class="comment">(* knd = ~1(*neq*) *)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">@(</span><span class="prfexp">pf1_gc</span><span class="keyword">,</span> <span class="prfexp">pf1_arr</span> <span class="keyword">|</span> p1<span class="keyword">)</span> <span class="keyword">=</span> intvecptr_copy <span class="keyword">(</span><span class="keyword">!</span>ivp<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p1<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := pred <span class="keyword">(</span>p1<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span><span class="keyword">)</span>
          <span class="keyword">val</span> ivp1 <span class="keyword">=</span> intvecptr_make_view_ptr <span class="keyword">(</span><span class="prfexp">pf1_gc</span><span class="keyword">,</span> <span class="prfexp">pf1_arr</span> <span class="keyword">|</span> p1<span class="keyword">)</span>
          <span class="keyword">val</span> ic1 <span class="keyword">=</span> ICvec <span class="keyword">(</span>2<span class="comment">(*gte*)</span><span class="keyword">,</span> ivp1<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">@(</span><span class="prfexp">pf2_gc</span><span class="keyword">,</span> <span class="prfexp">pf2_arr</span> <span class="keyword">|</span> p2<span class="keyword">)</span> <span class="keyword">=</span> intvecptr_copy <span class="keyword">(</span><span class="keyword">!</span>ivp<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> intvec_negate <span class="keyword">(</span><span class="keyword">!</span>p2<span class="keyword">,</span> n<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p2<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := pred <span class="keyword">(</span>p2<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span><span class="keyword">)</span>
          <span class="keyword">val</span> ivp2 <span class="keyword">=</span> intvecptr_make_view_ptr <span class="keyword">(</span><span class="prfexp">pf2_gc</span><span class="keyword">,</span> <span class="prfexp">pf2_arr</span> <span class="keyword">|</span> p2<span class="keyword">)</span>
          <span class="keyword">val</span> ic2 <span class="keyword">=</span> ICvec <span class="keyword">(</span>2<span class="comment">(*gte*)</span><span class="keyword">,</span> ivp2<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
            intvecptr_free <span class="keyword">(</span><span class="keyword">!</span>ivp<span class="keyword">)</span><span class="keyword">;</span> free@ <span class="keyword">{</span>n<span class="keyword">}</span> <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span>
          <span class="keyword">end</span>
          <span class="keyword">val</span> ics1<span class="keyword">:</span> <span class="staexp">icstrlst n</span> <span class="keyword">=</span>
            list_vt_cons <span class="keyword">(</span>ic1<span class="keyword">,</span> list_vt_cons <span class="keyword">(</span>ic2<span class="keyword">,</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span>
          <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main_disj <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">,</span> ics1<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">!</span>ic := ICveclst <span class="keyword">(</span>1<span class="comment">(*disj*)</span><span class="keyword">,</span> ics1<span class="keyword">)</span><span class="keyword">;</span> fold@ ics<span class="keyword">;</span> ans
        <span class="keyword">end</span> <span class="comment">// end of [neq]
</span>      <span class="keyword">end</span> <span class="comment">// end of [ICvec]
</span>    <span class="keyword">|</span> ICveclst <span class="keyword">(</span>knd<span class="comment">(*conj:0/disj:1*)</span><span class="keyword">,</span> <span class="keyword">!</span>ics1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="keyword">if</span> knd <span class="keyword">=</span> 0 <span class="keyword">then</span> <span class="keyword">let</span> <span class="comment">// conjunction
</span>          <span class="keyword">val</span> s1 <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_vt_length__boxed <span class="keyword">(</span><span class="keyword">!</span>ics1<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>ics_nxt := $Lst<span class="keyword">.</span>list_vt_append <span class="keyword">(</span><span class="keyword">!</span>ics1<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
          <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>ics1 := $Lst<span class="keyword">.</span>list_vt_prefix <span class="keyword">(</span><span class="keyword">!</span>ics_nxt<span class="keyword">,</span> s1<span class="keyword">)</span>
        <span class="keyword">in</span>
          fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans
        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main_disj <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">!</span>ics_nxt<span class="keyword">,</span> <span class="keyword">!</span>ics1<span class="keyword">)</span>
        <span class="keyword">in</span>
          fold@ <span class="keyword">(</span><span class="keyword">!</span>ic<span class="keyword">)</span><span class="keyword">;</span> fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> ans
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [ICveclst]
</span>    <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>  <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fold@ <span class="keyword">(</span>ics<span class="keyword">)</span><span class="keyword">;</span> 0<span class="comment">(*unsolved*)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_nil]
</span><span class="keyword">end</span> <span class="comment">// end of [aux_main]
</span><span class="comment">//
</span><span class="keyword">and</span> aux_main_disj <span class="staexp"><span class="keyword">{</span>s<span class="keyword">,</span>s1<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    stamp<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> v1ecs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst1 n</span>
  <span class="keyword">,</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>intveclst1 n</span>
  <span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span>
  <span class="keyword">,</span>ics<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>icstrlst <span class="keyword">(</span>n<span class="keyword">,</span> s<span class="keyword">)</span></span>
  <span class="keyword">,</span> ics1<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>icstrlst <span class="keyword">(</span>n<span class="keyword">,</span> s1<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intBtw <span class="keyword">(</span>~1<span class="keyword">,</span> 1<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> ics1 <span class="keyword">of</span>
  <span class="keyword">|</span> list_vt_cons <span class="keyword">(</span><span class="keyword">!</span>ic1<span class="keyword">,</span> <span class="keyword">!</span>ics1_nxt<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs_eq := INTVECLST1mark v1ecs_eq
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs := INTVECLST1mark v1ecs
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ics := list_vt_cons <span class="keyword">(</span><span class="keyword">!</span>ic1<span class="keyword">,</span> ics<span class="keyword">)</span>
      <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> ics<span class="keyword">)</span>
      <span class="keyword">val+</span> <span class="keyword">~</span>list_vt_cons <span class="keyword">(</span>ic1_v<span class="keyword">,</span> ics_v<span class="keyword">)</span> <span class="keyword">=</span> ics
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>ic1 := ic1_v<span class="keyword">;</span> ics := ics_v<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs_eq := intveclst1_backtrack v1ecs_eq
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> v1ecs := intveclst1_backtrack v1ecs
    <span class="keyword">in</span>
      <span class="keyword">if</span> ans &gt;= 0 <span class="keyword">then</span> <span class="keyword">begin</span>
        fold@ ics1<span class="keyword">;</span> 0 <span class="comment">(*unsolved*)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// solved and continue
</span>        <span class="keyword">val</span> ans <span class="keyword">=</span> aux_main_disj <span class="keyword">(</span>stamp<span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> ics<span class="keyword">,</span> <span class="keyword">!</span>ics1_nxt<span class="keyword">)</span>
      <span class="keyword">in</span>
        fold@ ics1<span class="keyword">;</span> ans <span class="comment">(*unsolved*)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]
</span>  <span class="keyword">|</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ ics1<span class="keyword">;</span> ~1<span class="comment">(*solved*)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end [aux_main_disj]
</span><span class="comment">//
</span><span class="keyword">var</span> v1ecs_eq<span class="keyword">:</span> <span class="staexp">intveclst1 n</span> <span class="keyword">=</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">var</span> v1ecs<span class="keyword">:</span> <span class="staexp">intveclst1 n</span> <span class="keyword">=</span> INTVECLST1nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">val</span> ans <span class="keyword">=</span> aux_main <span class="keyword">(</span>0<span class="comment">(*stamp*)</span><span class="keyword">,</span> v1ecs<span class="keyword">,</span> v1ecs_eq<span class="keyword">,</span> n<span class="keyword">,</span> ics<span class="keyword">)</span>
<span class="comment">//
</span><span class="keyword">in</span>
  intveclst1_free v1ecs_eq<span class="keyword">;</span> intveclst1_free v1ecs<span class="keyword">;</span> ans
<span class="keyword">end</span> <span class="comment">// end of [icstrlst_solve]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_solver_fm.dats] *)</span>
</pre>
</body>
</html>
