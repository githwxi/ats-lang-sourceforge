
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ATSLIB/libats/ML/list0</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/libats/ML/list0</h1>


The functions declared in this package are primarily for supporting
ML-style processing of list-values. The programmer is encouraged to use the
dependent datatype <span class="patsyntaxstaexp">list</span> instead of <span class="patsyntaxstaexp">list0</span> after
gaining familiarity with dependent types.  

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#list0">list0</a></li>
<li><a href="#list0_of_list">list0_of_list</a></li>
<li><a href="#list0_of_list_vt">list0_of_list_vt</a></li>
<li><a href="#g0ofg1_list">g0ofg1_list</a></li>
<li><a href="#g1ofg0_list">g1ofg0_list</a></li>
<li><a href="#list0_make_sing">list0_make_sing</a></li>
<li><a href="#list0_make_pair">list0_make_pair</a></li>
<li><a href="#list0_make_elt">list0_make_elt</a></li>
<li><a href="#list0_make_intrange">list0_make_intrange</a></li>
<li><a href="#list0_make_intrange_lr">list0_make_intrange_lr</a></li>
<li><a href="#list0_make_intrange_lrd">list0_make_intrange_lrd</a></li>
<li><a href="#list0_make_arrpsz">list0_make_arrpsz</a></li>
<li><a href="#list0_is_nil">list0_is_nil</a></li>
<li><a href="#list0_is_cons">list0_is_cons</a></li>
<li><a href="#list0_is_empty">list0_is_empty</a></li>
<li><a href="#list0_isnot_empty">list0_isnot_empty</a></li>
<li><a href="#list0_head_exn">list0_head_exn</a></li>
<li><a href="#list0_head_opt">list0_head_opt</a></li>
<li><a href="#list0_tail_exn">list0_tail_exn</a></li>
<li><a href="#list0_tail_opt">list0_tail_opt</a></li>
<li><a href="#list0_last_exn">list0_last_exn</a></li>
<li><a href="#list0_last_opt">list0_last_opt</a></li>
<li><a href="#list0_nth_exn">list0_nth_exn</a></li>
<li><a href="#list0_nth_opt">list0_nth_opt</a></li>
<li><a href="#list0_get_at_exn">list0_get_at_exn</a></li>
<li><a href="#print_list0">print_list0</a></li>
<li><a href="#prerr_list0">prerr_list0</a></li>
<li><a href="#fprint_list0">fprint_list0</a></li>
<li><a href="#fprint_list0_sep">fprint_list0_sep</a></li>
<li><a href="#list0_insert_at_exn">list0_insert_at_exn</a></li>
<li><a href="#list0_remove_at_exn">list0_remove_at_exn</a></li>
<li><a href="#list0_takeout_at_exn">list0_takeout_at_exn</a></li>
<li><a href="#list0_length">list0_length</a></li>
<li><a href="#list0_append">list0_append</a></li>
<li><a href="#list0_extend">list0_extend</a></li>
<li><a href="#list0_snoc">list0_snoc</a></li>
<li><a href="#list0_reverse">list0_reverse</a></li>
<li><a href="#list0_reverse_append">list0_reverse_append</a></li>
<li><a href="#list0_concat">list0_concat</a></li>
<li><a href="#list0_take_exn">list0_take_exn</a></li>
<li><a href="#list0_drop_exn">list0_drop_exn</a></li>
<li><a href="#list0_tabulate">list0_tabulate</a></li>
<li><a href="#list0_tabulate_opt">list0_tabulate_opt</a></li>
<li><a href="#list0_app">list0_app</a></li>
<li><a href="#list0_foreach">list0_foreach</a></li>
<li><a href="#list0_iforeach">list0_iforeach</a></li>
<li><a href="#list0_foreach2">list0_foreach2</a></li>
<li><a href="#list0_foreach2_eq">list0_foreach2_eq</a></li>
<li><a href="#list0_foldleft">list0_foldleft</a></li>
<li><a href="#list0_ifoldleft">list0_ifoldleft</a></li>
<li><a href="#list0_foldleft2">list0_foldleft2</a></li>
<li><a href="#list0_foldright">list0_foldright</a></li>
<li><a href="#list0_exists">list0_exists</a></li>
<li><a href="#list0_exists2">list0_exists2</a></li>
<li><a href="#list0_forall">list0_forall</a></li>
<li><a href="#list0_forall2">list0_forall2</a></li>
<li><a href="#list0_forall2_eq">list0_forall2_eq</a></li>
<li><a href="#list0_equal">list0_equal</a></li>
<li><a href="#list0_find_exn">list0_find_exn</a></li>
<li><a href="#list0_find_opt">list0_find_opt</a></li>
<li><a href="#list0_filter">list0_filter</a></li>
<li><a href="#list0_map">list0_map</a></li>
<li><a href="#list0_mapopt">list0_mapopt</a></li>
<li><a href="#list0_imap">list0_imap</a></li>
<li><a href="#list0_map2">list0_map2</a></li>
<li><a href="#list0_zip">list0_zip</a></li>
<li><a href="#list0_zipwith">list0_zipwith</a></li>
<li><a href="#list0_quicksort">list0_quicksort</a></li>
<li><a href="#list0_mergesort">list0_mergesort</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#+">+</a></li>
<li><a href="#[]">[]</a></li>
<li><a href="#g0ofg1">g0ofg1</a></li>
<li><a href="#g1ofg0">g1ofg0</a></li>
<li><a href="#iseqz">iseqz</a></li>
<li><a href="#isneqz">isneqz</a></li>
<li><a href="#.head">.head</a></li>
<li><a href="#.tail">.tail</a></li>
<li><a href="#length">length</a></li>
<li><a href="#print">print</a></li>
<li><a href="#prerr">prerr</a></li>
<li><a href="#fprint">fprint</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="list0">list0</a></h2>
<h3>Synopsis</h3>

The full name of the list0-type constructor is
<span class="patsyntaxstaexp">list0_t0ype_type</span>, which is given to the datatype declared as
follows:

<pre class="patsyntax"><span class="dynexp"><span class="keyword">datatype</span> <span class="comment">// t@ype+: covariant</span>
list0_t0ype_type <span class="staexp"><span class="keyword">(</span>a<span class="keyword">:</span> <span class="keyword">t@ype+</span><span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list0_t0ype_type</span> <span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [list0_t0ype_type]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_of_list">list0_of_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list0_of_list<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function casts a list-value of indexed type to a list-value of
unindexed type.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_of_list_vt">list0_of_list_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list0_of_list_vt<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List_vt</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function casts a linear list-value of indexed type to a list-value of
unindexed type.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g0ofg1_list">g0ofg1_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
g0ofg1_list<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">g0ofg1</span>, casts a
list-value of indexed type to another list-value of unindexed type.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g1ofg0_list">g1ofg0_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
g1ofg0_list<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">List0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">g1ofg0</span>, casts a
list-value of unindexed type to another list-value of indexed type.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_sing">list0_make_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_make_sing <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function constructs a singleton list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_pair">list0_make_pair</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_make_pair <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given two elements x1 and x2, this function returns a list consisting of x1
and x2 as its first and second elements, respectively.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_elt">list0_make_elt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_make_elt <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given an integer n and an element x, this function returns a list
consisting of n occurrences of x if n is a natural number. Otherwise it
raises an exception (<span class="patsyntaxdynexp">IllegalArgExn</span>).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_intrange">list0_make_intrange</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> list0_make_intrange <span class="keyword">with</span> list0_make_intrange_lr</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> list0_make_intrange <span class="keyword">with</span> list0_make_intrange_lrd</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_intrange_lr">list0_make_intrange_lr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
list0_make_intrange_lr <span class="keyword">(</span>l<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given integers l and r, this function returns the list consisting of
integers l, l+1, ..., and r-1, inclusive if l <= r holds. Otherwise, it
returns the list l, l-1, ..., r+1, inclusive.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_intrange_lrd">list0_make_intrange_lrd</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
list0_make_intrange_lrd <span class="keyword">(</span>l<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> d<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given integers l, r and d, if l < r and d > 0, then this function returns
the list consisting of integers l, l+d, ..., l+n*d, where n is the largest
natural number satisfying l+n*d < r; if l > r and d < 0, this function
returns the list consisting of integers l, l-d, ..., l-n*d, where n is the
largest natural number satisfying l-n*d > r; if d = 0, then this function
raises an exception (<span class="patsyntaxdynexp">IllegalArgExn</span>); otherwise, this function
returns the empty list.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_make_arrpsz">list0_make_arrpsz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_make_arrpsz<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>psz<span class="keyword">:</span> <span class="staexp">arrpsz</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">list0</span>, is often
conveniently employed to build a list of some fixed length. <h3>Example</h3>

The following code builds a list of digits and then prints them out:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_0.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> <span class="keyword">(</span>list0<span class="keyword">)</span><span class="keyword">$arrpsz</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list0_foreach&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> print_int <span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_is_nil">list0_is_nil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_is_nil <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its list argument is empty.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_is_cons">list0_is_cons</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_is_cons <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its list argument is not empty.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_is_empty">list0_is_empty</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_is_empty <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
This function does the same as <span class="patsyntaxdynexp">list0_is_nil</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_isnot_empty">list0_isnot_empty</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_isnot_empty <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
This function does the same as <span class="patsyntaxdynexp">list0_is_cons</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_head_exn">list0_head_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_head_exn <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the head of a given list if the list is non-empty or
raises an exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>) if the list is empty.
It is O(1)-time.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_head_opt">list0_head_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_head_opt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">list0_head_exn</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_tail_exn">list0_tail_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_tail_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the tail of a given list if the list is non-empty.
Otherwise, it raises an exception (<span class="patsyntaxdynexp">ListSubscriptExn</span>).  The
function is O(1)-time.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_tail_opt">list0_tail_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_tail_opt
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">list0_tail_exn</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_last_exn">list0_last_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_last_exn <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the last element of a given list if the list is
non-empty. Otherwise, it raises an exception
(<span class="patsyntaxdynexp">ListSubscriptExn</span>).  The function is O(n)-time, where n is the
length of its argument.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_last_opt">list0_last_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_last_opt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">list0_last_exn</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_nth_exn">list0_nth_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_nth_exn <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns element i of a given list if i is a natural number
less than the length of the list.  Otherwise, it raises an exception
(<span class="patsyntaxdynexp">ListSubscriptExn</span>). The function is O(i)-time.
<h3>Example</h3>

The following code gives a <em>terribly inefficient</em> O(n^2)-time
implementation of list concatenation:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_1.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_append <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
    xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> i1 <span class="keyword">=</span> i - <span class="dynexp">1</span></span>
      <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> list0_cons <span class="keyword">(</span>list0_nth_exn <span class="keyword">(</span>xs<span class="keyword">,</span> i1<span class="keyword">)</span><span class="keyword">,</span> res<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      loop <span class="keyword">(</span>xs<span class="keyword">,</span> i1<span class="keyword">,</span> res<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> res</span> <span class="comment">// end of [if]</span>
  <span class="comment">// end of [loop]</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>xs<span class="keyword">,</span> list0_length <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_append]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_nth_opt">list0_nth_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_nth_opt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is the optional version of <span class="patsyntaxdynexp">list0_nth_exn</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_get_at_exn">list0_get_at_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_get_at_exn <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, does the same as
<span class="patsyntaxdynexp">list0_nth_exn</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="print_list0">print_list0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
print_list0 <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function prints a given list onto STDOUT.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="prerr_list0">prerr_list0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
prerr_list0 <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function prints a given list onto STDERR.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list0">fprint_list0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fprint_list0
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_list0]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list0_sep">fprint_list0_sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
fprint_list0_sep
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_list0_sep]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_insert_at_exn">list0_insert_at_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_insert_at_exn <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

Given a list xs of length n, an integer i and an element x, this function
builds a list xs1 by inserting x into xs at position i if i is between 0
and n, inclusive.  Otherwise, it raises an exception
(<span class="patsyntaxdynexp">IllegalArgExn</span>).  Clearly, if the function returns a list, then
element i in the returned list must be x.  The function is O(i)-time.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_remove_at_exn">list0_remove_at_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_remove_at_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, an integer i and an element x, this function
builds a list xs1 by removing element i in xs if i is between 0 and n-1,
inclusive.  Otherwise, it raises an exception (<span class="patsyntaxdynexp">IllegalArgExn</span>).
The function is O(i)-time.
<h3>Example</h3>

Let xs be a list of length n, i an integer between 0 and n-1, inclusive,
and xs1 the list obtained from removing element i in xs. The following code
checks that xs equals the list built by inserting xs[i] into xs1 at
position i:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_2.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> N 10</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> i <span class="keyword">=</span> N / <span class="dynexp">2</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list0_make_intrange <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> N<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> list0_insert_at_exn <span class="keyword">(</span>list0_remove_at_exn <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">,</span> <span class="dynexp">xs[i<span class="keyword">]</span></span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> iseq <span class="keyword">=</span> list0_equal <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> x <span class="keyword">=</span> y<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>iseq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*NormalExit*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_takeout_at_exn">list0_takeout_at_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_takeout_at_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is similar to <span class="patsyntaxdynexp">list0_remove_at_exn</span> except that it
also stores the removed element (in its third call-by-reference argument).

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_length">list0_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_length <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span></pre>
<h3>Description</h3>

This function returns the length of a given list, and its implementation is
tail-recursive. It is O(n)-time, where n is the length of the given list.
For convenience, <span class="patsyntaxdynexp">list0_length</span> overloads the symbol <span class="patsyntaxdynexp">length</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_append">list0_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_append
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given two lists xs and ys, this function returns the concatenation of xs
and ys. It is O(n)-time, where n is the length of xs.
For convenience, <span class="patsyntaxdynexp">list0_append</span> overloads the symbol
<span class="patsyntaxdynexp">+</span>.  Note that the implementation of <span class="patsyntaxdynexp">list0_append</span> is
tail-recursive in ATSLIB.
<h3>Example</h3>

The following code checks that the length of the concatenation of two lists
equals the sum of their individual lengths:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_3.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> M 10</span>
  <span class="neuexp"><span class="keyword">#define</span> N 20</span>
  <span class="neuexp"><span class="keyword">#define</span> length list0_length</span>
  <span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list0_make_elt&lt;<span class="staexp">char</span><span class="keyword">&gt;</span> <span class="keyword">(</span>M<span class="keyword">,</span> <span class="dynexp">'a'</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span> list0_make_elt&lt;<span class="staexp">char</span><span class="keyword">&gt;</span> <span class="keyword">(</span>N<span class="keyword">,</span> <span class="dynexp">'b'</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>length <span class="keyword">(</span>xs<span class="keyword">)</span> + length <span class="keyword">(</span>ys<span class="keyword">)</span> <span class="keyword">=</span> length <span class="keyword">(</span>xs + ys<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*NormalExit*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_extend">list0_extend</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_extend <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> y<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a lists xs and y, this function returns the concatenation of xs and
the singleton list consisting of y. It is O(n)-time, where n is the length
of xs.
<h3>Example</h3>

The following code gives a typical implementation of the list-reverse
function by a beginner of functional programming:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_4.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_reverse <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_extend <span class="keyword">(</span>list0_reverse <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">)</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [list0_reverse]</span>
</pre>

Note that this implementation is <em>terribly inefficient</em> both
time-wise and memory-wise: It is O(n^2)-time and non-tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_snoc">list0_snoc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">macdef</span> list0_snoc <span class="keyword">=</span> list0_extend</span></pre>
<h3>Example</h3>
This function does the same as <span class="patsyntaxdynexp">list0_extend</span>.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_reverse">list0_reverse</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_reverse <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns the reverse of a given list. It is O(n)-time,
where n is the length of the given list, and its implementation in ATSLIB
is tail-recurisive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_reverse_append">list0_reverse_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_reverse_append
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given two lists xs and ys, this function returns the concatenation of the
rxs and ys, where rxs refers to the reverse of xs. It is O(n)-time, where n
is the length of the given list, and its implementation in ATSLIB is
tail-recurisive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_concat">list0_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_concat <span class="keyword">(</span>xss<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xss of lists, this funciton returns the concatenation
of xss[0], xss[1], ..., and xss[n-1], where n is the length of xss.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_take_exn">list0_take_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_take_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs and an integer i, this function contructs another list
consisting of the first i elemements of xs. If i is negative, the function
raises the exception <span class="patsyntaxdynexp">IllegalArgExn</span>. If i exceeds the length of
xs, then the function raises the exception <span class="patsyntaxdynexp">ListSubscriptExn</span>.
The time-complexity of the function is O(i).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_drop_exn">list0_drop_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_drop_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs and an integer i, this function returns the suffix of xs
that is of length n-i, where n is the length of xs.  If i is negative, the
function raises the exception <span class="patsyntaxdynexp">IllegalArgExn</span>. If i exceeds the
length of xs, then the function raises the exception <span class="patsyntaxdynexp">ListSubscriptExn</span>.
The time-complexity of the function is O(i).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_tabulate">list0_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_tabulate <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given an integer n and a function f, this function returns a list
consisting of the elements f(0), f(1), ..., f(n-1) if n is a natural
number. Otherwise, it raises an exception (<span class="patsyntaxdynexp">IllegalArgExn</span>).  <h3>Example</h3>

The following code builds a list of digits and then prints them onto the
standard output channel:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_5.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list0_tabulate&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="dynexp">10</span><span class="keyword">,</span> <span class="keyword">lam</span> i <span class="keyword">=&gt;</span> i<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list0_sep&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>stdout_ref<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>


As a more elaborate example, the following code implements a function
<span class="patsyntaxdynexp">list0_permute</span> that returns a list consisting of all the
permutations of a given list:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_6.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_permute
<span class="keyword">(</span>
  xs0<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> n <span class="keyword">=</span> list0_length <span class="keyword">(</span>xs0<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs0 <span class="keyword">of</span>
<span class="keyword">|</span> list0_cons
    <span class="keyword">(</span>x0<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> yss <span class="keyword">=</span> list0_permute <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> f <span class="keyword">=</span> <span class="keyword">lam</span> <span class="keyword">(</span>ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span>
      list0_tabulate&lt;<span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>n<span class="keyword">,</span> <span class="keyword">lam</span> i <span class="keyword">=&gt;</span> list0_insert_at_exn <span class="keyword">(</span>ys<span class="keyword">,</span> i<span class="keyword">,</span> x0<span class="keyword">)</span><span class="keyword">)</span></span>
    <span class="comment">// end of [lam] // end of [val]</span>
  <span class="keyword">in</span>
    list0_concat <span class="keyword">(</span>list0_map <span class="keyword">(</span>yss<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list0_cons]</span>
<span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_sing <span class="keyword">(</span>list0_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_permute]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_tabulate_opt">list0_tabulate_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_tabulate_opt <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given an integer n and a function f, this function returns a list
that collects precisely every x whenever
<span class="patsyntaxdynexp">Some0(x)</span> is returned by f(i), where i ranges from 0 until
n-1, inclusive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_app">list0_app</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_app <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function is idential to <span class="patsyntaxdynexp">list0_foreach</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foreach">list0_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_foreach <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function applies its second argument to each element in its first
argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_iforeach">list0_iforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_iforeach <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span></span></pre>
<h3>Description</h3>

This function applies its second argument f to (i, x), where i ranges from
0 to the length of xs minus 1 and x is element i in xs.
<h3>Example</h3>

The following code implements a function for printing out a given list:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_7.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
fprint_list0_sep <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> sep<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">fun</span> f <span class="keyword">(</span>
    i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref1</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> sep<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    fprint_val&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> x<span class="keyword">)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [f]</span>
  <span class="dynexp"><span class="keyword">val</span> _<span class="comment">(*n*)</span> <span class="keyword">=</span> list0_iforeach <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [fprint_list0_sep]</span>
</pre>

Note that the argument sep of <span class="patsyntaxdynexp">fprint_list0_sep</span> is only printed
between list elements.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foreach2">list0_foreach2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_foreach2
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [list0_foreach2]</span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
applies its third argument to each pair (xs[i], ys[i]), where i ranges from
0 until min(m,n)-1, inclusive, and xs[i] (ys[i]) refers to element i in
the list xs (ys).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foreach2_eq">list0_foreach2_eq</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_foreach2_eq
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">,</span> sgn<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">int</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [list0_foreach2_eq]</span></pre>
<h3>Description</h3>

This function is largely similar to <span class="patsyntaxdynexp">list0_foreach2</span>.  After a
call to the function returns, the value stored in the call-by-reference
parameter sgn equals sgn(n1-n2), that is, the sign of n1-n2, where n1 and
n2 are the lengths of the first and second arguments of the function,
respectively.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foldleft">list0_foldleft</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_foldleft
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">res</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns the value f (...f (f
(ini, xs[0]), xs[1])..., xs[n-1]), where the notation xs[i] refers to
element i in the list xs. The implementation of this function is
tail-recursive.  <h3>Example</h3>

The following code gives a standard implementation of the list-reverse
function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_8.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_reverse <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>
  list0_foldleft&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> list0_nil<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">// end of [list0_reverse]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_ifoldleft">list0_ifoldleft</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_ifoldleft
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun3</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">res</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns the value f (...f (f
(ini, 0, xs[0]), 1, xs[1])..., n-1, xs[n-1]), where the notation xs[i]
refers to element i in the list xs. The implementation of this function is
tail-recursive.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foldleft2">list0_foldleft2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_foldleft2 <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> ini<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun3</span> <span class="keyword">(</span><span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">res</span></span> <span class="comment">// end of [list0_foldleft2]</span></pre>
<h3>Description</h3>

Given two lists xs1 and xs2 of length n1 and n2, respectively, this
function returns the value f (...f (ini, xs1[0], xs2[0])..., xs1[n-1],
xs2[n-1]), where n equals min(n1, n2).

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_foldright">list0_foldright</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>res<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_foldright
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">,</span> <span class="staexp">res</span><span class="keyword">)</span><span class="keyword">,</span> snk<span class="keyword">:</span> <span class="staexp">res</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">res</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function returns the value f (xs[0], f
(xs[1], ...f (xs[n-1], snk)...)), where the notation xs[i] refers to
element i in the list xs. The implementation of this function is
<em>not</em> tail-recursive, and stack-overflow may occur if the xs is long
(e.g., containing 1,000,000 elements).  <h3>Example</h3>

The following code gives a standard implementation of the list-append
function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_9.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_append <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>
  list0_foldright&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> res<span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">// end of [list0_append]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_exists">list0_exists</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_exists <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

This function returns true if and only if there exists an element in its
first argument that satisfies the predicated provided as its second
argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_exists2">list0_exists2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_exists2
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> pred<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// end of [list0_exists2]</span></pre>
<h3>Description</h3>

Given two lists xs1 and xs2 of length n1 and n2, respectively, this
function returns true if and only if p(xs1[i], xs2[i]) returns true for
some i between 0 and min(n1,n2)-1, inclusive.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_forall">list0_forall</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_forall <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>

This function returns true if and only if every element in its first
argument satisfies the predicated provided as its second argument.  <h3>Example</h3>

The following code tests whether the integers in a given list are
all even:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_10.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list0_of_list <span class="keyword">(</span><span class="keyword">$list</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> isevn <span class="keyword">=</span> list0_forall&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> x mod <span class="dynexp">2</span> <span class="keyword">=</span> <span class="dynexp">0</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>isevn<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main] </span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_forall2">list0_forall2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_forall2 <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> pred<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// end of [list0_forall2]</span></pre>
<h3>Description</h3>

Given two lists xs1 and xs2 of length n1 and n2, respectively, this
function returns true if and only if p(xs1[i], xs2[i]) returns true for
every i between 0 and min(n1,n2)-1, inclusive.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_forall2_eq">list0_forall2_eq</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_forall2_eq
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">,</span> sgn<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">int</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// end of [list0_forall2_eq]</span></pre>
<h3>Description</h3>

This function is largely similar to <span class="patsyntaxdynexp">list0_forall2</span>.  Given two
lists xs1 and xs2 of length n1 and n2, respectively, this function returns
true if and only if p(xs1[i], xs2[i]) returns true for every i between 0
and min(n1,n2)-1, inclusive. If this function returns true, then the
value stored in the call-by-reference parameter sgn equals sgn(n1-n2), that
is, the sign of n1-n2.  Otherwise, the value equals 0.  <h3>Example</h3>

The following code implements a function that checks whether two given
lists are equal based on a given equality funtion on list elements:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_11.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_equal
  <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> eqfn<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> sgn<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// uninitialied</span>
  <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> list0_forall2_eq <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> eqfn<span class="keyword">,</span> sgn<span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">if</span> sgn <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">then</span>
    ans <span class="comment">// [xs1] and [xs2] are of the same length</span>
  <span class="keyword">else</span>
    false <span class="comment">// [xs1] and [xs2] are of different length</span>
  <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_equal]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_equal">list0_equal</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_equal
<span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> eqfn<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">bool</span></span> <span class="comment">// end of [list0_equal]</span></pre>
<h3>Description</h3>

Given two lists xs1 and xs2 and a function eqfn, this function returns true
if and only if xs1 and xs2 are of the same length and eqfn(xs1[i], xs2[i])
holds for each natural number i less than the length of xs1.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_find_exn">list0_find_exn</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_find_exn
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span></span></pre>
<h3>Description</h3>

This functions returns the first element in its first argument that
satisfies the predicate given as its second argument. In case that such an
element does not exist, the function raises an exception
(<span class="patsyntaxdynexp">NotFoundExn</span>).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_find_opt">list0_find_opt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_find_opt
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function is the optional version of <span class="patsyntaxdynexp">list0_find_exn</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_filter">list0_filter</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_filter
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list consisting of the sequence of elements in its
first argument that satisfy the predicate provided as its second argument.

Following is a standard implementation of this function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_12.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list0_filter <span class="keyword">(</span>xs<span class="keyword">,</span> p<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">if</span> p <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">then</span>
      list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> list0_filter&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> p<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span>
      list0_filter&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> p<span class="keyword">)</span>
    <span class="comment">// end of [if]</span>
<span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_filter]</span>
</pre>

However, the implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_map">list0_map</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_map
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function returns a list consisting of the sequence of results obtained
from applying its second argument f to each element in its first argument xs.
Following is a standard implementation of this function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_13.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_map <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
    list0_cons <span class="keyword">(</span>f x<span class="keyword">,</span> list0_map <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_map]</span>
</pre>


However, the implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_mapopt">list0_mapopt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_mapopt
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">Option_vt</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs of length n and a function f, this function returns
another list that collects precisely every y whenever <span class="patsyntaxdynexp">Some0(y)</span> is
returned by f(xs[i]), where i ranges from 0 until n-1, inclusive.
The implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_imap">list0_imap</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_imap
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs, this function returns a list consisting of the sequence of
results obtained from applying its second argument f to each pair (i,
xs[i]), where i ranges from 0 until the length of xs minus 1, inclusive,
and xs[i] refers to element i in the list xs.

Following is a standard implementation of this function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_14.dats">
<span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_imap <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> aux <span class="keyword">(</span>
  i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">a</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="staexp">b</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_cons <span class="keyword">(</span>f <span class="keyword">(</span>i<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> aux <span class="keyword">(</span>i+<span class="dynexp">1</span><span class="keyword">,</span> xs<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [aux]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  aux <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> xs<span class="keyword">,</span> f<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_imap]</span>
</pre>

However, the implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_map2">list0_map2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a1<span class="keyword">,</span>a2<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> list0_map2 <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">cfun2</span> <span class="keyword">(</span><span class="staexp">a1</span><span class="keyword">,</span> <span class="staexp">a2</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span> <span class="comment">// end of [list0_map2]</span></pre>
<h3>Description</h3>

This function returns a list consisting of the sequence of results obtained
from applying its third argument f to each pair in the zip of the first and
second arguments.

Following is a standard implementation of this function:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_15.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a1<span class="keyword">,</span>a2</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_map2 <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs1 <span class="keyword">of</span>
<span class="keyword">|</span> list0_cons <span class="keyword">(</span>x1<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
  <span class="keyword">case+</span> xs2 <span class="keyword">of</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>x2<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_cons <span class="keyword">(</span>f <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span><span class="keyword">,</span> list0_map2 <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_map2]</span>
</pre>

However, the implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_zip">list0_zip</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_zip <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">@(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given two lists xs and ys of length m and n, respectively, this function
returns a list of pairs (xs[i], ys[i]), where i ranges from 0 until
min(m,n)-1 and xs[i] (ys[i]) refers to element i in xs (ys).
<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_16.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">x<span class="keyword">,</span>y</span><span class="keyword">}</span>
list0_zip <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
  <span class="keyword">case+</span> ys <span class="keyword">of</span>
  <span class="keyword">|</span> list0_cons <span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_cons <span class="keyword">(</span><span class="keyword">@(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list0_zip&lt;<span class="staexp">x</span><span class="keyword">,</span><span class="staexp">y</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">|</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_zip]</span>
</pre>

However, the implementation of this function in ATSLIB is tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_zipwith">list0_zipwith</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">macdef</span> list0_zipwith <span class="keyword">=</span> list0_map2</span></pre>
<h3>Description</h3>
This function does exactly the same as <span class="patsyntaxdynexp">list0_map2</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_quicksort">list0_quicksort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_quicksort
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its first argument according to the ordering provided
as its second argument. <h3>Example</h3>

The following code mergesorts a randomly generated list of integers:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_17.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="keyword">staload</span> "contrib/libats-hwxi/testing/SATS/randgen.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="neuexp"><span class="keyword">#define</span> N 10</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  list0_of_list <span class="keyword">(</span>randgen_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>N<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"xs(bef) = "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list0_sep <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  list0_quicksort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=&gt;</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"xs(aft) = "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list0_sep <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list0_mergesort">list0_mergesort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list0_mergesort
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its first argument according to the
ordering implemented by its second argument.  <h3>Example</h3>

The following code mergesorts a randomly generated list of integers:

<pre class="patsyntax patscode_tryit" name="TRYIT/libats_ML_list0_18.dats"><span class="comment">//</span>
<span class="keyword">staload</span> "libats/ML/SATS/basis.sats"
<span class="keyword">staload</span> "libats/ML/SATS/list0.sats"
<span class="keyword">staload</span> "contrib/libats-hwxi/testing/SATS/randgen.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="neuexp"><span class="keyword">#define</span> N 10</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  list0_of_list <span class="keyword">(</span>randgen_list&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>N<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"xs(bef) = "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list0_sep <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  list0_mergesort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=&gt;</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"xs(aft) = "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list0_sep <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [main0] *)</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="+">+</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> + <span class="keyword">with</span> list0_append</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> list0_get_at_exn</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g0ofg1">g0ofg1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> g0ofg1 <span class="keyword">with</span> g0ofg1_list</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> g0ofg1 <span class="keyword">with</span> g0ofg1_list_vt</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="g1ofg0">g1ofg0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> g1ofg0 <span class="keyword">with</span> g1ofg0_list</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="iseqz">iseqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> list0_is_empty</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="isneqz">isneqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> list0_isnot_empty</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".head">.head</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>head <span class="keyword">with</span> list0_head_exn</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id=".tail">.tail</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">.</span>tail <span class="keyword">with</span> list0_tail_exn</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="length">length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> list0_length</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="print">print</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_list0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="prerr">prerr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_list0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint">fprint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list0_sep</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

