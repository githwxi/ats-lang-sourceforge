<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: November 2007
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Deb <span class="keyword">=</span> "ats_debug.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Lst <span class="keyword">=</span> "ats_list.sats"</span>
<span class="keyword">staload</span> <span class="staexp">NS <span class="keyword">=</span> "ats_namespace.sats"</span>
<span class="keyword">staload</span> <span class="staexp">PM <span class="keyword">=</span> "ats_posmark.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Sym <span class="keyword">=</span> "ats_symbol.sats"</span>

<span class="keyword">staload</span> <span class="staexp">SymEnv <span class="keyword">=</span> "ats_symenv.sats"</span>
<span class="keyword">stadef</span> <span class="staexp"><a name="1751"><span class="stacstdec">symmap_t <span class="keyword">=</span> $SymEnv<span class="keyword">.</span>symmap_t</span></a></span> 
<span class="keyword">typedef</span> <span class="staexp"><a name="1788"><span class="stacstdec">symmapref <span class="keyword">(</span>itm<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> $SymEnv<span class="keyword">.</span>symmapref <span class="keyword">(</span>itm<span class="keyword">)</span></span></a></span>

<span class="keyword">staload</span> <span class="staexp">Syn <span class="keyword">=</span> "ats_syntax.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_staexp1.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_dynexp1.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_staexp2.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_dynexp2.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_stadyncst2.sats"</span>
<span class="keyword">staload</span> <span class="staexp">"ats_trans2_env.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_trans2.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_reference.sats"</span>
<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anonymous*)</span> <span class="keyword">=</span> "ats_reference.dats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anonymous*)</span> <span class="keyword">=</span> "ats_map_lin.dats"</span>
<span class="keyword">staload</span> <span class="staexp">_<span class="comment">(*anonymous*)</span> <span class="keyword">=</span> "ats_symenv.dats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">THISFILENAME "ats_trans2_dyn2.dats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">nil list_nil</span>
<span class="keyword">#define</span> <span class="neuexp">cons list_cons</span>
<span class="keyword">#define</span> <span class="neuexp">:: list_cons</span>

<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> $Syn<span class="keyword">.</span>prerr_d0ynq</span>
<span class="neuexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> $Sym<span class="keyword">.</span>prerr_symbol</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> prerr_loc_error2 <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">(</span>$Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": error(2)"<span class="keyword">)</span>
<span class="comment">// end of [prerr_loc_error2]
</span>
<span class="keyword">fn</span> prerr_interror <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr "INTERNAL ERROR (ats_trans2_dyn2)"

<span class="keyword">fn</span> prerr_loc_interror <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  $Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": INTERNAL ERROR (ats_trans2_dyn2)"
<span class="keyword">end</span> <span class="comment">// end of [prerr_loc_interror]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> dyncstimploc_posmark
  <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> d2c<span class="keyword">:</span> <span class="staexp">d2cst_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc_d2c <span class="keyword">=</span> d2cst_loc_get <span class="keyword">(</span>d2c<span class="keyword">)</span>
  <span class="keyword">val</span> loc_begoff <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_begpos_toff loc
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_insert_dyncstimp_beg <span class="keyword">(</span>loc_begoff<span class="keyword">,</span> loc_d2c<span class="keyword">)</span>
  <span class="keyword">val</span> loc_endoff <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_endpos_toff loc
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_insert_dyncstimp_end <span class="keyword">(</span>loc_endoff<span class="keyword">,</span> loc_d2c<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [dyncstimploc_posmark]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> symintr_tr <span class="keyword">(</span>ids<span class="keyword">:</span> <span class="staexp">i0delst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>ids<span class="keyword">:</span> <span class="staexp">i0delst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">case+</span> ids <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>id<span class="keyword">,</span> ids<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux ids <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_add <span class="keyword">(</span>id<span class="keyword">.</span>i0de_sym<span class="keyword">,</span> D2ITEMsymdef nil<span class="keyword">)</span>
      <span class="keyword">}</span> <span class="comment">// end of [list_cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [list_nil]
</span>  <span class="comment">// end of [aux]
</span><span class="keyword">in</span>
  aux ids
<span class="keyword">end</span> <span class="comment">// end of [symintr_tr]
</span>
<span class="keyword">fn</span> symelim_tr <span class="keyword">(</span>ids<span class="keyword">:</span> <span class="staexp">i0delst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>ids<span class="keyword">:</span> <span class="staexp">i0delst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">case+</span> ids <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>id<span class="keyword">,</span> ids<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux ids <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_add <span class="keyword">(</span>id<span class="keyword">.</span>i0de_sym<span class="keyword">,</span> D2ITEMsymdef nil<span class="keyword">)</span>
      <span class="keyword">}</span> <span class="comment">// end of [list_cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [list_nil]
</span>  <span class="comment">// end of [aux]
</span><span class="keyword">in</span>
  aux ids
<span class="keyword">end</span> <span class="comment">// end of [symelim_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> c1lassdec_tr
  <span class="keyword">(</span>id<span class="keyword">:</span> <span class="staexp">i0de</span><span class="keyword">,</span> sup<span class="keyword">:</span> <span class="staexp">s1expopt</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">val</span> s2c <span class="keyword">=</span> s2cst_make <span class="keyword">(</span>
      id<span class="keyword">.</span>i0de_sym <span class="comment">// sym
</span>    <span class="keyword">,</span> id<span class="keyword">.</span>i0de_loc <span class="comment">// location
</span>    <span class="keyword">,</span> s2rt_cls <span class="comment">// srt
</span>    <span class="keyword">,</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// isabs
</span>    <span class="keyword">,</span> false <span class="comment">// iscon
</span>    <span class="keyword">,</span> false <span class="comment">// isrec
</span>    <span class="keyword">,</span> false <span class="comment">// isasp
</span>    <span class="keyword">,</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// islst
</span>    <span class="keyword">,</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// argvar
</span>    <span class="keyword">,</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// def
</span>  <span class="keyword">)</span> <span class="comment">// end of [s2cst_make]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_add_scst s2c
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> sup <span class="keyword">of</span>
    <span class="keyword">|</span> Some s1e <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> s2e <span class="keyword">=</span> s1exp_tr_dn_cls <span class="keyword">(</span>s1e<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> s2cst_supcls_add <span class="keyword">(</span>s2c<span class="keyword">,</span> s2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="comment">// nothing
</span>      <span class="keyword">end</span> <span class="comment">// end of [Some]
</span>    <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [val]
</span><span class="keyword">}</span> <span class="comment">// end of [c1lassdec_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
overload_def_tr <span class="keyword">(</span>id<span class="keyword">,</span> def<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> ans <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">val</span> id_sym <span class="keyword">=</span> id<span class="keyword">.</span>i0de_sym
    <span class="keyword">val</span> ans <span class="keyword">=</span> the_d2expenv_current_find id_sym
    <span class="keyword">val</span> ans <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> ans <span class="keyword">of</span>
      <span class="keyword">|</span> Some_vt _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>fold@ ans<span class="keyword">;</span> ans<span class="keyword">)</span>
      <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> the_d2expenv_pervasive_find id_sym
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2itemopt_vt</span>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> d2is <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> ans <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>Some_vt d2i <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2i <span class="keyword">of</span>
      <span class="keyword">|</span> D2ITEMsymdef d2is <span class="keyword">=&gt;</span> d2is <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_error2 id<span class="keyword">.</span>i0de_loc<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: overload_def_tr"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the identifier ["<span class="keyword">;</span>
          prerr id<span class="keyword">.</span>i0de_sym<span class="keyword">;</span>
          prerr "] should refer to a symbol but it does not."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2itemlst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>          
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">end</span> <span class="comment">(* end of [Some_vt] *)</span>
    <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_error2 id<span class="keyword">.</span>i0de_loc<span class="keyword">;</span>
        $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: overload_def_tr"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
        prerr ": the identifier ["<span class="keyword">;</span>
        prerr id<span class="keyword">.</span>i0de_sym<span class="keyword">;</span>
        prerr "] is unrecognized."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2itemlst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [None_vt]
</span>  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2itemlst</span>
<span class="comment">(*
  val () = begin
    print "overload_def_tr: def := "; print_d2item def; print_newline ();
    print "overload_def_tr: d2is := "; print_d2itemlst d2is; print_newline ();
  end // end of [val]
*)</span>
  <span class="keyword">val</span> d2is_new <span class="keyword">=</span> D2ITEMsymdef <span class="keyword">(</span>def :: d2is<span class="keyword">)</span> 
<span class="keyword">in</span>
  the_d2expenv_add <span class="keyword">(</span>id<span class="keyword">.</span>i0de_sym<span class="keyword">,</span> d2is_new<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">(* end of [overload_def_tr] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> overload_tr
  <span class="keyword">(</span>id<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>i0de</span><span class="keyword">,</span> qid<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>dqi0de</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2item</span> <span class="keyword">=</span> def <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">(*
  val () = begin
    print "overload_tr: id = ";
    $Sym.print_symbol id.i0de_sym;
    print_newline ();
    print "overload_tr: qid = ";
    $Syn.print_d0ynq qid.dqi0de_qua;
    $Sym.print_symbol qid.dqi0de_sym;
    print_newline ();
  end // end of [val]
*)</span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> 
    the_d2expenv_find_qua <span class="keyword">(</span>qid<span class="keyword">.</span>dqi0de_qua<span class="keyword">,</span> qid<span class="keyword">.</span>dqi0de_sym<span class="keyword">)</span>
  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> def <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> ans <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>Some_vt d2i <span class="keyword">=&gt;</span> d2i <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_error2 qid<span class="keyword">.</span>dqi0de_loc<span class="keyword">;</span>
        $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: overload_tr"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
        prerr ": the dynamic identifier ["<span class="keyword">;</span>
        prerr qid<span class="keyword">.</span>dqi0de_qua<span class="keyword">;</span> prerr qid<span class="keyword">.</span>dqi0de_sym<span class="keyword">;</span>
        prerr "] is unrecognized."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2item<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [None_vt]
</span>  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2item</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> overload_def_tr <span class="keyword">(</span>id<span class="keyword">,</span> def<span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [overload_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> witht1ype_tr
  <span class="keyword">(</span>w1t<span class="keyword">:</span> <span class="staexp">witht1ype</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">s2expopt</span> <span class="keyword">=</span> <span class="keyword">case+</span> w1t <span class="keyword">of</span>
  <span class="keyword">|</span> WITHT1YPEnone <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> WITHT1YPEprop s1e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>s1exp_tr_dn <span class="keyword">(</span>s1e<span class="keyword">,</span> s2rt_prop<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> WITHT1YPEtype s1e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>s1exp_tr_dn <span class="keyword">(</span>s1e<span class="keyword">,</span> s2rt_t0ype<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> WITHT1YPEview s1e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>s1exp_tr_dn <span class="keyword">(</span>s1e<span class="keyword">,</span> s2rt_view<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> WITHT1YPEviewtype s1e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>s1exp_tr_dn <span class="keyword">(</span>s1e<span class="keyword">,</span> s2rt_viewt0ype<span class="keyword">)</span><span class="keyword">)</span>
<span class="comment">// end of [witht1ype_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> v1aldec_tr <span class="keyword">(</span>d1c<span class="keyword">:</span> <span class="staexp">v1aldec</span><span class="keyword">,</span> p2t<span class="keyword">:</span> <span class="staexp">p2at</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2aldec</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc <span class="keyword">=</span> d1c<span class="keyword">.</span>v1aldec_loc
  <span class="keyword">val</span> def <span class="keyword">=</span> d1exp_tr <span class="keyword">(</span>d1c<span class="keyword">.</span>v1aldec_def<span class="keyword">)</span>
  <span class="keyword">val</span> ann <span class="keyword">=</span> witht1ype_tr <span class="keyword">(</span>d1c<span class="keyword">.</span>v1aldec_ann<span class="keyword">)</span>
<span class="keyword">in</span>
  v2aldec_make <span class="keyword">(</span>loc<span class="keyword">,</span> p2t<span class="keyword">,</span> def<span class="keyword">,</span> ann<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [v1aldec_tr]
</span>
<span class="keyword">fn</span> v1aldeclst_tr <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>isrec<span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v1aldec<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2aldeclst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v1aldec<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">case+</span> d1cs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>p1at_tr d1c<span class="keyword">.</span>v1aldec_pat<span class="keyword">,</span> aux1 d1cs<span class="keyword">)</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span>d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>v1aldec<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> p2ts<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2aldeclst</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> d1cs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> cons <span class="keyword">(</span>p2t<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=</span> p2ts
      <span class="keyword">in</span>
        cons <span class="keyword">(</span>v1aldec_tr <span class="keyword">(</span>d1c<span class="keyword">,</span> p2t<span class="keyword">)</span><span class="keyword">,</span> aux2 <span class="keyword">(</span>d1cs<span class="keyword">,</span> p2ts<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> p2ts<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> aux1 d1cs
  <span class="keyword">val</span> s2vs <span class="keyword">=</span> s2varlst_of_s2varlstord <span class="keyword">(</span>p2atlst_svs_union p2ts<span class="keyword">)</span>
  <span class="keyword">val</span> d2vs <span class="keyword">=</span> d2varlst_of_d2varlstord <span class="keyword">(</span>p2atlst_dvs_union p2ts<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> isrec <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_add_dvarlst d2vs
    <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux2 <span class="keyword">(</span>d1cs<span class="keyword">,</span> p2ts<span class="keyword">)</span>
  <span class="keyword">in</span>
    the_s2expenv_add_svarlst s2vs<span class="keyword">;</span> d2cs
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux2 <span class="keyword">(</span>d1cs<span class="keyword">,</span> p2ts<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_add_dvarlst d2vs
  <span class="keyword">in</span>
    the_s2expenv_add_svarlst s2vs<span class="keyword">;</span> d2cs
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">(* end of [v1aldeclst_tr] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> f1undec_tr <span class="keyword">(</span>
    level<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> decarg<span class="keyword">:</span> <span class="staexp">s2qualst</span>
  <span class="keyword">,</span> d2v<span class="keyword">:</span> <span class="staexp">d2var_t</span>
  <span class="keyword">,</span> d1c<span class="keyword">:</span> <span class="staexp">f1undec</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">f2undec</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_lev_set <span class="keyword">(</span>d2v<span class="keyword">,</span> level<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_decarg_set <span class="keyword">(</span>d2v<span class="keyword">,</span> decarg<span class="keyword">)</span>
  <span class="keyword">val</span> def <span class="keyword">=</span> d1exp_tr <span class="keyword">(</span>d1c<span class="keyword">.</span>f1undec_def<span class="keyword">)</span>
<span class="comment">(*
  val () = begin
    print "f1undec_tr: d2v = "; print d2v; print_newline ()
    print "f1undec_tr: def = "; print def; print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">val</span> ann <span class="keyword">=</span> witht1ype_tr <span class="keyword">(</span>d1c<span class="keyword">.</span>f1undec_ann<span class="keyword">)</span>
<span class="keyword">in</span>
  f2undec_make <span class="keyword">(</span>d1c<span class="keyword">.</span>f1undec_loc<span class="keyword">,</span> d2v<span class="keyword">,</span> def<span class="keyword">,</span> ann<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [f1undec_tr]
</span>
<span class="keyword">fn</span> f1undeclst_tr <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    fk<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>funkind</span>
  <span class="keyword">,</span> level<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> decarg<span class="keyword">:</span> <span class="staexp">s2qualst</span>
  <span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>f1undec<span class="keyword">,</span> n<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">f2undeclst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> isprf <span class="keyword">=</span> $Syn<span class="keyword">.</span>funkind_is_proof fk
  <span class="keyword">val</span> isrec <span class="keyword">=</span> $Syn<span class="keyword">.</span>funkind_is_recursive fk
  <span class="keyword">val</span> d2vs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> aux1 <span class="keyword">(</span>isprf<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
      <span class="keyword">(</span>isprf<span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>f1undec<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span>
      <span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d1cs <span class="keyword">of</span>
      <span class="keyword">|</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> d2v <span class="keyword">=</span> d2var_make <span class="keyword">(</span>d1c<span class="keyword">.</span>f1undec_sym_loc<span class="keyword">,</span> d1c<span class="keyword">.</span>f1undec_sym<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_isfix_set <span class="keyword">(</span>d2v<span class="keyword">,</span> true<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_isprf_set <span class="keyword">(</span>d2v<span class="keyword">,</span> isprf<span class="keyword">)</span>
        <span class="keyword">in</span>
          cons <span class="keyword">(</span>d2v<span class="keyword">,</span> aux1 <span class="keyword">(</span>isprf<span class="keyword">,</span> d1cs<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [aux1]
</span>  <span class="keyword">}</span> <span class="comment">// end of [where]
</span>  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      level<span class="keyword">:</span> <span class="staexp">int</span>
    <span class="keyword">,</span> decarg<span class="keyword">:</span> <span class="staexp">s2qualst</span>
    <span class="keyword">,</span> d2vs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>f1undec<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>f2undec<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">case+</span> d2vs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d2v<span class="keyword">,</span> d2vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=</span> d1cs
        <span class="keyword">val</span> d2c <span class="keyword">=</span> f1undec_tr <span class="keyword">(</span>level<span class="keyword">,</span> decarg<span class="keyword">,</span> d2v<span class="keyword">,</span> d1c<span class="keyword">)</span>
        <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux2 <span class="keyword">(</span>level<span class="keyword">,</span> decarg<span class="keyword">,</span> d2vs<span class="keyword">,</span> d1cs<span class="keyword">)</span>
      <span class="keyword">in</span>
        cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isrec <span class="keyword">then</span> the_d2expenv_add_dvarlst <span class="keyword">(</span>d2vs<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux2 <span class="keyword">(</span>level<span class="keyword">,</span> decarg<span class="keyword">,</span> d2vs<span class="keyword">,</span> d1cs<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isrec <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> the_d2expenv_add_dvarlst <span class="keyword">(</span>d2vs<span class="keyword">)</span>
<span class="keyword">in</span>
  d2cs
<span class="keyword">end</span> <span class="comment">// end of [f1undeclst_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> v1ardec_tr <span class="keyword">(</span>d1c<span class="keyword">:</span> <span class="staexp">v1ardec</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2ardec</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> knd <span class="keyword">=</span> d1c<span class="keyword">.</span>v1ardec_knd
<span class="comment">(*
  // top-level stack allocation is now supported!!!
  val () = if knd &gt; 0 then (*BANG*)
    if d2var_current_level_get () = 0 then begin
      prerr_loc_error2 (d1c.v1ardec_loc);
      prerr ": stack allocation is not supported at the top level.";
      prerr_newline ();
      $Err.abort {void} ()
    end // end of [if]
  // end of [val]
*)</span>
  <span class="keyword">val</span> sym <span class="keyword">=</span> d1c<span class="keyword">.</span>v1ardec_sym
  <span class="keyword">val</span> loc_sym <span class="keyword">=</span> d1c<span class="keyword">.</span>v1ardec_sym_loc
  <span class="keyword">val</span> d2v_ptr <span class="keyword">=</span> d2var_make <span class="keyword">(</span>loc_sym<span class="keyword">,</span> sym<span class="keyword">)</span>
  <span class="comment">// [s2v_ptr] is introduced as a static variable of the
</span>  <span class="keyword">val</span> s2v_ptr <span class="keyword">=</span> s2var_make_id_srt <span class="keyword">(</span>sym<span class="keyword">,</span> s2rt_addr<span class="keyword">)</span> <span class="comment">// same name
</span>  <span class="keyword">val</span> os2e_ptr <span class="keyword">=</span> Some <span class="keyword">(</span>s2exp_var s2v_ptr<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_addr_set <span class="keyword">(</span>d2v_ptr<span class="keyword">,</span> os2e_ptr<span class="keyword">)</span>
  <span class="keyword">val</span> typ <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d1c<span class="keyword">.</span>v1ardec_typ <span class="keyword">of</span>
    <span class="keyword">|</span> Some s1e <span class="keyword">=&gt;</span> Some <span class="keyword">(</span>s1exp_tr_dn_impredicative s1e<span class="keyword">)</span>
    <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2expopt</span>
  <span class="keyword">val</span> wth <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d1c<span class="keyword">.</span>v1ardec_wth <span class="keyword">of</span>
    <span class="keyword">|</span> Some <span class="keyword">(</span>i0de<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2v <span class="keyword">=</span> d2var_make <span class="keyword">(</span>i0de<span class="keyword">.</span>i0de_loc<span class="keyword">,</span> i0de<span class="keyword">.</span>i0de_sym<span class="keyword">)</span>
      <span class="keyword">in</span>
        D2VAROPTsome d2v
      <span class="keyword">end</span> <span class="comment">// end of [Some]
</span>    <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> D2VAROPTnone <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2varopt</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> ini <span class="keyword">=</span> d1expopt_tr d1c<span class="keyword">.</span>v1ardec_ini
<span class="keyword">in</span>
  v2ardec_make <span class="keyword">(</span>d1c<span class="keyword">.</span>v1ardec_loc<span class="keyword">,</span> knd<span class="keyword">,</span> d2v_ptr<span class="keyword">,</span> s2v_ptr<span class="keyword">,</span> typ<span class="keyword">,</span> wth<span class="keyword">,</span> ini<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [v1ardec_tr]
</span>
<span class="keyword">fn</span> v1ardeclst_tr
  <span class="keyword">(</span>d1cs<span class="keyword">:</span> <span class="staexp">v1ardeclst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">v2ardeclst</span> <span class="keyword">=</span> d2cs <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> aux1 <span class="keyword">(</span>
      d1cs<span class="keyword">:</span> <span class="staexp">v1ardeclst</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">v2ardeclst</span> <span class="keyword">=</span> <span class="keyword">case+</span> d1cs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>v1ardec_tr d1c<span class="keyword">,</span> aux1 d1cs<span class="keyword">)</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [aux1]
</span>  <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux1 d1cs
  <span class="keyword">fun</span> aux2 <span class="keyword">(</span>
      d2cs<span class="keyword">:</span> <span class="staexp">v2ardeclst</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux2 d2cs <span class="keyword">where</span> <span class="keyword">{</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_add_svar <span class="keyword">(</span>d2c<span class="keyword">.</span>v2ardec_svar<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_add_dvar <span class="keyword">(</span>d2c<span class="keyword">.</span>v2ardec_dvar<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d2c<span class="keyword">.</span>v2ardec_wth <span class="keyword">of</span>
          <span class="keyword">|</span> D2VAROPTsome d2v <span class="keyword">=&gt;</span> the_d2expenv_add_dvar d2v
          <span class="keyword">|</span> D2VAROPTnone <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="comment">// end of [val]
</span>      <span class="keyword">}</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [aux2]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux2 d2cs
<span class="keyword">}</span> <span class="comment">// end of [v2ardeclst_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> s1arglst_bind_svarlst <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> s1as<span class="keyword">:</span> <span class="staexp">s1arglst</span><span class="keyword">,</span> s2vs<span class="keyword">:</span> <span class="staexp">s2varlst</span><span class="keyword">,</span> sub<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>stasub_t</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2varlst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      s1as<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s1arg<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">,</span> s2vs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">,</span> sub<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>stasub_t</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> s1as <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>s1a<span class="keyword">,</span> s1as<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> cons <span class="keyword">(</span>s2v<span class="keyword">,</span> s2vs<span class="keyword">)</span> <span class="keyword">=</span> s2vs
        <span class="keyword">val</span> s2v_new <span class="keyword">=</span> s1arg_var_tr_srt <span class="keyword">(</span>s1a<span class="keyword">,</span> s2var_srt_get s2v<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span>
          <span class="keyword">~</span><span class="keyword">(</span>s2var_srt_get s2v &lt;= s2var_srt_get s2v_new<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
          prerr_loc_error2 s1a<span class="keyword">.</span>s1arg_loc<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf
            <span class="keyword">(</span>": %s: s1arglst_bind_svarlst"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the ascribed sort for the static variable ["<span class="keyword">;</span>
          $Sym<span class="keyword">.</span>prerr_symbol s1a<span class="keyword">.</span>s1arg_sym<span class="keyword">;</span>
          prerr "] is incorrect."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">val</span> s2e_new <span class="keyword">=</span> s2exp_var <span class="keyword">(</span>s2v_new<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sub := stasub_add <span class="keyword">(</span>sub<span class="keyword">,</span> s2v<span class="keyword">,</span> s2e_new<span class="keyword">)</span>
      <span class="keyword">in</span>
        cons <span class="keyword">(</span>s2v_new<span class="keyword">,</span> aux <span class="keyword">(</span>s1as<span class="keyword">,</span> s2vs<span class="keyword">,</span> sub<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [aux]
</span>  <span class="keyword">val</span> ns1as <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length s1as <span class="keyword">and</span> ns2vs <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length s2vs
<span class="keyword">in</span>
  <span class="keyword">if</span> ns1as &lt;&gt; ns2vs <span class="keyword">then</span> <span class="keyword">begin</span>
    prerr_loc_error2 loc0<span class="keyword">;</span>
    <span class="keyword">if</span> ns1as <span class="keyword">&lt;</span> ns2vs <span class="keyword">then</span> prerr ": more static arguments should be given."<span class="keyword">;</span>
    <span class="keyword">if</span> ns1as <span class="keyword">&gt;</span> ns2vs <span class="keyword">then</span> prerr ": less static arguments should be given."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>s2varlst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    aux <span class="keyword">(</span>s1as<span class="keyword">,</span> s2vs<span class="keyword">,</span> sub<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">(* end of [s1arglst_bind_svarlst] *)</span>
      
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> s1explst_bind_svarlst <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> s1es<span class="keyword">:</span> <span class="staexp">s1explst</span><span class="keyword">,</span> s2vs<span class="keyword">:</span> <span class="staexp">s2varlst</span><span class="keyword">,</span> sub<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>stasub_t</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2explst</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      s1es<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s1exp<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">,</span> s2vs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s2var_t<span class="keyword">,</span> n<span class="keyword">)</span></span>
    <span class="keyword">,</span> sub<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>stasub_t</span>
    <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2explst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> s1es <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>s1e<span class="keyword">,</span> s1es<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> cons <span class="keyword">(</span>s2v<span class="keyword">,</span> s2vs<span class="keyword">)</span> <span class="keyword">=</span> s2vs<span class="keyword">;</span> <span class="keyword">val</span> s2e <span class="keyword">=</span> s1exp_tr_up <span class="keyword">(</span>s1e<span class="keyword">)</span>
        <span class="keyword">val</span> s2t_s2v <span class="keyword">=</span> s2var_srt_get s2v <span class="keyword">and</span> s2t_s2e <span class="keyword">=</span> s2e<span class="keyword">.</span>s2exp_srt
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">~</span><span class="keyword">(</span>s2t_s2e &lt;= s2t_s2v<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
          prerr_loc_error2 s1e<span class="keyword">.</span>s1exp_loc<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: s1explst_bind_svarlst"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the sort of the static expression ["<span class="keyword">;</span> prerr s1e<span class="keyword">;</span>
          prerr "] is expected to be ["<span class="keyword">;</span> prerr s2t_s2v<span class="keyword">;</span>
          prerr "], but it is ["<span class="keyword">;</span> prerr s2t_s2e<span class="keyword">;</span> prerr "] instead."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [val]
</span>        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sub := stasub_add <span class="keyword">(</span>sub<span class="keyword">,</span> s2v<span class="keyword">,</span> s2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        list_cons <span class="keyword">(</span>s2e<span class="keyword">,</span> aux <span class="keyword">(</span>s1es<span class="keyword">,</span> s2vs<span class="keyword">,</span> sub<span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">val</span> ns1es <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length s1es <span class="keyword">and</span> ns2vs <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length s2vs
<span class="keyword">in</span>
  <span class="keyword">if</span> ns1es &lt;&gt; ns2vs <span class="keyword">then</span> <span class="keyword">begin</span>
    prerr_loc_error2 loc0<span class="keyword">;</span>
    <span class="keyword">if</span> ns1es <span class="keyword">&lt;</span> ns2vs <span class="keyword">then</span> prerr ": more template arguments should be given."<span class="keyword">;</span>
    <span class="keyword">if</span> ns1es <span class="keyword">&gt;</span> ns2vs <span class="keyword">then</span> prerr ": less template arguments should be given."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>s2explst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    aux <span class="keyword">(</span>s1es<span class="keyword">,</span> s2vs<span class="keyword">,</span> sub<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">(* end of [s1explst_bind_svarlst] *)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//
</span><span class="comment">// HX: [s2e0] is assumed to be in WHNF
</span><span class="comment">//
</span><span class="keyword">fun</span> d1exp_tr_ann <span class="keyword">(</span>
    d1e0<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">,</span> s2e0<span class="keyword">:</span> <span class="staexp">s2exp</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2exp</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> s2e0<span class="keyword">.</span>s2exp_node <span class="keyword">of</span>
  <span class="keyword">|</span> S2Euni <span class="keyword">(</span>s2vs<span class="keyword">,</span> s2ps<span class="keyword">,</span> s2e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> d1e0<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elam_sta_ana <span class="keyword">(</span>loc_arg<span class="keyword">,</span> arg<span class="keyword">,</span> body<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">var</span> sub<span class="keyword">:</span> <span class="staexp">stasub_t</span> <span class="keyword">=</span> stasub_nil
        <span class="keyword">val</span> s2vs <span class="keyword">=</span> s1arglst_bind_svarlst
          <span class="keyword">(</span>loc_arg<span class="keyword">,</span> arg<span class="keyword">,</span> s2vs<span class="keyword">,</span> sub<span class="keyword">)</span> <span class="comment">// end of [val]
</span>        <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_push <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
          the_s2expenv_add_svarlst <span class="keyword">(</span>s2vs<span class="keyword">)</span>
        <span class="comment">// end of [val]
</span>        <span class="keyword">val</span> s2ps <span class="keyword">=</span> s2explst_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2ps<span class="keyword">)</span>
        <span class="keyword">val</span> s2e <span class="keyword">=</span> s2exp_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2e<span class="keyword">)</span>
        <span class="keyword">val</span> body <span class="keyword">=</span> d1exp_tr_ann <span class="keyword">(</span>body<span class="keyword">,</span> s2e<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
          the_s2expenv_pop <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
        <span class="comment">// end of [val]
</span>      <span class="keyword">in</span>
        d2exp_lam_sta <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> s2vs<span class="keyword">,</span> s2ps<span class="keyword">,</span> body<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D1Elam_sta_ana]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> d2e0 <span class="keyword">=</span> d1exp_tr_ann <span class="keyword">(</span>d1e0<span class="keyword">,</span> s2e<span class="keyword">)</span>
      <span class="keyword">in</span>
        d2exp_lam_sta <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> s2vs<span class="keyword">,</span> s2ps<span class="keyword">,</span> d2e0<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_]
</span>    <span class="keyword">end</span> <span class="comment">(* end of [S2Euni] *)</span>
  <span class="keyword">|</span> S2Efun <span class="keyword">(</span>fc<span class="keyword">,</span> lin1<span class="keyword">,</span> s2fe<span class="keyword">,</span> npf1<span class="keyword">,</span> s2es_arg<span class="keyword">,</span> s2e_res<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> d1e0<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elam_dyn <span class="keyword">(</span>lin2<span class="keyword">,</span> p1t_arg<span class="keyword">,</span> d1e_body<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">@(</span>p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span> <span class="keyword">=</span> d1exp_arg_body_tr_ann <span class="keyword">(</span>
          d1e0<span class="keyword">,</span> fc<span class="keyword">,</span> lin1<span class="keyword">,</span> s2fe<span class="keyword">,</span> npf1<span class="keyword">,</span> s2es_arg<span class="keyword">,</span> s2e_res<span class="keyword">,</span> lin2<span class="keyword">,</span> p1t_arg<span class="keyword">,</span> d1e_body
        <span class="keyword">)</span> <span class="comment">// end of [val]
</span>      <span class="keyword">in</span>
        d2exp_lam_dyn <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> lin1<span class="keyword">,</span> npf1<span class="keyword">,</span> p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D2Elam_dyn]
</span>    <span class="keyword">|</span> D1Elaminit_dyn <span class="keyword">(</span>lin2<span class="keyword">,</span> p1t_arg<span class="keyword">,</span> d1e_body<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">@(</span>p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span> <span class="keyword">=</span> d1exp_arg_body_tr_ann <span class="keyword">(</span>
          d1e0<span class="keyword">,</span> fc<span class="keyword">,</span> lin1<span class="keyword">,</span> s2fe<span class="keyword">,</span> npf1<span class="keyword">,</span> s2es_arg<span class="keyword">,</span> s2e_res<span class="keyword">,</span> lin2<span class="keyword">,</span> p1t_arg<span class="keyword">,</span> d1e_body
        <span class="keyword">)</span> <span class="comment">// end of [val]
</span>      <span class="keyword">in</span>
        d2exp_laminit_dyn <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> lin1<span class="keyword">,</span> npf1<span class="keyword">,</span> p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [D2Elam_dyn]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> d2exp_ann_type <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> d1exp_tr d1e0<span class="keyword">,</span> s2e0<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">(* end of [S2Efun] *)</span>
  <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> d2exp_ann_type <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">,</span> d1exp_tr d1e0<span class="keyword">,</span> s2e0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">(* end of [d1exp_tr_ann] *)</span>

<span class="keyword">and</span> d1exp_arg_body_tr_ann <span class="keyword">(</span>
    d1e0<span class="keyword">:</span> <span class="staexp">d1exp</span>
  <span class="keyword">,</span> fc<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>funclo</span>
  <span class="keyword">,</span> lin1<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> s2fe<span class="keyword">:</span> <span class="staexp">s2eff</span>
  <span class="keyword">,</span> npf1<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> s2es_arg<span class="keyword">:</span> <span class="staexp">s2explst</span>
  <span class="keyword">,</span> s2e_res<span class="keyword">:</span> <span class="staexp">s2exp</span>
  <span class="keyword">,</span> lin2<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> p1t_arg<span class="keyword">:</span> <span class="staexp">p1at</span>
  <span class="keyword">,</span> d1e_body<span class="keyword">:</span> <span class="staexp">d1exp</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">@(</span>p2atlst<span class="keyword">,</span> d2exp<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> fc <span class="keyword">of</span>
    <span class="keyword">|</span> $Syn<span class="keyword">.</span>FUNCLOclo knd <span class="keyword">when</span> knd <span class="keyword">=</span> 0 <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_error2 d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">;</span>
        prerr ": function is given an unboxed closure type."<span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [FUNCLOclo when ...]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> lin1 &lt;&gt; lin2 <span class="keyword">then</span> <span class="keyword">begin</span>
    prerr_loc_error2 d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">;</span>
    $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: d1exp_arg_body_tr_ann"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
    <span class="keyword">if</span> lin1 <span class="keyword">&lt;</span> lin2 <span class="keyword">then</span> prerr ": linear function is given a nonlinear type."<span class="keyword">;</span>
    <span class="keyword">if</span> lin1 <span class="keyword">&gt;</span> lin2 <span class="keyword">then</span> prerr ": nonlinear function is given a linear type."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">var</span> wths1es <span class="keyword">=</span> WTHS1EXPLSTnil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> p2t_arg <span class="keyword">=</span> p1at_arg_tr <span class="keyword">(</span>p1t_arg<span class="keyword">,</span> wths1es<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// check for refval types
</span>    <span class="keyword">if</span> wths1explst_is_none wths1es <span class="keyword">then</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      prerr_loc_error2 p1t_arg<span class="keyword">.</span>p1at_loc<span class="keyword">;</span>
      prerr ": the function argument cannot be ascribed refval types."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
  <span class="comment">// end of [val]
</span>  <span class="keyword">var</span> npf2<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0
  <span class="keyword">val</span> p2ts_arg <span class="keyword">=</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> p2t_arg<span class="keyword">.</span>p2at_node <span class="keyword">of</span>
    <span class="keyword">|</span> P2Tlist <span class="keyword">(</span>npf<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>npf2 := npf<span class="keyword">;</span> p2ts<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>p2t_arg<span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">p2atlst</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> npf1 &lt;&gt; npf2 <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// check for pfarity match
</span>    prerr_loc_error2 d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">;</span>
    $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: d1exp_tr_ann"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
    <span class="keyword">if</span> npf1 <span class="keyword">&lt;</span> npf2 <span class="keyword">then</span> prerr ": less proof arguments are expected."<span class="keyword">;</span>
    <span class="keyword">if</span> npf1 <span class="keyword">&gt;</span> npf2 <span class="keyword">then</span> prerr ": more proof arguments are expected."<span class="keyword">;</span>
    prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
    $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> p2ts_arg <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> ns2es <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length s2es_arg
    <span class="keyword">val</span> np2ts <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length p2ts_arg
    <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
      <span class="keyword">(</span>p2ts<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> s2es<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>s2exp<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>p2at<span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
      <span class="keyword">case+</span> p2ts <span class="keyword">of</span>
      <span class="keyword">|</span> cons <span class="keyword">(</span>p2t<span class="keyword">,</span> p2ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val+</span> cons <span class="keyword">(</span>s2e<span class="keyword">,</span> s2es<span class="keyword">)</span> <span class="keyword">=</span> s2es
        <span class="keyword">in</span>
          cons <span class="keyword">(</span>p2at_ann <span class="keyword">(</span>p2t<span class="keyword">.</span>p2at_loc<span class="keyword">,</span> p2t<span class="keyword">,</span> s2e<span class="keyword">)</span><span class="keyword">,</span> aux <span class="keyword">(</span>p2ts<span class="keyword">,</span> s2es<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">end</span>
      <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>            
  <span class="keyword">in</span>
    <span class="keyword">if</span> ns2es &lt;&gt; np2ts <span class="keyword">then</span> <span class="keyword">begin</span>
      prerr_loc_error2 d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">;</span>
      $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: d1exp_tr_ann"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      <span class="keyword">if</span> ns2es <span class="keyword">&lt;</span> np2ts <span class="keyword">then</span> prerr ": less arguments are expected."<span class="keyword">;</span>
      <span class="keyword">if</span> ns2es <span class="keyword">&gt;</span> np2ts <span class="keyword">then</span> prerr ": more arguments are expected."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>p2atlst<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      aux <span class="keyword">(</span>p2ts_arg<span class="keyword">,</span> s2es_arg<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">end</span> <span class="keyword">:</span> <span class="staexp">p2atlst</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_env2</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_push <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> s2vs <span class="keyword">=</span> s2varlst_of_s2varlstord p2t_arg<span class="keyword">.</span>p2at_svs
  <span class="keyword">in</span>
    the_s2expenv_add_svarlst s2vs
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> d2vs <span class="keyword">=</span> d2varlst_of_d2varlstord p2t_arg<span class="keyword">.</span>p2at_dvs
  <span class="keyword">in</span>
    the_d2expenv_add_dvarlst d2vs
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_level</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_current_level_inc <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//
</span>  <span class="keyword">var</span> annerr<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span>
    d1e_body<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Eann_funclo _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>annerr := annerr + 1<span class="keyword">)</span>
    <span class="keyword">|</span> D1Eann_effc _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>annerr := annerr + 1<span class="keyword">)</span> <span class="comment">// less likely
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">(</span>annerr <span class="keyword">&gt;</span> 0<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_loc_error2 <span class="keyword">(</span>d1e0<span class="keyword">.</span>d1exp_loc<span class="keyword">)</span>
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr ": the [funclo/effect] annonation is redundant."
    <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerr_newline <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">in</span>
    $Err<span class="keyword">.</span>abort <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// redundant annotation is treated as an error
</span>  <span class="keyword">end</span> <span class="comment">// end of [val]
</span><span class="comment">//
</span>  <span class="keyword">val</span> d2e_body <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> s2e_res <span class="keyword">=</span> s2exp_whnf <span class="keyword">(</span>s2e_res<span class="keyword">)</span> <span class="keyword">in</span> d1exp_tr_ann <span class="keyword">(</span>d1e_body<span class="keyword">,</span> s2e_res<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span><span class="comment">//
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2var_current_level_dec <span class="keyword">(</span><span class="prfexp">pf_level</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_pop <span class="keyword">(</span><span class="prfexp">pf_env2</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
  <span class="keyword">val</span> loc_body <span class="keyword">=</span> d2e_body<span class="keyword">.</span>d2exp_loc
  <span class="keyword">val</span> d2e_body <span class="keyword">=</span> d2exp_ann_seff <span class="keyword">(</span>loc_body<span class="keyword">,</span> d2e_body<span class="keyword">,</span> s2fe<span class="keyword">)</span>
  <span class="keyword">val</span> d2e_body <span class="keyword">=</span> d2exp_ann_funclo <span class="keyword">(</span>loc_body<span class="keyword">,</span> d2e_body<span class="keyword">,</span> fc<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">@(</span>p2ts_arg<span class="keyword">,</span> d2e_body<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [d2exp_tr_arg_body_ann]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> m1acdef_tr
  <span class="keyword">(</span>knd<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> d2m<span class="keyword">:</span> <span class="staexp">d2mac_t</span><span class="keyword">,</span> d1c<span class="keyword">:</span> <span class="staexp">m1acdef</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> loc <span class="keyword">=</span> d1c<span class="keyword">.</span>m1acdef_loc <span class="keyword">and</span> name <span class="keyword">=</span> d1c<span class="keyword">.</span>m1acdef_sym
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_d2expenv</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_push <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aux <span class="keyword">(</span>d2mac_arglst_get d2m<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">fun</span> aux <span class="keyword">(</span>args<span class="keyword">:</span> <span class="staexp">macarglst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
      <span class="keyword">|</span> cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> arg <span class="keyword">of</span>
            <span class="keyword">|</span> MACARGone <span class="keyword">(</span>d2v<span class="keyword">)</span> <span class="keyword">=&gt;</span> the_d2expenv_add_dmac_var <span class="keyword">(</span>d2v<span class="keyword">)</span>
            <span class="keyword">|</span> MACARGlst <span class="keyword">(</span>_<span class="comment">(*n*)</span><span class="keyword">,</span> d2vs<span class="keyword">)</span> <span class="keyword">=&gt;</span> the_d2expenv_add_dmac_varlst <span class="keyword">(</span>d2vs<span class="keyword">)</span>
        <span class="keyword">in</span>
          aux args
        <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>      <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">}</span> <span class="comment">// end of [where]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> macdef_inc <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> knd <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> macro_level_dec <span class="keyword">(</span>loc<span class="keyword">)</span>
  <span class="keyword">val</span> def <span class="keyword">=</span> d1exp_tr <span class="keyword">(</span>d1c<span class="keyword">.</span>m1acdef_def<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> knd <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> macro_level_inc <span class="keyword">(</span>loc<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> macdef_dec <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_d2expenv_pop <span class="keyword">(</span><span class="prfexp">pf_d2expenv</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2mac_def_set <span class="keyword">(</span>d2m<span class="keyword">,</span> def<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [m1acdef_tr]
</span>
<span class="keyword">fun</span> m1acdeflst_tr <span class="keyword">(</span>knd<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">m1acdeflst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="comment">// knd: 0/1/2 =&gt; short/long/long rec
</span>  <span class="keyword">fn</span> aux1 <span class="keyword">(</span>d1c<span class="keyword">:</span> <span class="staexp">m1acdef</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">d2mac_t</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> args <span class="keyword">=</span> auxarglst d1c<span class="keyword">.</span>m1acdef_arg <span class="keyword">where</span> <span class="keyword">{</span>
      <span class="keyword">fun</span> auxarg <span class="keyword">(</span>arg<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>m0acarg</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">macarg</span> <span class="keyword">=</span> <span class="keyword">let</span>
        <span class="keyword">fn</span> f <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>i0de</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2var_t</span> <span class="keyword">=</span> d2var_make <span class="keyword">(</span>x<span class="keyword">.</span>i0de_loc<span class="keyword">,</span> x<span class="keyword">.</span>i0de_sym<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">case+</span> arg <span class="keyword">of</span>
        <span class="keyword">|</span> $Syn<span class="keyword">.</span>M0ACARGone <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> MACARGone <span class="keyword">(</span>f x<span class="keyword">)</span>
        <span class="keyword">|</span> $Syn<span class="keyword">.</span>M0ACARGlst <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
            <span class="keyword">val</span> d2vs <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_map_fun <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">)</span><span class="keyword">;</span> <span class="keyword">val</span> n <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_length d2vs
          <span class="keyword">in</span>
            MACARGlst <span class="keyword">(</span>n<span class="keyword">,</span> d2vs<span class="keyword">)</span>
          <span class="keyword">end</span>
      <span class="keyword">end</span>
      <span class="keyword">fun</span> auxarglst <span class="keyword">(</span>args<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>m0acarglst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">macarglst</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
        <span class="keyword">|</span> cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>auxarg arg<span class="keyword">,</span> auxarglst args<span class="keyword">)</span> <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [auxarglst]
</span>    <span class="keyword">}</span> <span class="comment">// end of [where]
</span>    <span class="keyword">val</span> def <span class="keyword">=</span> d2exp_empty <span class="keyword">(</span>$Loc<span class="keyword">.</span>location_none<span class="keyword">)</span>
    <span class="keyword">val</span> d2m <span class="keyword">=</span> d2mac_make <span class="keyword">(</span>
      d1c<span class="keyword">.</span>m1acdef_loc<span class="keyword">,</span> d1c<span class="keyword">.</span>m1acdef_sym<span class="keyword">,</span> knd<span class="keyword">,</span> args<span class="keyword">,</span> def
    <span class="keyword">)</span> <span class="comment">// end of [d2mac_make]
</span>  <span class="keyword">in</span>
    <span class="comment">// [knd &gt; 1] : recursive
</span>    <span class="keyword">if</span> knd <span class="keyword">&gt;</span> 1 <span class="keyword">then</span> the_d2expenv_add_dmac_def <span class="keyword">(</span>d2m<span class="keyword">)</span><span class="keyword">;</span> d2m
  <span class="keyword">end</span> <span class="comment">// end of [aux1]
</span>  <span class="keyword">fun</span> aux2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span>d2ms<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>d2mac_t<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>m1acdef<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2ms <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>d2m<span class="keyword">,</span> d2ms<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val+</span> cons <span class="keyword">(</span>d1c<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=</span> d1cs
        <span class="keyword">val</span> knd <span class="keyword">=</span> d2mac_kind_get <span class="keyword">(</span>d2m<span class="keyword">)</span>
      <span class="keyword">in</span>
        m1acdef_tr <span class="keyword">(</span>knd<span class="keyword">,</span> d2m<span class="keyword">,</span> d1c<span class="keyword">)</span><span class="keyword">;</span>
        <span class="comment">// [knd &lt;= 1] : non-recursive
</span>        <span class="keyword">if</span> knd &lt;= 1 <span class="keyword">then</span> the_d2expenv_add_dmac_def <span class="keyword">(</span>d2m<span class="keyword">)</span><span class="keyword">;</span>
        aux2 <span class="keyword">(</span>d2ms<span class="keyword">,</span> d1cs<span class="keyword">)</span>
      <span class="keyword">end</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux2]
</span>  <span class="keyword">val</span> d2ms <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_map_cloptr <span class="keyword">(</span>d1cs<span class="keyword">,</span> aux1<span class="keyword">)</span>
<span class="keyword">in</span>
  aux2 <span class="keyword">(</span>d2ms<span class="keyword">,</span> d1cs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [m1acdeflst_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">viewtypedef</span> <span class="staexp"><a name="24229"><span class="stacstdec">d2cstlst_vt <span class="keyword">=</span> List_vt d2cst_t</span></a></span>

<span class="keyword">fun</span> d1exp_arity_check
  <span class="keyword">(</span>d1e<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">,</span> ns<span class="keyword">:</span> <span class="staexp">List int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//
</span>  <span class="keyword">fn*</span> aux1 <span class="keyword">(</span>d1e<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">,</span> ns<span class="keyword">:</span> <span class="staexp">List int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> ns <span class="keyword">of</span> list_cons <span class="keyword">(</span>n<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux2 <span class="keyword">(</span>d1e<span class="keyword">,</span> n<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">end</span> <span class="comment">// end of [aux1]
</span><span class="comment">//
</span>  <span class="keyword">and</span> aux2 <span class="keyword">(</span>d1e<span class="keyword">:</span> <span class="staexp">d1exp</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> ns<span class="keyword">:</span> <span class="staexp">List int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">begin</span>
<span class="comment">(*
    print "d1exp_arith_check: n = "; print n; print_newline ();
    print "d1exp_arith_check: d1e = "; print_d1exp d1e; print_newline ();
*)</span>
    <span class="keyword">case+</span> d1e<span class="keyword">.</span>d1exp_node <span class="keyword">of</span>
    <span class="keyword">|</span> D1Elam_dyn <span class="keyword">(</span>_<span class="comment">(*lin*)</span><span class="keyword">,</span> p1t<span class="keyword">,</span> d1e<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> narg <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> p1t<span class="keyword">.</span>p1at_node <span class="keyword">of</span>
          <span class="keyword">|</span> P1Tlist <span class="keyword">(</span>_<span class="comment">(*npf*)</span><span class="keyword">,</span> p1ts<span class="keyword">)</span> <span class="keyword">=&gt;</span> $Lst<span class="keyword">.</span>list_length <span class="keyword">(</span>p1ts<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> 1
        <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>n <span class="keyword">=</span> narg<span class="keyword">)</span> <span class="keyword">then</span> aux1 <span class="keyword">(</span>d1e<span class="keyword">,</span> ns<span class="keyword">)</span> <span class="keyword">else</span> false
      <span class="keyword">end</span> <span class="comment">// end of [D1Elam_dyn]
</span>    <span class="keyword">|</span> D1Elam_met <span class="keyword">(</span>_<span class="comment">(*loc*)</span><span class="keyword">,</span> _<span class="comment">(*met*)</span><span class="keyword">,</span> d1e<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux2 <span class="keyword">(</span>d1e<span class="keyword">,</span> n<span class="keyword">,</span> ns<span class="keyword">)</span>
    <span class="keyword">|</span> D1Elam_sta_ana <span class="keyword">(</span>_<span class="comment">(*loc*)</span><span class="keyword">,</span> _<span class="comment">(*s1as*)</span><span class="keyword">,</span> d1e<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux2 <span class="keyword">(</span>d1e<span class="keyword">,</span> n<span class="keyword">,</span> ns<span class="keyword">)</span>
    <span class="keyword">|</span> D1Elam_sta_syn <span class="keyword">(</span>_<span class="comment">(*loc*)</span><span class="keyword">,</span> _<span class="comment">(*s1qs*)</span><span class="keyword">,</span> d1e<span class="keyword">)</span> <span class="keyword">=&gt;</span> aux2 <span class="keyword">(</span>d1e<span class="keyword">,</span> n<span class="keyword">,</span> ns<span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> false
  <span class="keyword">end</span> <span class="comment">// end of [aux2]
</span><span class="comment">//
</span><span class="keyword">in</span>
  aux1 <span class="keyword">(</span>d1e<span class="keyword">,</span> ns<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [d1exp_arity_check]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> i1mpdec_tr_d2cst_select
  <span class="keyword">(</span>d1c<span class="keyword">:</span> <span class="staexp">i1mpdec</span><span class="keyword">,</span> d2is<span class="keyword">:</span> <span class="staexp">d2itemlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">d2cst_t</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>d2is<span class="keyword">:</span> <span class="staexp">d2itemlst</span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">d2cstlst_vt</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2is <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2i<span class="keyword">,</span> d2is<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2i <span class="keyword">of</span>
      <span class="keyword">|</span> D2ITEMcst d2c <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> ns <span class="keyword">=</span> d2cst_arilst_get <span class="keyword">(</span>d2c<span class="keyword">)</span>
          <span class="keyword">val</span> ismat <span class="keyword">=</span> d1exp_arity_check <span class="keyword">(</span>d1c<span class="keyword">.</span>i1mpdec_def<span class="keyword">,</span> ns<span class="keyword">)</span>
        <span class="keyword">in</span> 
          <span class="keyword">if</span> <span class="keyword">(</span>ismat<span class="keyword">)</span> <span class="keyword">then</span> list_vt_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> aux d2is<span class="keyword">)</span> <span class="keyword">else</span> aux d2is
        <span class="keyword">end</span>
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> aux d2is
      <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span>  <span class="keyword">val</span> d2cs <span class="keyword">=</span> aux <span class="keyword">(</span>d2is<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons <span class="keyword">(</span>d2c1<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2c1
    <span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons <span class="keyword">(</span>d2c2<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> qid <span class="keyword">=</span> d1c<span class="keyword">.</span>i1mpdec_qid
        <span class="keyword">val</span> q <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_qua <span class="keyword">and</span> id <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_sym
      <span class="keyword">in</span>
        prerr_loc_error2 d1c<span class="keyword">.</span>i1mpdec_loc<span class="keyword">;</span>
        prerr ": the dynamic constants ["<span class="keyword">;</span>
        prerr d2c1<span class="keyword">;</span> prerr "] and ["<span class="keyword">;</span>
        prerr d2c2<span class="keyword">;</span> prerr "] cannot be resolved for ["<span class="keyword">;</span>
        $Syn<span class="keyword">.</span>prerr_d0ynq q<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol id<span class="keyword">;</span> prerr "]."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Lst<span class="keyword">.</span>list_vt_free__boxed <span class="keyword">(</span>d2cs<span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2cst_t<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]
</span>    <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]
</span>  <span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> qid <span class="keyword">=</span> d1c<span class="keyword">.</span>i1mpdec_qid
      <span class="keyword">val</span> q <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_qua <span class="keyword">and</span> id <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_sym
    <span class="keyword">in</span>
      prerr_loc_error2 d1c<span class="keyword">.</span>i1mpdec_loc<span class="keyword">;</span>
      prerr ": no dynamic constant can be found for ["<span class="keyword">;</span>
      $Syn<span class="keyword">.</span>prerr_d0ynq q<span class="keyword">;</span> $Sym<span class="keyword">.</span>prerr_symbol id<span class="keyword">;</span> prerr "]."<span class="keyword">;</span>
      prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
      $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2cst_t<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_vt_nil]
</span><span class="keyword">end</span> <span class="comment">// end of [i1mpdec_tr_d2cst_select]
</span>
<span class="keyword">fn</span> i1mpdec_tr
  <span class="keyword">(</span>loc0<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> i1mparg<span class="keyword">:</span> <span class="staexp">s1arglstlst</span><span class="keyword">,</span> d1c<span class="keyword">:</span> <span class="staexp">i1mpdec</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">i2mpdec</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> t1mparg <span class="keyword">=</span> d1c<span class="keyword">.</span>i1mpdec_tmparg
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> <span class="keyword">(</span>i1mparg<span class="keyword">,</span> t1mparg<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>cons _<span class="keyword">,</span> cons _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_error2 loc0<span class="keyword">;</span>
        prerr ": template implementation and instantiation may not be combined."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons, cons]
</span>    <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> qid <span class="keyword">=</span> d1c<span class="keyword">.</span>i1mpdec_qid
  <span class="keyword">val</span> q <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_qua <span class="keyword">and</span> id <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_sym
  <span class="keyword">val</span> d2c <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> the_d2expenv_find_qua <span class="keyword">(</span>q<span class="keyword">,</span> id<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>Some_vt d2i <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> d2i <span class="keyword">of</span>
      <span class="keyword">|</span> D2ITEMcst d2c <span class="keyword">=&gt;</span> d2c
      <span class="keyword">|</span> D2ITEMsymdef <span class="keyword">(</span>d2is<span class="keyword">)</span> <span class="keyword">=&gt;</span> i1mpdec_tr_d2cst_select <span class="keyword">(</span>d1c<span class="keyword">,</span> d2is<span class="keyword">)</span>
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_error2 d1c<span class="keyword">.</span>i1mpdec_loc<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the identifier ["<span class="keyword">;</span>
          prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
          prerr "] should refer to a dynamic constant but it does not."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2cst_t<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [_]
</span>      <span class="keyword">end</span> <span class="comment">(* end of [Some_vt] *)</span>
    <span class="keyword">|</span> <span class="keyword">~</span>None_vt <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        prerr_loc_error2 d1c<span class="keyword">.</span>i1mpdec_loc<span class="keyword">;</span>
        $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
        prerr ": the dynamic identifier ["<span class="keyword">;</span>
        prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
        prerr "] is unrecognized."<span class="keyword">;</span>
        prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
        $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>d2cst_t<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [None_vt]
</span>  <span class="keyword">end</span> <span class="comment">// end of [val]
</span><span class="comment">//
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> dyncstimploc_posmark <span class="keyword">(</span>qid<span class="keyword">.</span>impqi0de_loc<span class="keyword">,</span> d2c<span class="keyword">)</span>
<span class="comment">//
</span><span class="comment">(*
  // automatic instantiation is not supported because it can readily
  // lead to confusion as to whether an implementation is actually compiled.
  fun aux1
    (s2vpss: s2qualst, s2e: s2exp, out: &amp;s2qualst): s2exp = begin
    case+ s2vpss of
    | cons (s2vps, s2vpss) =&gt; let
        val (sub, s2vs) = stasub_extend_svarlst (stasub_nil, s2vps.0)
        val s2ps = s2explst_subst (sub, s2vps.1)
        val s2e = s2exp_subst (sub, s2e)
      in
        out := @(s2vs, s2ps) :: out; aux1 (s2vpss, s2e, out)
      end
    | nil () =&gt; (out := s2qualst_reverse out; s2e)
  end // end of [aux1]
*)</span>
  <span class="keyword">fun</span> aux2_imp <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> args<span class="keyword">:</span> <span class="staexp">s1arglstlst</span>
    <span class="keyword">,</span> s2vpss<span class="keyword">:</span> <span class="staexp">s2qualst</span>
    <span class="keyword">,</span> s2e<span class="keyword">:</span> <span class="staexp">s2exp</span>
    <span class="keyword">,</span> out_imp<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>s2qualst</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">s2exp</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> s2vpss <span class="keyword">of</span>
      <span class="keyword">|</span> cons <span class="keyword">(</span>s2vps<span class="keyword">,</span> s2vpss<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">var</span> sub<span class="keyword">:</span> <span class="staexp">stasub_t</span> <span class="keyword">=</span> stasub_nil
          <span class="keyword">val</span> s2vs <span class="keyword">=</span> s1arglst_bind_svarlst <span class="keyword">(</span>loc0<span class="keyword">,</span> arg<span class="keyword">,</span> s2vps<span class="keyword">.</span>0<span class="keyword">,</span> sub<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_add_svarlst s2vs
          <span class="keyword">val</span> s2ps <span class="keyword">=</span> s2explst_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2vps<span class="keyword">.</span>1<span class="keyword">)</span>
          <span class="keyword">val</span> s2e <span class="keyword">=</span> s2exp_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2e<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> out_imp := <span class="keyword">@(</span>s2vs<span class="keyword">,</span> s2ps<span class="keyword">)</span> :: out_imp
        <span class="keyword">in</span>
          aux2_imp <span class="keyword">(</span>loc0<span class="keyword">,</span> args<span class="keyword">,</span> s2vpss<span class="keyword">,</span> s2e<span class="keyword">,</span> out_imp<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>      <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_error2 loc0<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr: aux2_imp"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the implementation for ["<span class="keyword">;</span>
          prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
          prerr "] should be applied to less template arguments."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>s2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [nil]
</span>      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> s2vpss <span class="keyword">of</span>
          <span class="keyword">|</span> cons _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
              prerr_loc_error2 loc0<span class="keyword">;</span>
              $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr: aux2_imp"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
              prerr ": the implementation for ["<span class="keyword">;</span>
              prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
              prerr "] should be applied to more template arguments."<span class="keyword">;</span>
              prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
              $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>          <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">in</span>
        s2e <span class="comment">// no automatic instantiation
</span>      <span class="keyword">end</span> <span class="comment">// end of [nil]
</span>  <span class="keyword">end</span> <span class="comment">// end of [aux2_imp]
</span>  <span class="keyword">fun</span> aux2_tmp <span class="keyword">(</span>
      loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
    <span class="keyword">,</span> args<span class="keyword">:</span> <span class="staexp">s1explstlst</span>
    <span class="keyword">,</span> s2vpss<span class="keyword">:</span> <span class="staexp">s2qualst</span>
    <span class="keyword">,</span> s2e<span class="keyword">:</span> <span class="staexp">s2exp</span>
    <span class="keyword">,</span> out_tmparg<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>s2explstlst</span>
    <span class="keyword">,</span> out_tmpgua<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>s2explstlst</span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloptr1</span><span class="keyword">&gt;</span> <span class="staexp">s2exp</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> args <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>arg<span class="keyword">,</span> args<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> s2vpss <span class="keyword">of</span>
      <span class="keyword">|</span> cons <span class="keyword">(</span>s2vps<span class="keyword">,</span> s2vpss<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">var</span> sub<span class="keyword">:</span> <span class="staexp">stasub_t</span> <span class="keyword">=</span> stasub_nil
          <span class="keyword">val</span> s2es <span class="keyword">=</span> s1explst_bind_svarlst <span class="keyword">(</span>loc0<span class="keyword">,</span> arg<span class="keyword">,</span> s2vps<span class="keyword">.</span>0<span class="keyword">,</span> sub<span class="keyword">)</span>
          <span class="keyword">val</span> s2ps <span class="keyword">=</span> s2explst_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2vps<span class="keyword">.</span>1<span class="keyword">)</span>
          <span class="keyword">val</span> s2e <span class="keyword">=</span> s2exp_subst <span class="keyword">(</span>sub<span class="keyword">,</span> s2e<span class="keyword">)</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> out_tmparg := s2es :: out_tmparg
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> out_tmpgua := s2ps :: out_tmpgua
        <span class="keyword">in</span>
          aux2_tmp <span class="keyword">(</span>loc0<span class="keyword">,</span> args<span class="keyword">,</span> s2vpss<span class="keyword">,</span> s2e<span class="keyword">,</span> out_tmparg<span class="keyword">,</span> out_tmpgua<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>      <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_error2 loc0<span class="keyword">;</span>
          $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr: aux2_tmp"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
          prerr ": the implementation for ["<span class="keyword">;</span>
          prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
          prerr "] should be applied to less template arguments."<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>s2exp<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [nil]
</span>      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> s2vpss <span class="keyword">of</span>
          <span class="keyword">|</span> cons _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
              prerr_loc_error2 loc0<span class="keyword">;</span>
              $Deb<span class="keyword">.</span>debug_prerrf <span class="keyword">(</span>": %s: i1mpdec_tr: aux2_tmp"<span class="keyword">,</span> <span class="keyword">@(</span>THISFILENAME<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
              prerr ": the implementation for ["<span class="keyword">;</span>
              prerr q<span class="keyword">;</span> prerr id<span class="keyword">;</span>
              prerr "] should be applied to more template arguments."<span class="keyword">;</span>
              prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
              $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>          <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">in</span>
        s2e <span class="comment">// no automatic instantiation
</span>      <span class="keyword">end</span> <span class="comment">// end of [nil]
</span>  <span class="keyword">end</span> <span class="comment">// end of [aux2_tmp]
</span>  <span class="keyword">val</span> loc_id <span class="keyword">=</span> qid<span class="keyword">.</span>impqi0de_loc
  <span class="keyword">val</span> decarg <span class="keyword">=</span> d2cst_decarg_get d2c <span class="keyword">and</span> s2e_d2c <span class="keyword">=</span> d2cst_typ_get d2c
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> decarg <span class="keyword">of</span>
    <span class="keyword">|</span> cons _ <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">(</span>i1mparg<span class="keyword">,</span> t1mparg<span class="keyword">)</span> <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          prerr_loc_error2 loc0<span class="keyword">;</span>
          prerr ": the dynamic constant ["<span class="keyword">;</span>
          prerr d2c<span class="keyword">;</span> prerr "] requires a template implementation"<span class="keyword">;</span>
          prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
          $Err<span class="keyword">.</span>abort <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [nil, nil]
</span>      <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">var</span> out_imp<span class="keyword">:</span> <span class="staexp">s2qualst</span> <span class="keyword">=</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> out_tmparg<span class="keyword">:</span> <span class="staexp">s2explstlst</span> <span class="keyword">=</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> out_tmpgua<span class="keyword">:</span> <span class="staexp">s2explstlst</span> <span class="keyword">=</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> s2e <span class="keyword">=</span> s2e_d2c
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_push <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> decarg <span class="keyword">of</span> cons _ <span class="keyword">=&gt;</span> template_level_inc <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> nil _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> s2e <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> i1mparg <span class="keyword">of</span>
    <span class="keyword">|</span> cons _ <span class="keyword">=&gt;</span> aux2_imp <span class="keyword">(</span>loc_id<span class="keyword">,</span> i1mparg<span class="keyword">,</span> decarg<span class="keyword">,</span> s2e<span class="keyword">,</span> out_imp<span class="keyword">)</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> s2e
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2exp</span>
  <span class="keyword">val</span> s2e <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> t1mparg <span class="keyword">of</span>
    <span class="keyword">|</span> cons _ <span class="keyword">=&gt;</span> aux2_tmp
        <span class="keyword">(</span>loc_id<span class="keyword">,</span> t1mparg<span class="keyword">,</span> decarg<span class="keyword">,</span> s2e<span class="keyword">,</span> out_tmparg<span class="keyword">,</span> out_tmpgua<span class="keyword">)</span>
    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> s2e
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">s2exp</span>        
<span class="comment">(*
// val out_imp = $Lst.list_reverse (out_imp) // HX: a serious bug!!!
*)</span>
  <span class="keyword">val</span> out_imp <span class="keyword">=</span> s2qualst_reverse <span class="keyword">(</span>out_imp<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> s2qualst_tmplev_set <span class="keyword">(</span>out_imp<span class="keyword">,</span> template_level_get <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">val</span> out_tmparg <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_reverse <span class="keyword">(</span>out_tmparg<span class="keyword">:</span> <span class="staexp">s2explstlst</span><span class="keyword">)</span>
  <span class="keyword">val</span> out_tmpgua <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_reverse <span class="keyword">(</span>out_tmpgua<span class="keyword">:</span> <span class="staexp">s2explstlst</span><span class="keyword">)</span>
  <span class="keyword">val</span> s2e <span class="keyword">=</span> s2exp_whnf <span class="keyword">(</span>s2e<span class="keyword">)</span>
  <span class="keyword">val</span> d2e <span class="keyword">=</span> d1exp_tr_ann <span class="keyword">(</span>d1c<span class="keyword">.</span>i1mpdec_def<span class="keyword">,</span> s2e<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> decarg <span class="keyword">of</span> cons _ <span class="keyword">=&gt;</span> template_level_dec <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> nil _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_pop <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2cst_def_set <span class="keyword">(</span>d2c<span class="keyword">,</span> Some d2e<span class="keyword">)</span>
<span class="keyword">in</span>
  i2mpdec_make <span class="keyword">(</span>
    d1c<span class="keyword">.</span>i1mpdec_loc<span class="keyword">,</span> loc_id<span class="keyword">,</span> d2c<span class="keyword">,</span> out_imp<span class="keyword">,</span> out_tmparg<span class="keyword">,</span> out_tmpgua<span class="keyword">,</span> d2e
  <span class="keyword">)</span> <span class="comment">// end of [i2mpdec_make]
</span><span class="keyword">end</span> <span class="comment">// end of [i1mpdec_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> s1taload_tr <span class="keyword">(</span>
    loc0<span class="keyword">:</span> <span class="staexp">loc_t</span>
  <span class="keyword">,</span> idopt<span class="keyword">:</span> <span class="staexp">symopt_t</span><span class="keyword">,</span> fil<span class="keyword">:</span> <span class="staexp">fil_t</span><span class="keyword">,</span> loaded<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> d1cs<span class="keyword">:</span> <span class="staexp">d1eclst</span>
  <span class="keyword">,</span> loadflag<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">,</span> d2cs_loaded<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>d2eclst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2ec</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">(*
  val () = print "s1taload_tr: staid = "
  val () = case+ idopt of
    | Some id =&gt; $Sym.print_symbol id | None () =&gt; print "None"
  // end of [val]
  val () = print_newline ()
  val () = begin
    print "s1taload_tr: filename = "; $Fil.print_filename fil;
    print_newline ()
  end // end of [val]
*)</span>
  <span class="keyword">val</span> fil_sym <span class="keyword">=</span> $Fil<span class="keyword">.</span>filename_full_sym fil
  <span class="keyword">var</span> loaded<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_token</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> staload_level_push <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> qua <span class="keyword">=</span> <span class="comment">// qualified, that is, closed
</span>    <span class="keyword">(</span><span class="keyword">case+</span> idopt <span class="keyword">of</span> Some _ <span class="keyword">=&gt;</span> 1 <span class="keyword">|</span> None _ <span class="keyword">=&gt;</span> 0<span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span>
  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> ans <span class="keyword">=</span> d2eclst_namespace_find fil_sym
  <span class="keyword">val</span> d2cs <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> ans <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>Some_vt d2cs <span class="keyword">=&gt;</span> <span class="keyword">(</span>loaded := 1<span class="keyword">;</span> d2cs<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">~</span>None_vt _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_save <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//
</span>        <span class="keyword">val</span> flag <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_pause_get <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">val</span> d2cs <span class="keyword">=</span> d1eclst_tr d1cs
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2cs_loaded := d2cs
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_resume_set <span class="keyword">(</span>flag<span class="keyword">)</span>
<span class="comment">//
</span>        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_namespace_add_topenv <span class="keyword">(</span>fil_sym<span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_restore <span class="keyword">(</span><span class="keyword">)</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2eclst_namespace_add <span class="keyword">(</span>fil_sym<span class="keyword">,</span> d2cs<span class="keyword">)</span>
      <span class="keyword">in</span>
        d2cs
      <span class="keyword">end</span> <span class="comment">// end of [None_vt]
</span>  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">d2eclst</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> d2cs_loaded := d2cs
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> idopt <span class="keyword">of</span>
    <span class="keyword">|</span> Some id <span class="keyword">=&gt;</span> the_s2expenv_add <span class="keyword">(</span>id<span class="keyword">,</span> S2ITEMfil fil<span class="keyword">)</span>
    <span class="keyword">|</span> None <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        $NS<span class="keyword">.</span>the_namespace_add fil_sym <span class="comment">(* opened file *)</span>
      <span class="keyword">end</span> <span class="comment">// end of [None]
</span>  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> staload_level_pop <span class="keyword">(</span><span class="prfexp">pf_token</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">in</span>
  d2ec_staload <span class="keyword">(</span>loc0<span class="keyword">,</span> qua<span class="keyword">,</span> fil<span class="keyword">,</span> loaded<span class="keyword">,</span> loadflag<span class="keyword">,</span> d2cs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [s1taload_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
overload_d2eclst_tr <span class="keyword">(</span>d2cs<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> d2cs <span class="keyword">of</span>
  <span class="keyword">|</span> list_cons <span class="keyword">(</span>d2c<span class="keyword">,</span> d2cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> d2c<span class="keyword">.</span>d2ec_node <span class="keyword">of</span>
        <span class="keyword">|</span> D2Csymintr ids <span class="keyword">=&gt;</span> symintr_tr <span class="keyword">(</span>ids<span class="keyword">)</span>
<span class="comment">(*
        | D2Csymelim ids =&gt; symelim_tr (ids) // is this really needed?
*)</span>
        <span class="keyword">|</span> D2Coverload <span class="keyword">(</span>id<span class="keyword">,</span> d2i<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">(*
            val () = begin
              print "overload_d2eclst_tr: id = "; $Syn.print_i0de id; print_newline ();
              print "overload_d2eclst_tr: d2i = "; print_d2item d2i; print_newline ();
            end // end of [D2Coverload]
*)</span>
          <span class="keyword">in</span>
            overload_def_tr <span class="keyword">(</span>id<span class="keyword">,</span> d2i<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [D2Coverload]
</span>        <span class="keyword">|</span> D2Cinclude d2cs_include <span class="keyword">=&gt;</span> overload_d2eclst_tr d2cs_include
        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="comment">// end of [val]
</span>    <span class="keyword">in</span>
      overload_d2eclst_tr <span class="keyword">(</span>d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>  <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [overload_d2eclst_tr]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
d1ec_tr <span class="keyword">(</span>d1c0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> d1c0<span class="keyword">.</span>d1ec_node <span class="keyword">of</span>
  <span class="keyword">|</span> D1Cnone <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
  <span class="keyword">|</span> D1Clist d1cs <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d2ec_list <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d1eclst_tr d1cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Clist]
</span>  <span class="keyword">|</span> D1Cinclude d1cs <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> flag <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_pause_get <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> d1eclst_tr d1cs
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $PM<span class="keyword">.</span>posmark_resume_set <span class="keyword">(</span>flag<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_include <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cinclude]
</span>  <span class="keyword">|</span> D1Csymintr ids <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> symintr_tr <span class="keyword">(</span>ids<span class="keyword">)</span> <span class="keyword">in</span>
      d2ec_symintr <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> ids<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Csymintr]
</span>  <span class="keyword">|</span> D1Csymelim ids <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> symelim_tr <span class="keyword">(</span>ids<span class="keyword">)</span> <span class="keyword">in</span>
      d2ec_symelim <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> ids<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Csymelim]
</span>  <span class="keyword">|</span> D1Ce1xpdef <span class="keyword">(</span>id<span class="keyword">,</span> def<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      the_s2expenv_add <span class="keyword">(</span>id<span class="keyword">,</span> S2ITEMe1xp def<span class="keyword">)</span><span class="keyword">;</span>
      the_d2expenv_add <span class="keyword">(</span>id<span class="keyword">,</span> D2ITEMe1xp def<span class="keyword">)</span><span class="keyword">;</span>
      d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Ce1xpdef]
</span>  <span class="keyword">|</span> D1Cdatsrts <span class="keyword">(</span>para<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d1atsrtdeclst_tr d1cs<span class="keyword">;</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cdatsrts]
</span>  <span class="keyword">|</span> D1Csrtdefs d1cs <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      s1rtdeflst_tr d1cs<span class="keyword">;</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Csrtdefs]
</span>  <span class="keyword">|</span> D1Cstacons <span class="keyword">(</span>absknd<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      s1taconlst_tr <span class="keyword">(</span>absknd<span class="keyword">,</span> d1cs<span class="keyword">)</span><span class="keyword">;</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cstacons]
</span>  <span class="keyword">|</span> D1Cstacsts d1cs <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      s1tacstlst_tr d1cs<span class="keyword">;</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cstacsts]
</span>  <span class="keyword">|</span> D1Cstavars d1cs <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> s1tavarlst_tr d1cs <span class="keyword">in</span>
      d2ec_stavars <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cstavars]
</span>  <span class="keyword">|</span> D1Csexpdefs <span class="keyword">(</span>os1t<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2c <span class="keyword">where</span> <span class="keyword">{</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> s1expdeflst_tr <span class="keyword">(</span>s1rtopt_tr os1t<span class="keyword">,</span> d1cs<span class="keyword">)</span>
      <span class="keyword">val</span> d2c <span class="keyword">=</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">}</span> <span class="comment">// end of [D1Csexpdefs]
</span>  <span class="keyword">|</span> D1Csaspdec <span class="keyword">(</span>d1c<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d2ec_saspdec <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> s1aspdec_tr d1c<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Csaspdec]
</span>  <span class="keyword">|</span> D1Cdcstdecs <span class="keyword">(</span>dck<span class="keyword">,</span> decarg<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_push <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> s2vpss <span class="keyword">=</span> s1qualstlst_tr <span class="keyword">(</span>decarg<span class="keyword">)</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> d1cstdeclst_tr <span class="keyword">(</span>dck<span class="keyword">,</span> s2vpss<span class="keyword">,</span> d1cs<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_pop <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_dcstdec <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> dck<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cdcstdecs]
</span>  <span class="keyword">|</span> D1Cdatdecs <span class="keyword">(</span>dtk<span class="keyword">,</span> d1cs_dat<span class="keyword">,</span> d1cs_def<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> s2cs <span class="keyword">=</span> d1atdeclst_tr <span class="keyword">(</span>dtk<span class="keyword">,</span> d1cs_dat<span class="keyword">,</span> d1cs_def<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_datdec <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> dtk<span class="keyword">,</span> s2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cdatdecs]
</span>  <span class="keyword">|</span> D1Cexndecs <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> e1xndeclst_tr d1cs <span class="keyword">in</span>
      d2ec_exndec <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cexndecs]
</span>  <span class="keyword">|</span> D1Cclassdec <span class="keyword">(</span>id<span class="keyword">,</span> sup<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> c1lassdec_tr <span class="keyword">(</span>id<span class="keyword">,</span> sup<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cclassdec]
</span>  <span class="keyword">|</span> D1Coverload <span class="keyword">(</span>id<span class="keyword">,</span> qid<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2i <span class="keyword">=</span> overload_tr <span class="keyword">(</span>id<span class="keyword">,</span> qid<span class="keyword">)</span> <span class="keyword">in</span>
      d2ec_overload <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> id<span class="keyword">,</span> d2i<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Coverload]
</span>  <span class="keyword">|</span> D1Cextype <span class="keyword">(</span>name<span class="keyword">,</span> s1e_def<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> s2e_def <span class="keyword">=</span> s1exp_tr_dn_viewt0ype s1e_def
    <span class="keyword">in</span>
      d2ec_extype <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> name<span class="keyword">,</span> s2e_def<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cextype]
</span>  <span class="keyword">|</span> D1Cextval <span class="keyword">(</span>name<span class="keyword">,</span> d1e_def<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d2ec_extval <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> name<span class="keyword">,</span> d1exp_tr d1e_def<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cextval]
</span>  <span class="keyword">|</span> D1Cextcode <span class="keyword">(</span>pos<span class="keyword">,</span> code<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      d2ec_extcode <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> pos<span class="keyword">,</span> code<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cextcode]
</span>  <span class="keyword">|</span> D1Cvaldecs <span class="keyword">(</span>valknd<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> v1aldeclst_tr <span class="keyword">(</span>false<span class="comment">(*isrec*)</span><span class="keyword">,</span> d1cs<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_valdecs <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> valknd<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cvaldecs]
</span>  <span class="keyword">|</span> D1Cvaldecs_par <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> v1aldeclst_tr <span class="keyword">(</span>false<span class="comment">(*isrec*)</span><span class="keyword">,</span> d1cs<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_valdecs_par <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cvaldecs_par]
</span>  <span class="keyword">|</span> D1Cvaldecs_rec <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> v1aldeclst_tr <span class="keyword">(</span>true<span class="comment">(*isrec*)</span><span class="keyword">,</span> d1cs<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_valdecs_rec <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cvaldecs_rec]
</span>  <span class="keyword">|</span> D1Cfundecs <span class="keyword">(</span>funknd<span class="keyword">,</span> decarg<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_push <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
        <span class="keyword">case+</span> decarg <span class="keyword">of</span> cons _ <span class="keyword">=&gt;</span> template_level_inc <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> nil _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> s2vpss <span class="keyword">=</span> s1qualstlst_tr <span class="keyword">(</span>decarg<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> s2qualst_tmplev_set <span class="keyword">(</span>s2vpss<span class="keyword">,</span> template_level_get <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">val</span> level <span class="keyword">=</span> d2var_current_level_get <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> f1undeclst_tr <span class="keyword">(</span>funknd<span class="keyword">,</span> level<span class="keyword">,</span> s2vpss<span class="keyword">,</span> d1cs<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> the_s2expenv_pop <span class="keyword">(</span><span class="prfexp">pf_s2expenv</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
        <span class="keyword">case+</span> decarg <span class="keyword">of</span> cons _ <span class="keyword">=&gt;</span> template_level_dec <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> nil _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [val]
</span>    <span class="keyword">in</span>
      d2ec_fundecs <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> s2vpss<span class="keyword">,</span> funknd<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cfundecs]
</span>  <span class="keyword">|</span> D1Cvardecs <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> d2cs <span class="keyword">=</span> v1ardeclst_tr d1cs
    <span class="keyword">in</span>
      d2ec_vardecs <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cvardecs]
</span>  <span class="keyword">|</span> D1Cmacdefs <span class="keyword">(</span>knd<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
       <span class="comment">// knd: 0/1/2 =&gt; short/long/long rec
</span>       <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> m1acdeflst_tr <span class="keyword">(</span>knd<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">in</span> d2ec_none <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cmacdefs]
</span>  <span class="keyword">|</span> D1Cimpdec <span class="keyword">(</span>i1mparg<span class="keyword">,</span> d1c<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> loc0 <span class="keyword">=</span> d1c0<span class="keyword">.</span>d1ec_loc
      <span class="keyword">val</span> d2c <span class="keyword">=</span> i1mpdec_tr <span class="keyword">(</span>loc0<span class="keyword">,</span> i1mparg<span class="keyword">,</span> d1c<span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_impdec <span class="keyword">(</span>loc0<span class="keyword">,</span> d2c<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Cimpdec]
</span>  <span class="keyword">|</span> D1Clocal <span class="keyword">(</span>d1cs_head<span class="keyword">,</span> d1cs_body<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf1_env</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_push <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> d2cs_head <span class="keyword">=</span> d1eclst_tr d1cs_head
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf2_env</span> <span class="keyword">|</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_push <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> d2cs_body <span class="keyword">=</span> d1eclst_tr d1cs_body
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trans2_env_localjoin <span class="keyword">(</span><span class="prfexp">pf1_env</span><span class="keyword">,</span> <span class="prfexp">pf2_env</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      d2ec_local <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> d2cs_head<span class="keyword">,</span> d2cs_body<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [D1Clocal]
</span>  <span class="keyword">|</span> D1Cdynload <span class="keyword">(</span>fil<span class="keyword">)</span> <span class="keyword">=&gt;</span> d2ec_dynload <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> fil<span class="keyword">)</span>
  <span class="keyword">|</span> D1Cstaload <span class="keyword">(</span>idopt<span class="keyword">,</span> fil<span class="keyword">,</span> loaded<span class="keyword">,</span> loadflag<span class="keyword">,</span> d1cs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">var</span> d2cs_loaded<span class="keyword">:</span> <span class="staexp">d2eclst</span> <span class="keyword">=</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> d2c0 <span class="keyword">=</span> s1taload_tr
        <span class="keyword">(</span>d1c0<span class="keyword">.</span>d1ec_loc<span class="keyword">,</span> idopt<span class="keyword">,</span> fil<span class="keyword">,</span> loaded<span class="keyword">,</span> d1cs<span class="keyword">,</span> loadflag<span class="keyword">,</span> d2cs_loaded<span class="keyword">)</span>
      <span class="comment">// end of [val]
</span>      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> idopt <span class="keyword">of</span>
        <span class="keyword">|</span> None _ <span class="keyword">=&gt;</span> overload_d2eclst_tr <span class="keyword">(</span>d2cs_loaded<span class="keyword">)</span> <span class="keyword">|</span> Some _ <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="comment">(*named*)</span><span class="keyword">)</span>
      <span class="comment">// end of [val]
</span>    <span class="keyword">in</span>
      d2c0
    <span class="keyword">end</span> <span class="comment">// end of [D1Cstaload]
</span><span class="comment">(*
  | _ =&gt; begin
      prerr_loc_interror d1c0.d1ec_loc;
      prerr ": d1ec_tr: not available yet.\n";
      $Err.abort {d2ec} ()
    end // end of [_]
*)</span>
<span class="keyword">end</span> <span class="comment">// end of [d1ec_tr]
</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//
</span><span class="comment">// HX: [list_map_fun] is tail-recursive!
</span><span class="comment">//
</span><span class="keyword">implement</span>
d1eclst_tr <span class="keyword">(</span>d1cs<span class="keyword">)</span> <span class="keyword">=</span> $Lst<span class="keyword">.</span>list_map_fun <span class="keyword">(</span>d1cs<span class="keyword">,</span> d1ec_tr<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_trans2_dyn2.dats] *)</span>
</pre>
</body>
</html>
