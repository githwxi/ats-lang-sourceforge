<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    span.comment {color:#787878;font-style:italic}
    span.extern  {color:#A52A2A}
    span.keyword {color:#000000;font-weight:bold}
    span.neuexp  {color:#800080}
    span.staexp  {color:#0000FF}
    span.dynexp  {color:#E80000}
    span.prfexp  {color:#009000}
    span.stacstdec  {text-decoration:none}
    span.stacstuse  {color:#0000CF;text-decoration:underline}
    span.dyncstdec  {text-decoration:none}
    span.dyncstimp  {color:#B80000;text-decoration:underline}
    span.dyncstuse  {color:#B80000;text-decoration:underline}
    body          {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<body>
<pre>
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                              Hongwei Xi                             *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Anairiats - Unleashing the Potential of Types!
**
** Copyright (C) 2002-2008 Hongwei Xi, Boston University
**
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
</span><span class="comment">// Time: August 2007
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* ats_effect: for handing effects *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">Err <span class="keyword">=</span> "ats_error.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Loc <span class="keyword">=</span> "ats_location.sats"</span>
<span class="keyword">staload</span> <span class="staexp">Syn <span class="keyword">=</span> "ats_syntax.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> <span class="staexp">"ats_effect.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">nil list_nil</span>
<span class="keyword">#define</span> <span class="neuexp">:: list_cons</span>
<span class="keyword">#define</span> <span class="neuexp">cons list_cons</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><a name="1838"><span class="stacstdec">t0kn <span class="keyword">=</span> $Syn<span class="keyword">.</span>t0kn</span></a></span>
<span class="keyword">typedef</span> <span class="staexp"><a name="1863"><span class="stacstdec">funclo <span class="keyword">=</span> $Syn<span class="keyword">.</span>funclo</span></a></span>
<span class="keyword">typedef</span> <span class="staexp"><a name="1892"><span class="stacstdec">funcloopt <span class="keyword">=</span> $Syn<span class="keyword">.</span>funcloopt</span></a></span>
<span class="keyword">typedef</span> <span class="staexp"><a name="1927"><span class="stacstdec">loc_t <span class="keyword">=</span> $Loc<span class="keyword">.</span>location_t</span></a></span>

<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> $Loc<span class="keyword">.</span>prerr_location</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><a name="2043"><span class="stacstdec">effect <span class="keyword">=</span> int</span></a></span>
<span class="keyword">assume</span> <span class="staexp">$Syn<span class="keyword">.</span>effect_t <span class="keyword">=</span> effect</span>
<span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="staexp">"atsopt_effect_t" <span class="keyword">=</span> effect</span>

<span class="comment">// the maximal effect number
</span><span class="keyword">#define</span> <span class="neuexp">MAX_EFFECT_NUMBER 3</span>
<span class="comment">// #assert (MAX_EFFECT_NUMBER &lt;= __WORDSIZE)
</span>
<span class="keyword">macdef</span> <span class="neuexp">EFFexn <span class="keyword">=</span> 1</span> <span class="comment">// exception
</span><span class="keyword">macdef</span> <span class="neuexp">EFFntm <span class="keyword">=</span> 2</span> <span class="comment">// nontermination
</span><span class="keyword">macdef</span> <span class="neuexp">EFFref <span class="keyword">=</span> 3</span> <span class="comment">// reference
</span><span class="comment">// macdef EFFwrt = 4 // not supported
</span>
<span class="keyword">implement</span> effect_exn <span class="keyword">=</span> EFFexn
<span class="keyword">implement</span> effect_ntm <span class="keyword">=</span> EFFntm
<span class="keyword">implement</span> effect_ref <span class="keyword">=</span> EFFref
<span class="comment">// implement effect_wrt = EFFwrt // not supported
</span><span class="keyword">implement</span> effectlst_all <span class="keyword">=</span> <span class="keyword">'[</span> EFFexn<span class="keyword">,</span> EFFntm<span class="keyword">,</span> EFFref <span class="keyword">]</span>

<span class="keyword">implement</span> eq_effect_effect
  <span class="keyword">(</span>eff1<span class="keyword">,</span> eff2<span class="keyword">)</span> <span class="keyword">=</span> eq_int_int <span class="keyword">(</span>eff1<span class="keyword">,</span> eff2<span class="keyword">)</span>
<span class="comment">// end of [eq_effect_effect]
</span>
<span class="keyword">implement</span>
fprint_effect
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> eff<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">if</span> eq_int_int <span class="keyword">(</span>eff<span class="keyword">,</span> EFFexn<span class="keyword">)</span> <span class="keyword">then</span>
    fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "exn"<span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">if</span> eq_int_int <span class="keyword">(</span>eff<span class="keyword">,</span> EFFntm<span class="keyword">)</span> <span class="keyword">then</span>
    fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "ntm"<span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">if</span> eq_int_int <span class="keyword">(</span>eff<span class="keyword">,</span> EFFref<span class="keyword">)</span> <span class="keyword">then</span>
    fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "ref"<span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">begin</span>
    fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "eff("<span class="keyword">)</span><span class="keyword">;</span>
    fprint1_int <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> eff<span class="keyword">)</span><span class="keyword">;</span>
    fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ")"<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [if] *)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_effect]
</span>
<span class="keyword">implement</span>
fprint_effectlst
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> effs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> effs<span class="keyword">:</span> <span class="staexp">effectlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> effs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>eff<span class="keyword">,</span> effs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ", "<span class="keyword">)</span><span class="keyword">;</span>
        fprint_effect <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> eff<span class="keyword">)</span><span class="keyword">;</span> aux <span class="keyword">(</span>i+1<span class="keyword">,</span> out<span class="keyword">,</span> effs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [list_cons]
</span>    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [list_nil]
</span>  <span class="comment">// end of [aux]
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>0<span class="keyword">,</span> out<span class="keyword">,</span> effs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_effectlst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> print_effect <span class="keyword">(</span>eff<span class="keyword">)</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_effect<span class="keyword">,</span> eff<span class="keyword">)</span>
<span class="keyword">implement</span> prerr_effect <span class="keyword">(</span>eff<span class="keyword">)</span> <span class="keyword">=</span> prerr_mac <span class="keyword">(</span>fprint_effect<span class="keyword">,</span> eff<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><a name="3725"><span class="stacstdec">effset <span class="keyword">=</span> uint</span></a></span>

<span class="keyword">assume</span> <span class="staexp">effset_t <span class="keyword">=</span> effset</span>
<span class="keyword">extern</span> <span class="keyword">typedef</span> <span class="staexp">"atsopt_effset_t" <span class="keyword">=</span> effset</span>

<span class="keyword">macdef</span> <span class="neuexp">effset_exn <span class="keyword">=</span> 0x1</span> <span class="comment">// exception
</span><span class="keyword">macdef</span> <span class="neuexp">effset_ntm <span class="keyword">=</span> 0x2</span> <span class="comment">// nontermination
</span><span class="keyword">macdef</span> <span class="neuexp">effset_ref <span class="keyword">=</span> 0x4</span> <span class="comment">// reference
</span><span class="keyword">macdef</span> <span class="neuexp">effset_wrt <span class="keyword">=</span> 0x8</span> <span class="comment">// write effect (* program *)
</span>
<span class="keyword">implement</span> effset_all <span class="keyword">=</span> uint_of <span class="keyword">(</span><span class="keyword">(</span>1 &lt;&lt; MAX_EFFECT_NUMBER<span class="keyword">)</span> - 1<span class="keyword">)</span>
<span class="keyword">implement</span> effset_nil <span class="keyword">=</span> uint_of_int 0 <span class="comment">// 0U
</span>
<span class="keyword">implement</span> eq_effset_effset <span class="keyword">(</span>efs1<span class="keyword">,</span> efs2<span class="keyword">)</span> <span class="keyword">=</span> eq_uint_uint <span class="keyword">(</span>efs1<span class="keyword">,</span> efs2<span class="keyword">)</span>

<span class="extern">%{

#define MAX_EFFECT_NUMBER 4

#ifdef __WORDSIZE

#if (MAX_EFFECT_NUMBER &gt; __WORDSIZE)
#error "MAX_EFFECT_NUMBER is too large!"
#endif

#endif

ats_void_type
atsopt_fprint_effset (
  ats_ptr_type out, atsopt_effset_t effs
) {
  int i, n ;
  i = 1 ; n = 0 ;
  while (i &lt;= MAX_EFFECT_NUMBER) {
    if (effs &amp; 0x1) {
      if (n &gt; 0) fprintf ((FILE *)out, ",");
      atsopt_fprint_effect (out, i) ; ++n ;
    }
    ++i ; effs &gt;&gt;= 1 ;
  }
  return ;
} /* end of [atsopt_fprint_effset] */

%}</span> <span class="comment">// end of [%{]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extern">%{

atsopt_effset_t
atsopt_effset_add (
  atsopt_effset_t efs, atsopt_effect_t eff
) {
  unsigned int i = 1 ;
  while (eff &gt; 1) { i &lt;&lt;= 1; --eff ; }
  return (efs | i) ;
} // end of [atsopt_effset_add]

atsopt_effset_t
atsopt_effset_del (
  atsopt_effset_t efs, atsopt_effect_t eff
) {
  unsigned int i = 1 ;
  while (eff &gt; 1) { i &lt;&lt;= 1; --eff ; }
  return (efs &amp; ~i) ;
} // end of [atsopt_effset_del]

ats_bool_type
atsopt_effset_contain (
  atsopt_effset_t efs, atsopt_effect_t eff
) {
  unsigned int i = 1 ;
  while (eff &gt; 1) { i &lt;&lt;= 1; --eff ; }
  return (efs &amp; i ? ats_true_bool : ats_false_bool) ;
} // end of [atsopt_effset_contain]

atsopt_effset_t
atsopt_effset_union (
  atsopt_effset_t efs1, atsopt_effset_t efs2
) {
  return (efs1 | efs2) ;
} // end of [atsopt_effset_union]

ats_bool_type
atsopt_effset_subset (
  atsopt_effset_t efs1, atsopt_effset_t efs2
) {
  return (efs1 &amp; ~efs2 ? ats_false_bool : ats_true_bool) ;
} // end of [atsopt_effset_subset]

%}</span> <span class="comment">// end of [%{]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
$Syn<span class="keyword">.</span>d0exp_effmask_all <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">t0kn</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  d0exp_loc<span class="keyword">=</span> t<span class="keyword">.</span>t0kn_loc<span class="keyword">,</span> d0exp_node<span class="keyword">=</span> $Syn<span class="keyword">.</span>D0Eeffmask effectlst_all
<span class="keyword">}</span> <span class="comment">// end of [d0exp_effmask_all]
</span>
<span class="keyword">implement</span>
$Syn<span class="keyword">.</span>d0exp_effmask_exn <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">t0kn</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  d0exp_loc<span class="keyword">=</span> t<span class="keyword">.</span>t0kn_loc<span class="keyword">,</span> d0exp_node<span class="keyword">=</span> $Syn<span class="keyword">.</span>D0Eeffmask <span class="keyword">'[</span>effect_exn<span class="keyword">]</span>
<span class="keyword">}</span> <span class="comment">// end of [d0exp_effmask_exn]
</span>
<span class="keyword">implement</span>
$Syn<span class="keyword">.</span>d0exp_effmask_ntm <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">t0kn</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  d0exp_loc<span class="keyword">=</span> t<span class="keyword">.</span>t0kn_loc<span class="keyword">,</span> d0exp_node<span class="keyword">=</span> $Syn<span class="keyword">.</span>D0Eeffmask <span class="keyword">'[</span>effect_ntm<span class="keyword">]</span>
<span class="keyword">}</span> <span class="comment">// end of [d0exp_effmask_ntm]
</span>
<span class="keyword">implement</span>
$Syn<span class="keyword">.</span>d0exp_effmask_ref <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">t0kn</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">'{</span>
  d0exp_loc<span class="keyword">=</span> t<span class="keyword">.</span>t0kn_loc<span class="keyword">,</span> d0exp_node<span class="keyword">=</span> $Syn<span class="keyword">.</span>D0Eeffmask <span class="keyword">'[</span>effect_ref<span class="keyword">]</span>
<span class="keyword">}</span> <span class="comment">// end of [d0exp_effmask_ref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">val</span> effvars_nil<span class="keyword">:</span> <span class="staexp">effvarlst</span> <span class="keyword">=</span> nil <span class="keyword">(</span><span class="keyword">)</span>

<span class="keyword">fun</span> fprint_effvarlst
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>file_mode<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m<span class="keyword">,</span>w<span class="keyword">)</span></span></span>
  <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span>
  <span class="keyword">,</span> evs<span class="keyword">:</span> <span class="staexp">effvarlst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> aux <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> evs<span class="keyword">:</span> <span class="staexp">effvarlst</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> evs <span class="keyword">of</span>
    <span class="keyword">|</span> cons <span class="keyword">(</span>ev<span class="keyword">,</span> evs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ", "<span class="keyword">)</span><span class="keyword">;</span>
        $Syn<span class="keyword">.</span>fprint_i0de <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ev<span class="keyword">)</span><span class="keyword">;</span> aux <span class="keyword">(</span>out<span class="keyword">,</span> i+1<span class="keyword">,</span> evs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [aux]
</span><span class="keyword">in</span>
  aux <span class="keyword">(</span>out<span class="keyword">,</span> 0<span class="keyword">,</span> evs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [fprint_effvarlst]
</span>
<span class="keyword">implement</span>
fprint_effcst
  <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> efc<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> efc <span class="keyword">of</span>
  <span class="keyword">|</span> EFFCSTall <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "all"<span class="keyword">)</span>
  <span class="keyword">|</span> EFFCSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "nil"<span class="keyword">)</span>
  <span class="keyword">|</span> EFFCSTset <span class="keyword">(</span>es<span class="keyword">,</span> evs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "set("<span class="keyword">)</span><span class="keyword">;</span>
      fprint_effset <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> es<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> "; "<span class="keyword">)</span><span class="keyword">;</span>
      fprint_effvarlst <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> evs<span class="keyword">)</span><span class="keyword">;</span>
      fprint1_string <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> out<span class="keyword">,</span> ")"<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [EFFCSTset]
</span><span class="keyword">end</span> <span class="comment">// end of [fprint_effcst]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span>
print_effcst <span class="keyword">(</span>efc<span class="keyword">)</span> <span class="keyword">=</span> print_mac <span class="keyword">(</span>fprint_effcst<span class="keyword">,</span> efc<span class="keyword">)</span>
<span class="keyword">implement</span>
prerr_effcst <span class="keyword">(</span>efc<span class="keyword">)</span> <span class="keyword">=</span> prerr_mac <span class="keyword">(</span>fprint_effcst<span class="keyword">,</span> efc<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span> effcst_contain <span class="keyword">(</span>efc<span class="keyword">,</span> eff<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> efc <span class="keyword">of</span>
  <span class="keyword">|</span> EFFCSTall <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">|</span> EFFCSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
  <span class="keyword">|</span> EFFCSTset <span class="keyword">(</span>efs<span class="keyword">,</span> evs<span class="keyword">)</span>  <span class="keyword">=&gt;</span> effset_contain <span class="keyword">(</span>efs<span class="keyword">,</span> eff<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [effcst_contain]
</span>
<span class="keyword">implement</span> effcst_contain_ntm efc <span class="keyword">=</span> effcst_contain <span class="keyword">(</span>efc<span class="keyword">,</span> EFFntm<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span> name_is_emp <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> name <span class="keyword">=</span> "0"

<span class="keyword">fn</span> name_is_all <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> name <span class="keyword">=</span> "1"

<span class="keyword">fn</span> name_is_exn <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> name <span class="keyword">=</span> "exn" <span class="keyword">then</span> true <span class="keyword">else</span> name <span class="keyword">=</span> "exception"

<span class="keyword">fn</span> name_is_exnref <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> name <span class="keyword">=</span> "exnref"

<span class="keyword">fn</span> name_is_ntm <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> name <span class="keyword">=</span> "ntm" <span class="keyword">then</span> true <span class="keyword">else</span> name <span class="keyword">=</span> "nonterm"

<span class="keyword">fn</span> name_is_ref <span class="keyword">(</span>name<span class="keyword">:</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> name <span class="keyword">=</span> "ref" <span class="keyword">then</span> true <span class="keyword">else</span> name <span class="keyword">=</span> "reference"

<span class="keyword">fn</span> name_is_term <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> name <span class="keyword">=</span> "term"

<span class="comment">(*
fn name_is_wrt (name: string): bool =
  if name = "wrt" then true else name = "write"
*)</span>

<span class="comment">//
</span><span class="comment">// HX-2010-07-31: !laz = 1,~ref
</span><span class="comment">//
</span><span class="keyword">fn</span> name_is_lazy <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> name <span class="keyword">=</span> "laz"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">local</span>

<span class="keyword">fn</span> loop_err <span class="keyword">(</span>loc<span class="keyword">:</span> <span class="staexp">loc_t</span><span class="keyword">,</span> name<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  $Loc<span class="keyword">.</span>prerr_location loc<span class="keyword">;</span> prerr ": error(1)"<span class="keyword">;</span>
  prerr ": unrecognized effect constant: ["<span class="keyword">;</span> prerr name<span class="keyword">;</span> prerr "]"<span class="keyword">;</span>
  prerr_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span>
  $Err<span class="keyword">.</span>abort <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [loop_err]
</span>
<span class="keyword">fun</span> loop <span class="keyword">(</span>
    ofc<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>funcloopt</span>
  <span class="keyword">,</span> lin<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>int</span>
  <span class="keyword">,</span> prf<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>int</span>
  <span class="keyword">,</span> efs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>effset</span>
  <span class="keyword">,</span> evs<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>effvarlst</span>
  <span class="keyword">,</span> tags<span class="keyword">:</span> <span class="staexp">$Syn<span class="keyword">.</span>e0fftaglst</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> tags <span class="keyword">of</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>tag<span class="keyword">,</span> tags<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> tag<span class="keyword">.</span>e0fftag_node <span class="keyword">of</span>
      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGvar ev <span class="keyword">=&gt;</span> evs := cons <span class="keyword">(</span>ev<span class="keyword">,</span> evs<span class="keyword">)</span>
<span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGcst <span class="keyword">(</span>isneg<span class="keyword">,</span> name<span class="keyword">)</span>
          <span class="keyword">when</span> name_is_all name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          evs := effvars_nil<span class="keyword">;</span>
          <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> efs := effset_nil <span class="keyword">else</span> efs := effset_all
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGcst when ...]
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGcst <span class="keyword">(</span>isneg<span class="keyword">,</span> name<span class="keyword">)</span>
          <span class="keyword">when</span> name_is_emp name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          evs := effvars_nil<span class="keyword">;</span>
          <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> efs := effset_all <span class="keyword">else</span> efs := effset_nil
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGcst when ...]
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGcst <span class="keyword">(</span>isneg<span class="keyword">,</span> name<span class="keyword">)</span>
          <span class="keyword">when</span> name_is_lazy name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
          evs := effvars_nil<span class="keyword">;</span>
          <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
            efs := effset_add <span class="keyword">(</span>effset_nil<span class="keyword">,</span> EFFref<span class="keyword">)</span> <span class="comment">// HX: a pathological case
</span>          <span class="keyword">else</span>
            efs := effset_del <span class="keyword">(</span>effset_all<span class="keyword">,</span> EFFref<span class="keyword">)</span> <span class="comment">// HX: !laz = 1,~ref
</span>          <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGcst when ...]
</span><span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGcst <span class="keyword">(</span>isneg<span class="keyword">,</span> name<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> name <span class="keyword">of</span>
        <span class="keyword">|</span> _ <span class="keyword">when</span> name_is_exn name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
              efs := effset_del <span class="keyword">(</span>efs<span class="keyword">,</span> EFFexn<span class="keyword">)</span>
            <span class="keyword">else</span>
              efs := effset_add <span class="keyword">(</span>efs<span class="keyword">,</span> EFFexn<span class="keyword">)</span>
            <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>        <span class="keyword">|</span> _ <span class="keyword">when</span> name_is_exnref name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
              efs := effset_del <span class="keyword">(</span>effset_del <span class="keyword">(</span>efs<span class="keyword">,</span> EFFexn<span class="keyword">)</span><span class="keyword">,</span> EFFref<span class="keyword">)</span>
            <span class="keyword">else</span>
              efs := effset_add <span class="keyword">(</span>effset_add <span class="keyword">(</span>efs<span class="keyword">,</span> EFFexn<span class="keyword">)</span><span class="keyword">,</span> EFFref<span class="keyword">)</span>
            <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>        <span class="keyword">|</span> _ <span class="keyword">when</span> name_is_ntm name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
              efs := effset_del <span class="keyword">(</span>efs<span class="keyword">,</span> EFFntm<span class="keyword">)</span>
            <span class="keyword">else</span>
              efs := effset_add <span class="keyword">(</span>efs<span class="keyword">,</span> EFFntm<span class="keyword">)</span>
            <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>        <span class="keyword">|</span> _ <span class="keyword">when</span> name_is_term name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
              efs := effset_add <span class="keyword">(</span>efs<span class="keyword">,</span> EFFntm<span class="keyword">)</span>
            <span class="keyword">else</span>
              efs := effset_del <span class="keyword">(</span>efs<span class="keyword">,</span> EFFntm<span class="keyword">)</span>
            <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>        <span class="keyword">|</span> _ <span class="keyword">when</span> name_is_ref name <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
            <span class="keyword">if</span> isneg <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
              efs := effset_del <span class="keyword">(</span>efs<span class="keyword">,</span> EFFref<span class="keyword">)</span>
            <span class="keyword">else</span>
              efs := effset_add <span class="keyword">(</span>efs<span class="keyword">,</span> EFFref<span class="keyword">)</span>
            <span class="comment">// end of [if]
</span>          <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>        <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> loop_err <span class="keyword">(</span>tag<span class="keyword">.</span>e0fftag_loc<span class="keyword">,</span> name<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGcst]
</span><span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGprf <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> prf := 1
<span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGlin
          <span class="keyword">(</span>i<span class="comment">(*nil/all*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lin := 1 <span class="comment">// linearity
</span>        <span class="keyword">in</span>
          <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">(</span>efs := effset_all<span class="keyword">;</span> evs := effvars_nil<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGlin]
</span><span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGfun
          <span class="keyword">(</span>uln<span class="keyword">,</span> i<span class="comment">(*nil/all*)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">(</span>uln &gt;= 0<span class="keyword">)</span> <span class="keyword">then</span> lin := uln
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ofc := Some <span class="keyword">(</span>$Syn<span class="keyword">.</span>FUNCLOfun <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">(</span>efs := effset_all<span class="keyword">;</span> evs := effvars_nil<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGfun]
</span><span class="comment">//
</span>      <span class="keyword">|</span> $Syn<span class="keyword">.</span>E0FFTAGclo
          <span class="keyword">(</span>uln<span class="keyword">,</span> knd<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="comment">// knd : 1/~1:ptr/ref; i : nil/all
</span>          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> <span class="keyword">(</span>uln &gt;= 0<span class="keyword">)</span> <span class="keyword">then</span> lin := uln
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ofc := Some <span class="keyword">(</span>$Syn<span class="keyword">.</span>FUNCLOclo <span class="keyword">(</span>knd<span class="keyword">)</span><span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">(</span>efs := effset_all<span class="keyword">;</span> evs := effvars_nil<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [E0FFTAGclo]
</span><span class="comment">//
</span>    <span class="keyword">in</span>
      loop <span class="keyword">(</span>ofc<span class="keyword">,</span> lin<span class="keyword">,</span> prf<span class="keyword">,</span> efs<span class="keyword">,</span> evs<span class="keyword">,</span> tags<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [let] // end of [cons]
</span>  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [nil]
</span><span class="keyword">end</span> <span class="comment">// end of [loop]
</span>
<span class="keyword">in</span> <span class="comment">// in of [local]
</span>
<span class="keyword">implement</span>
e0fftaglst_tr <span class="keyword">(</span>tags<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> ofc<span class="keyword">:</span> <span class="staexp">funcloopt</span> <span class="keyword">=</span> None<span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">var</span> lin<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0 <span class="keyword">and</span> prf<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0
  <span class="keyword">var</span> efs<span class="keyword">:</span> <span class="staexp">effset</span> <span class="keyword">=</span> effset_nil <span class="keyword">and</span> evs<span class="keyword">:</span> <span class="staexp">effvarlst</span> <span class="keyword">=</span> effvars_nil
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>ofc<span class="keyword">,</span> lin<span class="keyword">,</span> prf<span class="keyword">,</span> efs<span class="keyword">,</span> evs<span class="keyword">,</span> tags<span class="keyword">)</span>
  <span class="keyword">val</span> efc <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">case+</span> 0 <span class="keyword">of</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> eq_effset_effset <span class="keyword">(</span>efs<span class="keyword">,</span> effset_all<span class="keyword">)</span> <span class="keyword">=&gt;</span> EFFCSTall <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">|</span> _ <span class="keyword">when</span> eq_effset_effset <span class="keyword">(</span>efs<span class="keyword">,</span> effset_nil<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        <span class="keyword">case+</span> evs <span class="keyword">of</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> EFFCSTnil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> EFFCSTset <span class="keyword">(</span>efs<span class="keyword">,</span> evs<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [_ when ...]
</span>    <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> EFFCSTset <span class="keyword">(</span>efs<span class="keyword">,</span> evs<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">effcst</span>
<span class="keyword">in</span>
  <span class="keyword">@(</span>ofc<span class="keyword">,</span> lin<span class="keyword">,</span> prf<span class="keyword">,</span> efc<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [e0fftaglst_tr]
</span>
<span class="keyword">end</span> <span class="comment">// end of [local]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [ats_effect.dats] *)</span>
</pre>
</body>
</html>
