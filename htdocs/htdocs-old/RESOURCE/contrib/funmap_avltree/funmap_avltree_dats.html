<HTML>
<HEAD>
<STYLE TYPE="text/css">
span.comment {color:787878;font-style:italic}
span.extern  {color:A52A2A}
span.keyword {color:000000;font-weight:bold}
span.neuexp  {color:800080}
span.staexp  {color:0000FF}
span.dynexp  {color:E80000}
span.prfexp  {color:009000}
span.stacstdec  {text-decoration:none}
span.stacstuse  {color:0000CF;text-decoration:underline}
span.dyncstdec  {text-decoration:none}
span.dyncstimp  {color:B80000;text-decoration:underline}
span.dyncstuse  {color:B80000;text-decoration:underline}
</STYLE>
</HEAD>

<BODY BGCOLOR="#E0E0E0" TEXT="#E80000">
<PRE>
<span class="comment">(*
**
** An implementation of functional maps based on AVL trees.
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: October, 2008
**
*)</span>

<span class="comment">//
</span><span class="comment">// License: LGPL 3.0 (available at http://www.gnu.org/licenses/lgpl.txt)
</span><span class="comment">//
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">#define</span> <span class="neuexp">ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynamic loading
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">abstype</span> <span class="staexp"><A name="335"><span class="stacstdec">map_t</span></span></A> <span class="keyword">(</span>key<span class="keyword">:</span> t@ype<span class="keyword">,</span> itm<span class="keyword">:</span> t@ype+<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="397"><span class="stacstdec">cmp <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>key<span class="keyword">,</span> key<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> Sgn</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  <A name="465"><span class="dyncstdec">compare_key_key <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Sgn</span></span></A>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">}</span> compare_key_key <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> cmp <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="keyword">}</span> <A name="617"><span class="dyncstdec">funmap_empty <span class="staexp"><span class="keyword">{</span>key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="keyword">}</span> <A name="683"><span class="dyncstdec">funmap_is_empty <span class="staexp"><span class="keyword">{</span>key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype<span class="keyword">}</span></span> <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="keyword">}</span> <A name="758"><span class="dyncstdec">funmap_isnot_empty <span class="staexp"><span class="keyword">{</span>key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype<span class="keyword">}</span></span> <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">// this function is O(n)-time and non-tail-recursive
</span><span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="924"><span class="dyncstdec">funmap_size <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Nat</span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  <A name="1015"><span class="dyncstdec">funmap_search <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Option_vt <span class="keyword">(</span>itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_search]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  <A name="1169"><span class="dyncstdec">funmap_insert <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">itm</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_insert]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1310"><span class="dyncstdec">funmap_insert_status
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">itm</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> status<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>int? &gt;&gt; int</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_insert_status]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  <A name="1515"><span class="dyncstdec">funmap_remove <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_remove]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1647"><span class="dyncstdec">funmap_remove_status
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> status<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>Option_vt itm? &gt;&gt; Option_vt itm</span><span class="keyword">)</span>
  <span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_remove_status]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="1843"><span class="stacstdec">eq <span class="keyword">(</span>itm<span class="keyword">:</span> t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>itm<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;&gt;</span> bool</span></span></A>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="1908"><span class="dyncstdec">funmap_is_subset
  <span class="keyword">(</span>m1<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> m2<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> eq<span class="keyword">:</span> <span class="staexp">eq itm</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>
<span class="comment">// end of [funmap_is_subset]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2062"><span class="dyncstdec">funmap_is_equal
  <span class="keyword">(</span>m1<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> m2<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> eq<span class="keyword">:</span> <span class="staexp">eq itm</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>
<span class="comment">// end of [funmap_is_equal]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2235"><span class="dyncstdec">funmap_foreach_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>view<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> xs<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span></span></A>
<span class="comment">// end of [funmap_foreach_clo]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2396"><span class="dyncstdec">funmap_foreach_cloref
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></A>
<span class="comment">// end of [funmap_foreach_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2567"><span class="dyncstdec">funmap_foreachif_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>view<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> xs<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> bool</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span></span></A>
<span class="comment">// end of [funmap_foreachif_clo]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2732"><span class="dyncstdec">funmap_foreachif_cloref
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> bool</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></A>
<span class="comment">// end of [funmap_foreachif_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <A name="2907"><span class="dyncstdec">funmap_tabulate
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List key</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">key <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> itm</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_tabulate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <span class="comment">// the created stream is sorted
</span>  <A name="3106"><span class="dyncstdec">funmap_stream_key_make <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">stream_vt key</span></span></A>
<span class="comment">// end of [funmap_stream_key_make]
</span>
<span class="keyword">extern</span> <span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> <span class="comment">// the created stream is sorted
</span>  <A name="3264"><span class="dyncstdec">funmap_stream_keyitm_make <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">stream_vt <span class="keyword">@(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
<span class="comment">// end of [funmap_stream_keyitm_make]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp"><A name="3405"><span class="stacstdec">listpos <span class="keyword">(</span>itm<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">[</span>n<span class="keyword">:</span>pos<span class="keyword">]</span> list <span class="keyword">(</span>itm<span class="keyword">,</span> n<span class="keyword">)</span></span></span></A>

<span class="keyword">datatype</span> <span class="staexp"><A name="3459"><span class="stacstdec">avltree <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="comment">(*height*)</span><span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat</span> <span class="keyword">|</span> <span class="staexp">hl &lt;= hr+1</span><span class="keyword">;</span> <span class="staexp">hr &lt;= hl+1</span><span class="keyword">}</span>
    B <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">)</span></span> <span class="keyword">of</span>
      <span class="staexp"><span class="keyword">(</span>int <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">)</span><span class="keyword">,</span> key<span class="keyword">,</span> listpos itm<span class="keyword">,</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span><span class="keyword">,</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> E <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> 0<span class="keyword">)</span></span>
<span class="comment">// end of [datatype avltree]
</span>
<span class="keyword">typedef</span> <span class="staexp"><A name="3734"><span class="stacstdec">avltree_inc <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h &lt;= h1<span class="keyword">;</span> h1 &lt;= h+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h1<span class="keyword">)</span></span></span></A>

<span class="keyword">typedef</span> <span class="staexp"><A name="3842"><span class="stacstdec">avltree_dec <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> h<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">[</span>h1<span class="keyword">:</span>nat <span class="keyword">|</span> h1 &lt;= h<span class="keyword">;</span> h &lt;= h1+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h1<span class="keyword">)</span></span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">assume</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">:</span>t@ype<span class="keyword">,</span> itm<span class="keyword">:</span>t@ype<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">[</span>h<span class="keyword">:</span>nat<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span> funmap_empty <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> E <span class="keyword">(</span><span class="keyword">)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span> funmap_is_empty <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> false <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
<span class="comment">// end of [funmap_is_empty]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="keyword">}</span> funmap_isnot_empty <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> true <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> false
<span class="comment">// end of [funmap_isnot_empty]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> size <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> size <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">Nat</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> _<span class="comment">(*k*)</span><span class="keyword">,</span> _<span class="comment">(*xs*)</span><span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> 1 + size <span class="keyword">(</span>tl<span class="keyword">)</span> + size <span class="keyword">(</span>tr<span class="keyword">)</span>
    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
  <span class="keyword">end</span> <span class="comment">// end of [size]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_size]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_search <span class="keyword">(</span>t<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> search <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> search <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt <span class="keyword">(</span>itm<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span>
    <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> search <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> search <span class="keyword">(</span>tr<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> xs
        <span class="keyword">in</span>
          Some_vt <span class="keyword">(</span>x<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> None_vt <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [search]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_search]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_height <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">int h</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> h <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="keyword">end</span> <span class="comment">// end of [avltree_height]
</span>
<span class="comment">(*
** left rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_lrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl+2 == hr<span class="keyword">}</span></span> <span class="keyword">(</span>
    k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">listpos itm</span>
  <span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span></span>
  <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat <span class="keyword">|</span> hr &lt;= h<span class="keyword">;</span> h &lt;= hr+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>hr<span class="keyword">,</span> kr<span class="keyword">,</span> xsr<span class="keyword">,</span> trl<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=</span> tr
  <span class="keyword">val</span> hrl <span class="keyword">=</span> avltree_height trl <span class="keyword">and</span> hrr <span class="keyword">=</span> avltree_height trr
<span class="keyword">in</span>
  <span class="keyword">if</span> hrl &lt;= hrr <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// hr = 1+hlr
</span>    B <span class="keyword">(</span>hrl+2<span class="keyword">,</span> kr<span class="keyword">,</span> xsr<span class="keyword">,</span> B <span class="keyword">(</span>hrl+1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> trl<span class="keyword">)</span><span class="keyword">,</span> trr<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// [hrl &gt; hrr]: deep rotation
</span>    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*hrl*)</span><span class="keyword">,</span> krl<span class="keyword">,</span> xsrl<span class="keyword">,</span> trll<span class="keyword">,</span> trlr<span class="keyword">)</span> <span class="keyword">=</span> trl
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hr<span class="keyword">,</span> krl<span class="keyword">,</span> xsrl<span class="keyword">,</span> B <span class="keyword">(</span>hrl<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> trll<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>hrl<span class="keyword">,</span> kr<span class="keyword">,</span> xsr<span class="keyword">,</span> trlr<span class="keyword">,</span> trr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_lrotate]
</span>
<span class="comment">(*
** right rotation for restoring height invariant
*)</span>
<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_rrotate <span class="staexp"><span class="keyword">{</span>hl<span class="keyword">,</span>hr<span class="keyword">:</span>nat <span class="keyword">|</span> hl == hr+2<span class="keyword">}</span></span> <span class="keyword">(</span>
    k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">listpos itm</span>
  <span class="keyword">,</span> tl<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hl<span class="keyword">)</span></span>
  <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> hr<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>h<span class="keyword">:</span>nat <span class="keyword">|</span> hl &lt;= h<span class="keyword">;</span> h &lt;= hl+1<span class="keyword">]</span> avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>hl<span class="keyword">,</span> kl<span class="keyword">,</span> xsl<span class="keyword">,</span> tll<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=</span> tl
  <span class="keyword">val</span> hll <span class="keyword">=</span> avltree_height tll <span class="keyword">and</span> hlr <span class="keyword">=</span> avltree_height tlr
<span class="keyword">in</span>
  <span class="keyword">if</span> hll &gt;= hlr <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">// hl = 1+hll
</span>    B <span class="keyword">(</span>hlr+2<span class="keyword">,</span> kl<span class="keyword">,</span> xsl<span class="keyword">,</span> tll<span class="keyword">,</span> B <span class="keyword">(</span>hlr+1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tlr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// [hll &lt; hlr]: deep rotation
</span>    <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="comment">(*hlr*)</span><span class="keyword">,</span> klr<span class="keyword">,</span> xslr<span class="keyword">,</span> tlrl<span class="keyword">,</span> tlrr<span class="keyword">)</span> <span class="keyword">=</span> tlr
  <span class="keyword">in</span>
    B <span class="keyword">(</span>hl<span class="keyword">,</span> klr<span class="keyword">,</span> xslr<span class="keyword">,</span> B <span class="keyword">(</span>hlr<span class="keyword">,</span> kl<span class="keyword">,</span> xsl<span class="keyword">,</span> tll<span class="keyword">,</span> tlrl<span class="keyword">)</span><span class="keyword">,</span> B <span class="keyword">(</span>hlr<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tlrr<span class="keyword">,</span> tr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [avltree_rrotate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">macdef</span> <span class="neuexp">list_sing <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> list_cons <span class="keyword">(</span><span class="keyword">,(</span>x<span class="keyword">)</span><span class="keyword">,</span> list_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_insert <span class="keyword">(</span>t<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> status<span class="keyword">:</span> <span class="staexp">int</span> <span class="comment">// uninitialized
</span><span class="keyword">in</span>
  funmap_insert_status <span class="keyword">(</span>t<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">,</span> status<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [funmap_insert]
</span>
<span class="comment">(*
**  [status=1] on return iff [k0] is already in the map
*)</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_insert_status
  <span class="keyword">(</span>t<span class="keyword">,</span> k0<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">,</span> status<span class="keyword">)</span> <span class="keyword">=</span> insert <span class="keyword">(</span>t<span class="keyword">,</span> status<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> insert <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">,</span> status<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>int? &gt;&gt; int</span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_inc <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tl <span class="keyword">=</span> insert <span class="keyword">(</span>tl<span class="keyword">,</span> status<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span> + 1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+2
</span>            avltree_rrotate <span class="keyword">(</span>k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tr <span class="keyword">=</span> insert <span class="keyword">(</span>tr<span class="keyword">,</span> status<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span> hr<span class="keyword">)</span> + 1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+1 = hr
</span>            avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">(* sgn = 0: item already exists *)</span>
          status := 1<span class="keyword">;</span> B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> list_cons <span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span>
        status := 0<span class="keyword">;</span> B <span class="keyword">(</span>1<span class="keyword">,</span> k0<span class="keyword">,</span> list_sing x0<span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> E <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [insert]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_insert_status]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> avltree_takeout_min <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
  <span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>key? &gt;&gt; key</span>
  <span class="keyword">,</span> xs0<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>listpos itm? &gt;&gt; listpos itm</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">avltree_dec <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val+</span> B <span class="keyword">(</span>_<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=</span> t
<span class="keyword">in</span>
  <span class="keyword">case+</span> tl <span class="keyword">of</span>
  <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> tl <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tl<span class="keyword">,</span> k0<span class="keyword">,</span> xs0<span class="keyword">)</span>
      <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tl<span class="keyword">)</span> <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height <span class="keyword">(</span>tr<span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
        B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 = hr
</span>       avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="comment">// end of [B]
</span>  <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>k0 := k<span class="keyword">;</span> xs0 := xs<span class="keyword">;</span> tr<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [avltree_takeout_min]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataview</span> <span class="prfexp"><span class="staexp"><A name="9129"><span class="stacstdec">ptrat0 <span class="keyword">(</span>itm<span class="keyword">:</span>t@ype+<span class="keyword">,</span> addr<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">l<span class="keyword">:</span>addr</span> <span class="keyword">|</span> <span class="staexp">l &lt;&gt; null</span><span class="keyword">}</span> ptrat0_some <span class="staexp"><span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">itm @ l</span>
  <span class="keyword">|</span> ptrat0_none <span class="staexp"><span class="keyword">(</span>itm<span class="keyword">,</span> null<span class="keyword">)</span></span></span>

<span class="keyword">dataview</span> <span class="prfexp"><span class="staexp"><A name="9252"><span class="stacstdec">ptrat1 <span class="keyword">(</span>itm<span class="keyword">:</span>viewt@ype+<span class="keyword">,</span> addr<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">l<span class="keyword">:</span>addr</span> <span class="keyword">|</span> <span class="staexp">l &lt;&gt; null</span><span class="keyword">}</span> ptrat1_some <span class="staexp"><span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">itm @ l</span>
  <span class="keyword">|</span> ptrat1_none <span class="staexp"><span class="keyword">(</span>itm<span class="keyword">,</span> null<span class="keyword">)</span></span></span>

<span class="keyword">viewdef</span> <span class="staexp"><A name="9378"><span class="stacstdec">ptratopt0 <span class="keyword">(</span>itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> l<span class="keyword">:</span>addr<span class="keyword">)</span> <span class="keyword">=</span> ptrat0 <span class="keyword">(</span>Option_vt itm?<span class="keyword">,</span> l<span class="keyword">)</span></span></span></A>
<span class="keyword">viewdef</span> <span class="staexp"><A name="9445"><span class="stacstdec">ptratopt1 <span class="keyword">(</span>itm<span class="keyword">:</span>t@ype<span class="keyword">,</span> l<span class="keyword">:</span>addr<span class="keyword">)</span> <span class="keyword">=</span> ptrat1 <span class="keyword">(</span>Option_vt itm <span class="keyword">,</span> l<span class="keyword">)</span></span></span></A>

<span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">key<span class="keyword">,</span>itm<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
  funmap_remove_main <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>ptratopt0 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span> &gt;&gt; ptratopt1 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span></span></span>
  <span class="keyword">|</span> m<span class="keyword">:</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span><span class="keyword">,</span> k0<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp key</span><span class="keyword">,</span> p<span class="keyword">:</span> <span class="staexp">ptr l</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span> <span class="keyword">=</span> remove <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> remove <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>ptratopt0 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span> &gt;&gt; ptratopt1 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span></span></span>
    <span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">avltree_dec <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> sgn <span class="keyword">=</span> compare_key_key <span class="keyword">(</span>k0<span class="keyword">,</span> k<span class="keyword">,</span> cmp<span class="keyword">)</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tl <span class="keyword">=</span> remove <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tl<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
        <span class="keyword">in</span>
          <span class="keyword">if</span> hr - hl &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span> + 1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 == hr
</span>            avltree_lrotate <span class="keyword">(</span>k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> tr <span class="keyword">=</span> remove <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> tr<span class="keyword">)</span>
          <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
        <span class="keyword">in</span>
          <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
            B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span> + 1<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl = hr+2
</span>            avltree_rrotate <span class="keyword">(</span>k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">(* sgn = 0: item found *)</span>
          <span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
            <span class="keyword">if</span> <span class="keyword">:</span><span class="keyword">(</span>pf<span class="keyword">:</span> ptratopt1 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> p &lt;&gt; null <span class="keyword">then</span> <span class="keyword">let</span>
              <span class="keyword">prval</span> <span class="prfexp">ptrat0_some pf1 <span class="keyword">=</span> pf</span>
            <span class="keyword">in</span>
              <span class="keyword">!</span>p := Some_vt x<span class="keyword">;</span> pf := ptrat1_some <span class="keyword">(</span>pf1<span class="keyword">)</span>
            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
              <span class="keyword">prval</span> <span class="prfexp">ptrat0_none <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> pf := ptrat1_none <span class="keyword">(</span><span class="keyword">)</span>
            <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">in</span>
          <span class="keyword">case+</span> xs <span class="keyword">of</span>
          <span class="keyword">|</span> list_cons _ <span class="keyword">=&gt;</span> B <span class="keyword">(</span>h<span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
          <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> tr <span class="keyword">of</span>
            <span class="keyword">|</span> B _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
                <span class="keyword">var</span> k_min<span class="keyword">:</span> <span class="staexp">key?</span> <span class="keyword">and</span> xs_min<span class="keyword">:</span> <span class="staexp">listpos itm?</span>
                <span class="keyword">val</span> tr <span class="keyword">=</span> avltree_takeout_min&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>tr<span class="keyword">,</span> k_min<span class="keyword">,</span> xs_min<span class="keyword">)</span>
                <span class="keyword">val</span> hl <span class="keyword">=</span> avltree_height tl <span class="keyword">and</span> hr <span class="keyword">=</span> avltree_height tr
              <span class="keyword">in</span>
                <span class="keyword">if</span> hl - hr &lt;= 1 <span class="keyword">then</span> <span class="keyword">begin</span>
                  B <span class="keyword">(</span>max<span class="keyword">(</span>hl<span class="keyword">,</span>hr<span class="keyword">)</span>+1<span class="keyword">,</span> k_min<span class="keyword">,</span> xs_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// hl+2 = hr
</span>                  avltree_rrotate <span class="keyword">(</span>k_min<span class="keyword">,</span> xs_min<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span>
                <span class="keyword">end</span> <span class="comment">// end of [if]
</span>              <span class="keyword">end</span> <span class="comment">// end of [B]
</span>            <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> tl
            <span class="keyword">end</span> <span class="comment">// end of [list_nil]
</span>        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
          <span class="keyword">if</span> <span class="keyword">:</span><span class="keyword">(</span>pf<span class="keyword">:</span> ptratopt1 <span class="keyword">(</span>itm<span class="keyword">,</span> l<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> p &lt;&gt; null <span class="keyword">then</span> <span class="keyword">let</span>
            <span class="keyword">prval</span> <span class="prfexp">ptrat0_some pf1 <span class="keyword">=</span> pf</span>
          <span class="keyword">in</span>
            <span class="keyword">!</span>p := None_vt <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> pf := ptrat1_some <span class="keyword">(</span>pf1<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
            <span class="keyword">prval</span> <span class="prfexp">ptrat0_none <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> pf := ptrat1_none <span class="keyword">(</span><span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>      <span class="keyword">in</span>
        E <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// no association for the key [k0]
</span>      <span class="keyword">end</span> <span class="comment">// end of [E]
</span>  <span class="keyword">end</span> <span class="comment">// end of [remove]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_remove_main]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_remove <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> ptrat0_none <span class="staexp"><span class="keyword">{</span>Option_vt itm?<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> m <span class="keyword">=</span> funmap_remove_main&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> null<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">ptrat1_none <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span>
<span class="keyword">in</span>
  m <span class="comment">// map after removal operation is performed
</span><span class="keyword">end</span> <span class="comment">// end of [funmap_remove]
</span>
<span class="comment">(*
**  [status=Some_vt(x)] on return iff [k0-&gt;x] is in the map
*)</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span> funmap_remove_status <span class="keyword">(</span>m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> status<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> ptrat0_some <span class="staexp"><span class="keyword">{</span>Option_vt itm?<span class="keyword">}</span></span> <span class="keyword">(</span>view@ status<span class="keyword">)</span></span>
  <span class="keyword">val</span> m <span class="keyword">=</span> funmap_remove_main&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> m<span class="keyword">,</span> k0<span class="keyword">,</span> cmp<span class="keyword">,</span> <span class="keyword">&amp;</span>status<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">ptrat1_some <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf</span><span class="keyword">;</span> <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> view@ status := pf1</span>
<span class="keyword">in</span>
  m <span class="comment">// map after removal operation is performed
</span><span class="keyword">end</span> <span class="comment">// end of [funmap_remove_status]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">// infix order traversal
</span><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_foreach_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">viewtypedef</span> <span class="staexp"><A name="13097"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>clo_type</span><span class="keyword">,</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span> <span class="comment">(* inorder traversal *)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> xs
      <span class="keyword">in</span>
        aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tl<span class="keyword">)</span><span class="keyword">;</span> f <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> k<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">;</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_foreach_clo]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_foreach_cloref <span class="keyword">(</span>t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> f <span class="keyword">=</span> __cast <span class="keyword">(</span>f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span> <span class="keyword">extern</span> <span class="keyword">castfn</span> <A name="13611"><span class="dyncstdec">__cast
    <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">typedef</span> <span class="staexp"><A name="13722"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> void</span></span></A>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">vbox pf_f</span> <span class="keyword">|</span> p_f<span class="keyword">)</span> <span class="keyword">=</span> cloref_get_view_ptr <span class="staexp"><span class="keyword">{</span>clo_type<span class="keyword">}</span></span> <span class="keyword">(</span>f<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_ref</span> <span class="keyword">(</span>funmap_foreach_clo&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="keyword">!</span>p_f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [funmap_foreach_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">// infix order traversal
</span><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_foreachif_clo <span class="staexp"><span class="keyword">{</span>v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">viewtypedef</span> <span class="staexp"><A name="14148"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> bool</span></span></A>
  <span class="keyword">fun</span> aux <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>h<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
      <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>v</span></span> <span class="keyword">|</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>clo_type</span><span class="keyword">,</span> t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span> <span class="comment">(* inorder traversal *)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> xs
      <span class="keyword">in</span>
        <span class="keyword">if</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tl<span class="keyword">)</span> <span class="keyword">then</span>
          <span class="keyword">(</span><span class="keyword">if</span> f <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> k<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">then</span> aux <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> f<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">else</span> false<span class="keyword">)</span>
        <span class="keyword">else</span> false
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
  <span class="keyword">end</span> <span class="comment">// end of [aux]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_foreachif_clo]
</span>
<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_foreachif_cloref <span class="keyword">(</span>t<span class="keyword">,</span> f<span class="keyword">)</span> <span class="keyword">=</span> ans <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">val</span> f <span class="keyword">=</span> __cast <span class="keyword">(</span>f<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span> <span class="keyword">extern</span> <span class="keyword">castfn</span> <A name="14732"><span class="dyncstdec">__cast
    <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> bool</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> bool</span></span></A>
  <span class="keyword">}</span> <span class="comment">// end of [val]
</span>  <span class="keyword">typedef</span> <span class="staexp"><A name="14843"><span class="stacstdec">clo_type <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">!</span>unit_v <span class="keyword">|</span> key<span class="keyword">,</span> itm<span class="keyword">)</span> <span class="keyword">-&lt;</span>clo<span class="keyword">&gt;</span> bool</span></span></A>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">vbox pf_f</span> <span class="keyword">|</span> p_f<span class="keyword">)</span> <span class="keyword">=</span> cloref_get_view_ptr <span class="staexp"><span class="keyword">{</span>clo_type<span class="keyword">}</span></span> <span class="keyword">(</span>f<span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> ans <span class="keyword">=</span> <span class="keyword">$effmask_ref</span> <span class="keyword">(</span>funmap_foreachif_clo&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="keyword">!</span>p_f<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span>
<span class="keyword">}</span> <span class="comment">// end of [funmap_foreachif_cloref]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_tabulate <span class="keyword">(</span>xs<span class="keyword">,</span> f<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> funmap_empty <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">typedef</span> <span class="staexp"><A name="15232"><span class="stacstdec">res_t <span class="keyword">=</span> map_t <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
  <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>xs<span class="keyword">:</span>  <span class="staexp">list <span class="keyword">(</span>key<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">res_t</span><span class="keyword">)</span><span class="keyword">:&lt;&gt;</span> <span class="staexp">res_t</span> <span class="keyword">=</span> <span class="keyword">case+</span> xs <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> funmap_insert&lt;<span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">&gt;</span> <span class="keyword">(</span>res<span class="keyword">,</span> x<span class="keyword">,</span> f x<span class="keyword">,</span> cmp<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> res
<span class="keyword">}</span> <span class="comment">// end of [funmap_tabulate]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">// infix order traversal
</span><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_stream_key_make <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_ntm</span> <span class="keyword">(</span>_make1 t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">fun</span> _make1 <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">1</span><span class="keyword">,</span><span class="keyword">~</span><span class="staexp">exnref</span><span class="keyword">&gt;</span> <span class="staexp">stream_vt key</span> <span class="keyword">=</span> <span class="keyword">$delay_vt</span> <span class="keyword">(</span><span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> _<span class="comment">(*xs*)</span><span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> ks1 <span class="keyword">=</span> _make1 <span class="keyword">(</span>tl<span class="keyword">)</span>
        <span class="keyword">val</span> ks1_con <span class="keyword">=</span> <span class="keyword">!</span>ks1 <span class="keyword">in</span> <span class="keyword">case+</span> ks1_con <span class="keyword">of</span>
          <span class="keyword">|</span> stream_vt_cons <span class="keyword">(</span>k1<span class="keyword">,</span> <span class="keyword">!</span>p_ks1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
              <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_ks1 := _make2 <span class="keyword">(</span><span class="keyword">!</span>p_ks1<span class="keyword">,</span> k<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">in</span>
              fold@ ks1_con<span class="keyword">;</span> ks1_con
            <span class="keyword">end</span> <span class="comment">// end of [stream_vt_cons]
</span>          <span class="keyword">|</span> <span class="keyword">~</span>stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_cons <span class="keyword">(</span>k<span class="keyword">,</span> _make1 tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">:</span> <span class="staexp">stream_vt_con key</span><span class="keyword">)</span> <span class="comment">// end of [_make1]
</span>
  <span class="keyword">and</span> _make2 <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      ks1<span class="keyword">:</span> <span class="staexp">stream_vt key</span>
    <span class="keyword">,</span> k<span class="keyword">:</span> <span class="staexp">key</span>
    <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">1</span><span class="keyword">,</span><span class="keyword">~</span><span class="staexp">exnref</span><span class="keyword">&gt;</span> <span class="staexp">stream_vt key</span> <span class="keyword">=</span> <span class="keyword">$delay_vt</span> <span class="keyword">(</span>
    <span class="keyword">let</span> <span class="keyword">val</span> ks1_con <span class="keyword">=</span> <span class="keyword">!</span>ks1 <span class="keyword">in</span> <span class="keyword">case+</span> ks1_con <span class="keyword">of</span>
      <span class="keyword">|</span> stream_vt_cons <span class="keyword">(</span>k1<span class="keyword">,</span> <span class="keyword">!</span>p_ks1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_ks1 := _make2 <span class="keyword">(</span><span class="keyword">!</span>p_ks1<span class="keyword">,</span> k<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">in</span>
          fold@ ks1_con<span class="keyword">;</span> ks1_con
        <span class="keyword">end</span> <span class="comment">// end of [stream_vt_cons]
</span>      <span class="keyword">|</span> <span class="keyword">~</span>stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_cons <span class="keyword">(</span>k<span class="keyword">,</span> _make1 tr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">:</span> <span class="staexp">stream_vt_con key</span>
  <span class="keyword">,</span> stream_vt_free <span class="keyword">(</span>ks1<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">// end of [_make2]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_stream_key_make]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">// infix order traversal
</span><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_stream_keyitm_make <span class="keyword">(</span>t<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_ntm</span> <span class="keyword">(</span>_make1 t<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">typedef</span> <span class="staexp"><A name="16862"><span class="stacstdec">keyitm <span class="keyword">=</span> <span class="keyword">@(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
  <span class="keyword">fun</span> _make1 <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;</span><span class="staexp">1</span><span class="keyword">,</span><span class="keyword">~</span><span class="staexp">exnref</span><span class="keyword">&gt;</span> <span class="staexp">stream_vt keyitm</span> <span class="keyword">=</span> <span class="keyword">$delay_vt</span> <span class="keyword">(</span><span class="keyword">begin</span> <span class="keyword">case+</span> t <span class="keyword">of</span>
    <span class="keyword">|</span> B <span class="keyword">(</span>_<span class="comment">(*h*)</span><span class="keyword">,</span> k<span class="keyword">,</span> xs<span class="keyword">,</span> tl<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="keyword">val</span> kis1 <span class="keyword">=</span> _make1 <span class="keyword">(</span>tl<span class="keyword">)</span>
        <span class="keyword">val+</span> list_cons <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> xs
        <span class="keyword">val</span> kis1_con <span class="keyword">=</span> <span class="keyword">!</span>kis1 <span class="keyword">in</span> <span class="keyword">case+</span> kis1_con <span class="keyword">of</span>
          <span class="keyword">|</span> stream_vt_cons <span class="keyword">(</span>k1<span class="keyword">,</span> <span class="keyword">!</span>p_kis1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
              <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_kis1 := _make2 <span class="keyword">(</span><span class="keyword">!</span>p_kis1<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">in</span>
              fold@ kis1_con<span class="keyword">;</span> kis1_con
            <span class="keyword">end</span> <span class="comment">// end of [stream_vt_cons]
</span>          <span class="keyword">|</span> <span class="keyword">~</span>stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_cons <span class="keyword">(</span><span class="keyword">@(</span>k<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> _make1 tr<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [B]
</span>    <span class="keyword">|</span> E <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">:</span> <span class="staexp">stream_vt_con keyitm</span><span class="keyword">)</span> <span class="comment">// end of [_make1]
</span>
  <span class="keyword">and</span> _make2 <span class="staexp"><span class="keyword">{</span>h<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
      kis1<span class="keyword">:</span> <span class="staexp">stream_vt keyitm</span>
    <span class="keyword">,</span> k<span class="keyword">:</span> <span class="staexp">key</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">itm</span>
    <span class="keyword">,</span> tr<span class="keyword">:</span> <span class="staexp">avltree <span class="keyword">(</span>key<span class="keyword">,</span> itm<span class="keyword">,</span> h<span class="keyword">)</span></span>
    <span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">1</span><span class="keyword">,</span><span class="keyword">~</span><span class="staexp">exnref</span><span class="keyword">&gt;</span> <span class="staexp">stream_vt keyitm</span> <span class="keyword">=</span> <span class="keyword">$delay_vt</span> <span class="keyword">(</span>
    <span class="keyword">let</span> <span class="keyword">val</span> kis1_con <span class="keyword">=</span> <span class="keyword">!</span>kis1 <span class="keyword">in</span> <span class="keyword">case+</span> kis1_con <span class="keyword">of</span>
      <span class="keyword">|</span> stream_vt_cons <span class="keyword">(</span>k1<span class="keyword">,</span> <span class="keyword">!</span>p_kis1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_kis1 := _make2 <span class="keyword">(</span><span class="keyword">!</span>p_kis1<span class="keyword">,</span> k<span class="keyword">,</span> x<span class="keyword">,</span> tr<span class="keyword">)</span> <span class="keyword">in</span>
          fold@ kis1_con<span class="keyword">;</span> kis1_con
        <span class="keyword">end</span> <span class="comment">// end of [stream_vt_cons]
</span>      <span class="keyword">|</span> <span class="keyword">~</span>stream_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_vt_cons <span class="keyword">(</span><span class="keyword">@(</span>k<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">,</span> _make1 tr<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">:</span> <span class="staexp">stream_vt_con keyitm</span>
  <span class="keyword">,</span> stream_vt_free <span class="keyword">(</span>kis1<span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">// end of [_make2]
</span><span class="keyword">}</span> <span class="comment">// end of [funmap_stream_keyitm_make]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">key</span><span class="keyword">,</span><span class="staexp">itm</span><span class="keyword">}</span>
  funmap_is_equal <span class="keyword">(</span>m1<span class="keyword">,</span> m2<span class="keyword">,</span> cmp<span class="keyword">,</span> eq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">viewtypedef</span> <span class="staexp"><A name="18187"><span class="stacstdec">kis_vt <span class="keyword">=</span> stream_vt <span class="keyword">@(</span>key<span class="keyword">,</span> itm<span class="keyword">)</span></span></span></A>
  <span class="keyword">#define</span> <span class="neuexp">nil stream_vt_nil</span>
  <span class="keyword">#define</span> <span class="neuexp">cons stream_vt_cons</span>
  <span class="keyword">#define</span> <span class="neuexp">free stream_vt_free</span>
  <span class="keyword">val</span> kis1 <span class="keyword">=</span> funmap_stream_keyitm_make <span class="keyword">(</span>m1<span class="keyword">)</span>
  <span class="keyword">val</span> kis2 <span class="keyword">=</span> funmap_stream_keyitm_make <span class="keyword">(</span>m2<span class="keyword">)</span>
  <span class="keyword">fun</span> eq_kis_kis
    <span class="keyword">(</span>kis1<span class="keyword">:</span> <span class="staexp">kis_vt</span><span class="keyword">,</span> kis2<span class="keyword">:</span> <span class="staexp">kis_vt</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">,</span><span class="keyword">!</span><span class="staexp">ntm</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">=</span>
    <span class="keyword">case+</span> <span class="keyword">!</span>kis1 <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">~</span>cons <span class="keyword">(</span>ki1<span class="keyword">,</span> kis1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">!</span>kis2 <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">~</span>cons <span class="keyword">(</span>ki2<span class="keyword">,</span> kis2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
          <span class="keyword">val</span> test <span class="keyword">=</span>
            cmp <span class="keyword">(</span>ki1<span class="keyword">.</span>0<span class="keyword">,</span> ki2<span class="keyword">.</span>0<span class="keyword">)</span> <span class="keyword">=</span> 0 andalso eq <span class="keyword">(</span>ki1<span class="keyword">.</span>1<span class="keyword">,</span> ki2<span class="keyword">.</span>1<span class="keyword">)</span>
          <span class="comment">// end of [val]
</span>        <span class="keyword">in</span>
          <span class="keyword">if</span> test <span class="keyword">then</span>
            eq_kis_kis <span class="keyword">(</span>kis1<span class="keyword">,</span> kis2<span class="keyword">)</span>
          <span class="keyword">else</span> <span class="keyword">begin</span>
            <span class="keyword">$effmask_exn</span> <span class="keyword">(</span>free kis1<span class="keyword">;</span> free kis2<span class="keyword">;</span> false<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// endif
</span>        <span class="keyword">end</span> <span class="comment">(* end of [cons] *)</span>
      <span class="keyword">|</span> <span class="keyword">~</span>nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">$effmask_exn</span> <span class="keyword">(</span>free kis1<span class="keyword">;</span> false<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [cons]
</span>    <span class="keyword">|</span> <span class="keyword">~</span>nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> <span class="keyword">!</span>kis2 <span class="keyword">of</span>
      <span class="keyword">|</span> <span class="keyword">~</span>cons <span class="keyword">(</span>_<span class="keyword">,</span> kis2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">$effmask_exn</span> <span class="keyword">(</span>free kis2<span class="keyword">;</span> false<span class="keyword">)</span>
      <span class="keyword">|</span> <span class="keyword">~</span>nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> true
      <span class="keyword">end</span> <span class="comment">// end of [nil]
</span>  <span class="comment">// end of [eq_kis_kis]
</span><span class="keyword">in</span>
  <span class="keyword">$effmask_ntm</span> <span class="keyword">(</span>eq_kis_kis <span class="keyword">(</span>kis1<span class="keyword">,</span> kis2<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [funmap_is_equal]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [funmap_avltree.dats] *)</span>
</PRE>
</BODY>
</HTML>
