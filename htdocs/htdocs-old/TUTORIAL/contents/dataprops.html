<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .atsyntax {color:#E80000;background-color:#E0E0E0}
    .atsyntax span.comment {color:#787878;font-style:italic}
    .atsyntax span.extern  {color:#A52A2A}
    .atsyntax span.keyword {color:#000000;font-weight:bold}
    .atsyntax span.neuexp  {color:#800080}
    .atsyntax span.staexp  {color:#0000FF}
    .atsyntax span.dynexp  {color:#E80000}
    .atsyntax span.prfexp  {color:#009000}
    .atsyntax span.stacstdec  {text-decoration:none}
    .atsyntax span.stacstuse  {color:#0000CF;text-decoration:underline}
    .atsyntax span.dyncstdec  {text-decoration:none}
    .atsyntax span.dyncstimp  {color:#B80000;text-decoration:underline}
    .atsyntax span.dyncstuse  {color:#B80000;text-decoration:underline}
    .atsyntax body {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<!--
<html>
<head>
<style type="text/css">
span.comment {color:787878;font-style:italic}
span.extern  {color:A52A2A}
span.keyword {color:000000;font-weight:bold}
span.neuexp  {color:800080}
span.staexp  {color:0000FF}
span.dynexp  {color:E80000}
span.prfexp  {color:009000}
</style>
</head>
-->
<body text="#000000" bgcolor="#ffffff" link="#0000FF" vlink="#CC00CC" alink="#ff0000">
<!--
The file is automatically generated by [atsdoc] from datatypes.atxt.
-->
<!--
Time of Generation: Mon Aug 22 15:00:17 2011
-->
<!--beg of [dataprops.html]-->

<H2><A id="dataprops" name="dataprops">Dataprops</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A prop is similar to a type. If a prop is assigned to a dynamic term, then
the term is guaranteed to be pure and total, that is, the evaluation of the
term generates no effects and always terminates. We refer to dynamic terms
classified by props as proof terms, or simply proofs. 

Dataprops are often declared for encoding recursively defined relations.
For instance, multiplication on integers can be defined as follows in
terms of integer addition:

<CENTER>
<TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2>

<TR>
  <TD ALIGN=RIGHT></TD>
  <TD ALIGN=CENTER></TD>
  <TD ALIGN=LEFT></TD>
  <TD ALIGN=LEFT></TD>
</TR>

<TR>
  <TD><i>0 * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>0</i></TD>
  <TD></TD>
<TR>

<TR>
  <TD><i>(m+1) * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>m * n + n</i></TD>
  <TD>; if <i>m >= 0 </i></TD>
<TR>

<TR>
  <TD><i>m * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>-(-m * n)</i></TD>
  <TD>; if <i>m < 0 </i></TD>
<TR>

</TABLE>
</CENTER>
<P>

Let <i>MUL(m, n, p)</i> be a relation on integers such that
<i>MUL(m, n, p)</i> holds if and only if <i>m * n = p</i>.
Then this relation can be encoded by the followng dataprop:


<pre class="atsyntax">
<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><a name="9"><span class="stacstdec">MUL <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">}</span> MULbas <span class="staexp"><span class="keyword">(</span>0<span class="keyword">,</span> n<span class="keyword">,</span> 0<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">m &gt;= 0</span><span class="keyword">}</span> MULind <span class="staexp"><span class="keyword">(</span>m+1<span class="keyword">,</span> n<span class="keyword">,</span> p+n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">m <span class="keyword">&gt;</span> 0</span><span class="keyword">}</span> MULneg <span class="staexp"><span class="keyword">(</span><span class="keyword">~</span>m<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">~</span>p<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span></span>
<span class="comment">// end of [MUL]
</span></pre>


<I>Proposition (Totality)
For each pair of integers <i>m</i> and <i>n</i>, there exists an
integer <i>p</i> such that <i>m * n = p</i> holds.
</I>
<P>

This proposition can be encoded as the following prop in ATS:

<pre>
{m,n:int} () -< prf > [p:int] MUL (m, n, p)
</pre>

which is assigned to the function <i>MULprop_total</i> defined below:


<pre class="atsyntax">
<span class="keyword">prfun</span> <span class="prfexp">MULprop_total
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">.&lt;</span> max<span class="keyword">(</span>2*m<span class="keyword">,</span>~2*m+1<span class="keyword">)</span> <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span> MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">m <span class="keyword">&gt;</span> 0</span> <span class="keyword">then</span> MULind <span class="keyword">(</span>MULprop_total <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">sif</span> <span class="staexp">m <span class="keyword">&lt;</span> 0</span> <span class="keyword">then</span> MULneg <span class="keyword">(</span>MULprop_total <span class="staexp"><span class="keyword">{</span><span class="keyword">~</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">else</span> MULbas <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [MULprop_total]
</span></pre>


Note that we use <i>sif</i> for constructing a static conditional in which
the condition is a static proposition, that is, a static term of sort
<i>bool</i>. The conditions for the two occurrences of <i>sif</i> are
<i>m > 0</i> and <i>m < 0</i>, which are both static propositions.
<P>
Given that the prop <i>{m,n:int} () -< prf > [p:int] MUL (m, n, p)</i>
is inhabited, we know that the proposition it encodes must hold.
<P>

<I>Proposition (Uniqueness)
Given integers <i>m,n,p1,p2</i> such that
<i>m * n = p1</i> and <i>m * n = p2</i>, then
<i>p1 = p2</i> holds.
</I>
<P>

This proposition can be encoded as the following prop in ATS:

<pre>
{m,n,p1,p2:int} (MUL (m, n, p1), MUL (m, n, p2)) -< prf > [p1 == p2] void
</pre>

which is assigned to the function <i>MULprop_unique</i> defined below:


<pre class="atsyntax">
<span class="keyword">prfun</span> <span class="prfexp">MULprop_unique
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">,</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> max<span class="keyword">(</span>2*m<span class="keyword">,</span> ~2*m+1<span class="keyword">)</span> <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p1<span class="keyword">)</span></span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p2<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1 == p2<span class="keyword">]</span> void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULind pf1<span class="keyword">,</span> MULind pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULprop_unique <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULneg pf1<span class="keyword">,</span> MULneg pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULprop_unique <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="comment">// end of [MULprop_unique]
</span></pre>


Therefore, the prop is inhabited and thus the proposition it
encodes must hold.

<P>

The distributivity (over addition), commutativity and associativity of
multiplication can all be esstablished similarly.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="dataprops.dats">here</a>.

<!--end of [dataprops.html]-->



</body>
</html>
