
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/unsafe</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/unsafe</h1>


<p>
This package contains functions primarily needed for bypassing the type
system of ATS. These functions are often employed to implement templates in
ATS, which can be instantiated and then compiled into C-code. This style of
template implementation offers a safer and more reliable alternative to
macro-based template implementation in C.  </p>

<p>Note that the file unsafe.sats is not loaded by default and must be done so
explicitly.
</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#cast">cast</a></li>
<li><a href="#castvwtp0">castvwtp0</a></li>
<li><a href="#castvwtp1">castvwtp1</a></li>
<li><a href="#cast2ptr">cast2ptr</a></li>
<li><a href="#cast2Ptr0">cast2Ptr0</a></li>
<li><a href="#cast2Ptr1">cast2Ptr1</a></li>
<li><a href="#cast2int">cast2int</a></li>
<li><a href="#cast2uint">cast2uint</a></li>
<li><a href="#cast2lint">cast2lint</a></li>
<li><a href="#cast2ulint">cast2ulint</a></li>
<li><a href="#cast2llint">cast2llint</a></li>
<li><a href="#cast2ullint">cast2ullint</a></li>
<li><a href="#cast2sint">cast2sint</a></li>
<li><a href="#cast2usint">cast2usint</a></li>
<li><a href="#cast2ssint">cast2ssint</a></li>
<li><a href="#cast2ussint">cast2ussint</a></li>
<li><a href="#list_vt2t">list_vt2t</a></li>
<li><a href="#arrayptr2ref">arrayptr2ref</a></li>
<li><a href="#strptr2string">strptr2string</a></li>
<li><a href="#ptr0_get">ptr0_get</a></li>
<li><a href="#ptr1_get">ptr1_get</a></li>
<li><a href="#ptr0_set">ptr0_set</a></li>
<li><a href="#ptr1_set">ptr1_set</a></li>
<li><a href="#ptr0_exch">ptr0_exch</a></li>
<li><a href="#ptr1_exch">ptr1_exch</a></li>
<li><a href="#ptr0_addby">ptr0_addby</a></li>
<li><a href="#ptr1_addby">ptr1_addby</a></li>
<li><a href="#ptr0_subby">ptr0_subby</a></li>
<li><a href="#ptr1_subby">ptr1_subby</a></li>
<li><a href="#ptr0_mulby">ptr0_mulby</a></li>
<li><a href="#ptr1_mulby">ptr1_mulby</a></li>
<li><a href="#ptr0_divby">ptr0_divby</a></li>
<li><a href="#ptr1_divby">ptr1_divby</a></li>
<li><a href="#ptr0_modby">ptr0_modby</a></li>
<li><a href="#ptr1_modby">ptr1_modby</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="cast">cast</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
cast<span class="staexp"><span class="keyword">{</span>to<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>from<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">from</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">to</span></span></pre>
<h3>Description</h3>
This is the generic function for casting values of nonlinear types.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="castvwtp0">castvwtp0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
castvwtp0
  <span class="staexp"><span class="keyword">{</span>to<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>from<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">from</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">to</span></span></pre>
<h3>Description</h3>

This is the generic function for casting values of linear types. Note that
it consumes the value being casted. The resource in the argument of this
function, if any, should be completely transferred into the result of the
cast so as to avoid resource-leaking.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="castvwtp1">castvwtp1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
castvwtp1
  <span class="staexp"><span class="keyword">{</span>to<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>from<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">from</span><span class="keyword">)</span><span class="staexp">&gt;&gt;</span><span class="staexp">from</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">to</span></span></pre>
<h3>Description</h3>

This is the generic function for casting values of linear types into values
of nonlinear types.  Note that It preserves the value being casted.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2ptr">cast2ptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2ptr <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span></span></pre>
<h3>Description</h3>
This function casts a boxed value to a pointer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2Ptr0">cast2Ptr0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2Ptr0 <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span></span></pre>
<h3>Description</h3>
This function casts a boxed value to a pointer of indexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2Ptr1">cast2Ptr1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2Ptr1 <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>type<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span></span></pre>
<h3>Description</h3>
This function casts a boxed value to a non-null pointer of indexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2int">cast2int</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2int <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span></pre>
<h3>Description</h3>
This function casts a value to a signed integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2uint">cast2uint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2uint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">uint</span></span></pre>
<h3>Description</h3>
This function casts a value to an unsigned integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2lint">cast2lint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2lint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">lint</span></span></pre>
<h3>Description</h3>
This function casts a value to a signed long integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2ulint">cast2ulint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2ulint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ulint</span></span></pre>
<h3>Description</h3>
This function casts a value to an unsigned long integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2llint">cast2llint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2llint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">llint</span></span></pre>
<h3>Description</h3>
This function casts a value to a signed long long integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2ullint">cast2ullint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2ullint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ullint</span></span></pre>
<h3>Description</h3>
This function casts a value to an unsigned long long integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2sint">cast2sint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2sint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sint</span></span></pre>
<h3>Description</h3>
This function casts a value to a signed short integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2usint">cast2usint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> cast2usint <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">usint</span></span></pre>
<h3>Description</h3>
This function casts a value to an unsigned short integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2ssint">cast2ssint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [cast2ssint] is unavailable.</pre>
<h3>Description</h3>
This function casts a value to a signed short short integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="cast2ussint">cast2ussint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
Synopsis for [cast2ussint] is unavailable.</pre>
<h3>Description</h3>
This function casts a value to an unsigned short short integer of unindexed type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt2t">list_vt2t</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> list_vt2t
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function casts a linear list to a nonlinear list (only for temporary use).
<h3>Example</h3>

A typical use of this function occurs in a case where certain function
defined only on nonlinear lists needs to be applied to a linear list. For
instane, the following code demonstrates a simple way to copy a linear list
by calling the copy function for nonlinear lists:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_unsafe_0.dats"><span class="comment">//</span>
<span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list_vt_copy <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> list_copy <span class="keyword">(</span>$UN<span class="keyword">.</span>list_vt2t <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [list_vt_copy]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr2ref">arrayptr2ref</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> arrayptr2ref
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="strptr2string">strptr2string</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span> strptr2string <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">String0</span></span></pre>
<h3>Description</h3>

This function casts a linear (non-null) string to a nonlinear string (only
for temporary use).  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_get">ptr0_get</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr0_get <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">a</span></span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_get</span> except it does not typecheck whether
its argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_get">ptr1_get</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr1_get <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">a</span></span></pre>
<h3>Description</h3>

This function reads from a non-null pointer with no requirement for a proof
of at-view associated with the pointer. This is precisely like reading from
a pointer in C.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_set">ptr0_set</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr0_set <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_set</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_set">ptr1_set</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr1_set <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function writes through a non-null pointer with no requirement for a proof
of at-view associated with the pointer. This is precisely like writing through
a pointer in C.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_exch">ptr0_exch</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr0_exch <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_exch</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_exch">ptr1_exch</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> ptr1_exch <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function exchanges the content at the location to which its first
argument points with the content in its second argument.  Note that there
is no proof available that guarantees the first argument being a valid
pointer.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_addby">ptr0_addby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr0_addby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p += x</span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_addby</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_addby">ptr1_addby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr1_addby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p += x</span></pre>
<h3>Description</h3>

This function updates the content of p with the sum of its current content
and x.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_subby">ptr0_subby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr0_subby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p -= x</span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">ptr1_subby</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_subby">ptr1_subby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr1_subby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p -= x</span></pre>
<h3>Description</h3>

This function updates the content of p with the difference of its current
content from x.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_mulby">ptr0_mulby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr0_mulby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p *= x</span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_mulby</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_mulby">ptr1_mulby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr1_mulby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p *= x</span></pre>
<h3>Description</h3>

This function updates the content of p with the product of multiplying its
current content by x.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_divby">ptr0_divby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr0_divby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p /= x</span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_divby</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_divby">ptr1_divby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr1_divby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p /= x</span></pre>
<h3>Description</h3>

This function updates the content of p with the quotient of dividing its
current content by x.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr0_modby">ptr0_modby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr0_modby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p %= x</span></pre>
<h3>Description</h3>
This function is like <span class="patsyntaxdynexp">ptr1_modby</span> except it does not typecheck whether
its first argument is non-null.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptr1_modby">ptr1_modby</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> ptr1_modby <span class="keyword">(</span>p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// !p %= x</span></pre>
<h3>Description</h3>

This function updates the content of p with the remainder of dividing its
current content by x.  

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

