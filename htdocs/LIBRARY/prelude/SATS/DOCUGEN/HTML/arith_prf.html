
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/arith_prf
</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/arith_prf
</h1>


<p>This package contains some common proof functions for handling
arithmetics.
</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#MUL">MUL</a></li>
<li><a href="#mul_make">mul_make</a></li>
<li><a href="#mul_elim">mul_elim</a></li>
<li><a href="#mul_istot">mul_istot</a></li>
<li><a href="#mul_isfun">mul_isfun</a></li>
<li><a href="#mul_isfun2">mul_isfun2</a></li>
<li><a href="#mul_add_const">mul_add_const</a></li>
<li><a href="#mul_expand_linear">mul_expand_linear</a></li>
<li><a href="#mul_expand2_linear">mul_expand2_linear</a></li>
<li><a href="#mul_gte_gte_gte">mul_gte_gte_gte</a></li>
<li><a href="#mul_lte_gte_lte">mul_lte_gte_lte</a></li>
<li><a href="#mul_gte_lte_lte">mul_gte_lte_lte</a></li>
<li><a href="#mul_lte_lte_gte">mul_lte_lte_gte</a></li>
<li><a href="#mul_nat_nat_nat">mul_nat_nat_nat</a></li>
<li><a href="#mul_pos_pos_pos">mul_pos_pos_pos</a></li>
<li><a href="#mul_negate">mul_negate</a></li>
<li><a href="#mul_negate2">mul_negate2</a></li>
<li><a href="#mul_commute">mul_commute</a></li>
<li><a href="#mul_is_commutative">mul_is_commutative</a></li>
<li><a href="#mul_distribute">mul_distribute</a></li>
<li><a href="#mul_distribute2">mul_distribute2</a></li>
<li><a href="#mul_is_associative">mul_is_associative</a></li>
<li><a href="#DIVMOD">DIVMOD</a></li>
<li><a href="#div_istot">div_istot</a></li>
<li><a href="#divmod_istot">divmod_istot</a></li>
<li><a href="#divmod_isfun">divmod_isfun</a></li>
<li><a href="#divmod_elim">divmod_elim</a></li>
<li><a href="#EXP2">EXP2</a></li>
<li><a href="#lemma_exp2_param">lemma_exp2_param</a></li>
<li><a href="#exp2_istot">exp2_istot</a></li>
<li><a href="#exp2_isfun">exp2_isfun</a></li>
<li><a href="#exp2_ispos">exp2_ispos</a></li>
<li><a href="#exp2_is_mono">exp2_is_mono</a></li>
<li><a href="#exp2_muladd">exp2_muladd</a></li>
<li><a href="#EXP">EXP</a></li>
<li><a href="#lemma_exp_param">lemma_exp_param</a></li>
<li><a href="#exp_istot">exp_istot</a></li>
<li><a href="#exp_isfun">exp_isfun</a></li>
<li><a href="#exp_elim_0">exp_elim_0</a></li>
<li><a href="#exp_elim_1">exp_elim_1</a></li>
<li><a href="#exp_elim_2">exp_elim_2</a></li>
<li><a href="#exp_elim_b_0">exp_elim_b_0</a></li>
<li><a href="#exp_elim_b_1">exp_elim_b_1</a></li>
<li><a href="#exp_elim_b_2">exp_elim_b_2</a></li>
<li><a href="#exp_muladd">exp_muladd</a></li>
<li><a href="#exp_expmul">exp_expmul</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="MUL">MUL</a></h2>
<h3>Synopsis</h3>

<p>The dataprop <span class="patsyntaxstaexp">MUL</span> is declared as follows:
<pre class="patsyntax"><span class="keyword">dataprop</span>
<span class="staexp">MUL <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
    MULbas <span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
    MULind <span class="keyword">(</span><span class="staexp">m</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
    MULneg <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [MUL]</span>
</pre>
</p>
<h3>Description</h3>
Given integers m, n and p, the type (or more precisely, prop)
<span class="patsyntaxstaexp">MUL(m, n, p)</span> captures the relation <span class="patsyntaxstaexp">m*n=p</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_make">mul_make</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> mul_make <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function applies to static integers m and n to generate a proof
of the type <span class="patsyntaxstaexp">MUL(m, n, m*n)</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_elim">mul_elim</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> mul_elim <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>p == m*n<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function relates the relation <span class="patsyntaxstaexp">MUL</span> to the pre-defined
static multiplication function on integers.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_istot">mul_istot</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_istot <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function applies to static integers m and n to generate a proof
of the type <span class="patsyntaxstaexp">MUL(m, n, p)</span> for some integer p. In other words,
the function proves that <span class="patsyntaxstaexp">MUL</span> is total on its first two
arguments. The following code gives a direct implementation of
<span class="patsyntaxprfexp">mul_istot</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_0.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_istot
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> MULind <span class="keyword">(</span>lemma <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> MULbas <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span> lemma <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">else</span> MULneg <span class="keyword">(</span>lemma <span class="staexp"><span class="keyword">{</span><span class="keyword">~</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_istot]</span>
</pre>


Note that <span class="patsyntaxprfexp">mul_make</span> entirely supersedes <span class="patsyntaxprfexp">mul_istot</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_isfun">mul_isfun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_isfun <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function proves that the relation <span class="patsyntaxstaexp">MUL</span> is functional
on its first two arguments.  The following code gives a direct
implementation of <span class="patsyntaxprfexp">mul_isfun</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_1.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_isfun
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULind <span class="keyword">(</span>pf1<span class="keyword">)</span><span class="keyword">,</span> MULind <span class="keyword">(</span>pf2<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span>
    lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> MULneg <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf1 <span class="keyword">and</span> MULneg <span class="keyword">(</span>pf2<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
  <span class="keyword">in</span>
    lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [sif] *)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_isfun]</span>
</pre>


<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_isfun2">mul_isfun2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_isfun2 <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">EQINT</span> <span class="keyword">(</span><span class="staexp">p1</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This proof function is a variation of <span class="patsyntaxprfexp">mul_isfun</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_add_const">mul_add_const</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> mul_add_const <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="staexp">+</span><span class="staexp">i</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">+</span><span class="staexp">i</span><span class="staexp">*</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially captures the identity:
<span class="patsyntaxstaexp">(m+i)*n=m*n+i*n</span>.  It is kept mostly for the sake of backward
compatibility as the constraint-solver for ATS2 (Postiats) is able to
verify such an identity automatically. For instance, this ability is made
of use in typechecking the following implementation of
<span class="patsyntaxdynexp">mul_add_const</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_2.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_add_const
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_elim <span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="keyword">in</span> mul_make <span class="staexp"><span class="keyword">{</span>m+i<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_add_const]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_expand_linear">mul_expand_linear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> mul_expand_linear <span class="comment">// a,b,c,d: constants!</span>
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">,</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">,</span>d<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>xy<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">*</span><span class="staexp">x</span><span class="staexp">+</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">c</span><span class="staexp">*</span><span class="staexp">y</span><span class="staexp">+</span><span class="staexp">d</span><span class="keyword">,</span> <span class="staexp">a</span><span class="staexp">*</span><span class="staexp">c</span><span class="staexp">*</span><span class="staexp">xy</span><span class="staexp">+</span><span class="staexp">a</span><span class="staexp">*</span><span class="staexp">d</span><span class="staexp">*</span><span class="staexp">x</span><span class="staexp">+</span><span class="staexp">b</span><span class="staexp">*</span><span class="staexp">c</span><span class="staexp">*</span><span class="staexp">y</span><span class="staexp">+</span><span class="staexp">b</span><span class="staexp">*</span><span class="staexp">d</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially captures the following identity:
<p style="text-align: center;"><span class="patsyntaxstaexp">(a*x+b)*(c*y+d) = a*c*xy+a*d*x+b*c*y+b*d</span></p>

It is kept mostly for the sake of backward compatibility.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_expand2_linear">mul_expand2_linear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> mul_expand2_linear <span class="comment">// a1,b1,c1,a2,b2,c2: constants!</span>
  <span class="staexp"><span class="keyword">{</span>a1<span class="keyword">,</span>a2<span class="keyword">,</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>c1<span class="keyword">,</span>c2<span class="keyword">,</span>d<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>x1<span class="keyword">,</span>x2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>y1<span class="keyword">,</span>y2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>x1y1<span class="keyword">,</span>x1y2<span class="keyword">,</span>x2y1<span class="keyword">,</span>x2y2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf11<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x1</span><span class="keyword">,</span> <span class="staexp">y1</span><span class="keyword">,</span> <span class="staexp">x1y1</span><span class="keyword">)</span><span class="keyword">,</span> pf12<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x1</span><span class="keyword">,</span> <span class="staexp">y2</span><span class="keyword">,</span> <span class="staexp">x1y2</span><span class="keyword">)</span>
<span class="keyword">,</span> pf21<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x2</span><span class="keyword">,</span> <span class="staexp">y1</span><span class="keyword">,</span> <span class="staexp">x2y1</span><span class="keyword">)</span><span class="keyword">,</span> pf22<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x2</span><span class="keyword">,</span> <span class="staexp">y2</span><span class="keyword">,</span> <span class="staexp">x2y2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span>
  <span class="staexp">a1</span><span class="staexp">*</span><span class="staexp">x1</span><span class="staexp">+</span><span class="staexp">a2</span><span class="staexp">*</span><span class="staexp">x2</span><span class="staexp">+</span><span class="staexp">b</span>
<span class="keyword">,</span> <span class="staexp">c1</span><span class="staexp">*</span><span class="staexp">y1</span><span class="staexp">+</span><span class="staexp">c2</span><span class="staexp">*</span><span class="staexp">y2</span><span class="staexp">+</span><span class="staexp">d</span>
<span class="keyword">,</span> <span class="staexp">a1</span><span class="staexp">*</span><span class="staexp">c1</span><span class="staexp">*</span><span class="staexp">x1y1</span> <span class="staexp">+</span> <span class="staexp">a1</span><span class="staexp">*</span><span class="staexp">c2</span><span class="staexp">*</span><span class="staexp">x1y2</span> <span class="staexp">+</span>
  <span class="staexp">a2</span><span class="staexp">*</span><span class="staexp">c1</span><span class="staexp">*</span><span class="staexp">x2y1</span> <span class="staexp">+</span> <span class="staexp">a2</span><span class="staexp">*</span><span class="staexp">c2</span><span class="staexp">*</span><span class="staexp">x2y2</span> <span class="staexp">+</span>
  <span class="staexp">a1</span><span class="staexp">*</span><span class="staexp">d</span><span class="staexp">*</span><span class="staexp">x1</span> <span class="staexp">+</span> <span class="staexp">a2</span><span class="staexp">*</span><span class="staexp">d</span><span class="staexp">*</span><span class="staexp">x2</span> <span class="staexp">+</span>
  <span class="staexp">b</span><span class="staexp">*</span><span class="staexp">c1</span><span class="staexp">*</span><span class="staexp">y1</span> <span class="staexp">+</span> <span class="staexp">b</span><span class="staexp">*</span><span class="staexp">c2</span><span class="staexp">*</span><span class="staexp">y2</span> <span class="staexp">+</span>
  <span class="staexp">b</span><span class="staexp">*</span><span class="staexp">d</span>
<span class="keyword">)</span></span> <span class="comment">// end of [mul_expand2_linear]</span></pre>
<h3>Description</h3>

This proof function essentially captures the following identity:
<p style="text-align: center;"><span class="patsyntaxstaexp">(a1*x1+a2*x2+b)*(c1*y1+c2*y2+d) = 
a1*c1*x1*y1 + a1*c2*x1*y2 +
a2*c1*x2*y1 + a2*c2*x2*y2 +
a1*d*x1 + a2*d*x2 + b*c1*y1 + b*c2*y2 + b*d
</span></p>

It is kept mostly for the sake of backward compatibility.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_gte_gte_gte">mul_gte_gte_gte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_gte_gte_gte
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m &gt;= 0<span class="keyword">;</span> n &gt;= 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>m*n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function proves m >= 0 and n >= 0 implying m*n >= 0 for
any integers m and n.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_lte_gte_lte">mul_lte_gte_lte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_lte_gte_lte
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= 0<span class="keyword">;</span> n &gt;= 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>m*n &lt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function proves m <= 0 and n >= 0 implying m*n <= 0 for
any integers m and n.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_gte_lte_lte">mul_gte_lte_lte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_gte_lte_lte
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m &gt;= 0<span class="keyword">;</span> n &lt;= 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>m*n &lt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function proves m >= 0 and n <= 0 implying m*n <= 0 for
any integers m and n.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_lte_lte_gte">mul_lte_lte_gte</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_lte_lte_gte
  <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= 0<span class="keyword">;</span> n &lt;= 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>m*n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function proves m <= 0 and n <= 0 implying m*n >= 0 for
any integers m and n.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_nat_nat_nat">mul_nat_nat_nat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_nat_nat_nat <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>p &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function establishes p >= 0 if given a proof of the type
<span class="patsyntaxstaexp">MUL(m, n, p)</span> for some natural numbers m and n. A straigtforward
implementation of <span class="patsyntaxdynexp">mul_nat_nat_nat</span> is given as follows:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_3.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_nat_nat_nat <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> MULind <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span> lemma <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">|</span> MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [lemma]</span>
<span class="keyword">in</span>
  lemma <span class="keyword">(</span>pf<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_nat_nat_nat]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_pos_pos_pos">mul_pos_pos_pos</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_pos_pos_pos <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>p &gt;= m+n-1<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function establishes p >= m+n-1 if given a proof of
the type <span class="patsyntaxstaexp">MUL(m, n, p)</span> for some postive intgers m and n.
A direct implementation of <span class="patsyntaxdynexp">mul_pos_pos_pos</span> based on
<span class="patsyntaxdynexp">mul_nat_nat_nat</span> is given as follows:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_4.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_pos_pos_pos <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> MULind <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="comment">// pf1: MUL(m-1, n, ...)</span>
  <span class="prfexp"><span class="keyword">prval</span> pf2 <span class="keyword">=</span> mul_commute <span class="keyword">(</span>pf1<span class="keyword">)</span></span> <span class="comment">// pf2: MUL (n, m-1, ...)</span>
  <span class="prfexp"><span class="keyword">prval</span> MULind <span class="keyword">(</span>pf3<span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="comment">// pf3: MUL(m-1, n-1, ...)</span>
<span class="keyword">in</span>
  mul_nat_nat_nat <span class="keyword">(</span>pf3<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_pos_pos_pos]</span>
</pre>


<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_negate">mul_negate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_negate
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">p</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially proves <span class="patsyntaxstaexp">(~m)*n=~(m*n)</span> for any
given integers m and n, where ~ is the symbol for integer negation in ATS.
Note that <span class="patsyntaxdynexp">mul_negate</span> is kept mostly for the sake of backward
compatibility as the constraint-solver for ATS2 (Postiats) can readily
infer the identity <span class="patsyntaxstaexp">(~m)*n=~(m*n)</span>. However, typechecking the
following implementation of <span class="patsyntaxdynexp">mul_negate</span> involves solving only
linear integer constraints:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_5.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_negate
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> pf1 <span class="keyword">=</span> mul_make <span class="staexp"><span class="keyword">{</span><span class="keyword">~</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
    <span class="prfexp"><span class="keyword">prval</span> MULneg <span class="keyword">(</span>pf2<span class="keyword">)</span> <span class="keyword">=</span> pf1</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_isfun <span class="keyword">(</span>pf<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    pf1
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp"><span class="keyword">&lt;</span></span> <span class="staexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> MULneg <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> pf1
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> MULbas <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [sif]</span>
<span class="keyword">)</span></span> <span class="comment">// end of [mul_negate]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_negate2">mul_negate2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_negate2
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">p</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially proves <span class="patsyntaxstaexp">m*(~n)=~(m*n)</span> for any
given integers m and n, where ~ is the symbol for integer negation in ATS.
Note that <span class="patsyntaxdynexp">mul_negate2</span> is kept mostly for the sake of backward
compatibility as the constraint-solver for ATS2 (Postiats) can readily
infer the identity <span class="patsyntaxstaexp">m*(~n)=~(m*n)</span>. However, typechecking the
following implementation of <span class="patsyntaxdynexp">mul_negate2</span> involves solving only
linear integer constraints:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_6.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_negate2
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
  pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">~</span></span><span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> MULind
      <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULind <span class="keyword">(</span>lemma <span class="keyword">(</span>pf<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> MULbas <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [mul_m_neg_n_neg_mn]</span>
<span class="comment">//</span>
<span class="keyword">in</span> <span class="comment">// in of [local]</span>
<span class="comment">//</span>
<span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span>
   lemma <span class="keyword">(</span>pf<span class="keyword">)</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> MULneg pf <span class="keyword">=</span> pf</span> <span class="keyword">in</span> MULneg <span class="keyword">(</span>lemma <span class="keyword">(</span>pf<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [sif]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_negate2]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_commute">mul_commute</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_commute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially proves <span class="patsyntaxstaexp">m*n=n*m</span> for any given
integers m and n.  It is kept mostly for the sake of backward compatibility
as the constraint-solver of ATS2 (Postiats) is able to infer the identity
<span class="patsyntaxstaexp">m*n=n*m</span> automatically.  However, typechecking the following
implementation of <span class="patsyntaxdynexp">mul_commute</span> involves solving only linear
integer constraints:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_7.dats"><span class="keyword">local</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> mul_m_n1_mnm
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">.&lt;</span><span class="staexp">max</span><span class="keyword">(</span><span class="staexp">2</span><span class="staexp">*</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">2</span><span class="staexp">*</span><span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">m</span><span class="keyword">)</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">&gt;.</span>
  <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">p</span><span class="staexp">+</span><span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> MULbas <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> MULind pf <span class="keyword">=&gt;</span> MULind <span class="keyword">(</span>mul_m_n1_mnm pf<span class="keyword">)</span>
  <span class="keyword">|</span> MULneg pf <span class="keyword">=&gt;</span> MULneg <span class="keyword">(</span>mul_m_n1_mnm pf<span class="keyword">)</span></span>
<span class="comment">// end of [mul_m_n1_mnm]</span>
<span class="comment">//</span>
<span class="keyword">in</span> <span class="comment">// in of [local]</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">primplmnt</span>
mul_commute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> aux
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">;</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
  pf<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> pf <span class="keyword">=</span>
        mul_istot <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_elim pf</span>
    <span class="keyword">in</span>
      pf
    <span class="keyword">end</span> <span class="comment">// end of [MULbas]</span>
  <span class="keyword">|</span> MULind pf <span class="keyword">=&gt;</span> mul_m_n1_mnm <span class="keyword">(</span>aux pf<span class="keyword">)</span></span>
<span class="comment">// end of [aux]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span> aux pf <span class="keyword">else</span> <span class="keyword">begin</span>
    <span class="keyword">let</span> <span class="prfexp"><span class="keyword">prval</span> MULneg <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> pf</span> <span class="keyword">in</span> mul_negate2 <span class="keyword">(</span>aux pf<span class="keyword">)</span> <span class="keyword">end</span>
  <span class="keyword">end</span> <span class="comment">// end of [sif]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_commute]</span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="comment">// end of [local]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_is_commutative">mul_is_commutative</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_is_commutative
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">,</span>q<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">q</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p==q<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function is just a slight variation of <span class="patsyntaxdynexp">mul_commute</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_8.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_is_commutative <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> mul_isfun <span class="keyword">(</span>mul_commute <span class="keyword">(</span>pf1<span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_distribute">mul_distribute</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_distribute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">+</span><span class="staexp">p2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially proves the identity
<span class="patsyntaxstaexp">m*(n1+n2)=m*n1+m*n2</span> for any given integers m, n1 and n2.  It is
kept mostly for the sake of backward compatibility as the constraint-solver
of ATS2 (Postiats) is able to infer the identity
<span class="patsyntaxstaexp">m*(n1+n2)=m*n1+m*n2</span> automatically.  However, typechecking the
following implementation of <span class="patsyntaxdynexp">mul_distribute</span> involves solving only
linear integer constraints:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_9.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_distribute
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">}</span></span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prfun</span> lemma
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">m</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">+</span><span class="staexp">p2</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> MULbas <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>MULind pf1<span class="keyword">,</span> MULind pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULind <span class="keyword">(</span>lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [lemma]</span>
<span class="comment">//</span>
<span class="keyword">in</span> <span class="comment">// in of [let]</span>
<span class="comment">//</span>
<span class="keyword">sif</span> <span class="staexp">m</span> <span class="staexp">&gt;=</span> <span class="staexp">0</span> <span class="keyword">then</span>
  lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
<span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> MULneg pf1 <span class="keyword">=</span> pf1 <span class="keyword">and</span> MULneg pf2 <span class="keyword">=</span> pf2</span>
<span class="keyword">in</span>
  MULneg <span class="keyword">(</span>lemma <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [sif]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [mul_distribute]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_distribute2">mul_distribute2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> mul_distribute2
  <span class="staexp"><span class="keyword">{</span>m1<span class="keyword">,</span>m2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">m1</span><span class="staexp">+</span><span class="staexp">m2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">+</span><span class="staexp">p2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This proof function essentially proves the identity
<span class="patsyntaxstaexp">(m1+m2)*n=m1*n+m2*n</span> for any given integers m1, m2 and n.  It is
kept mostly for the sake of backward compatibility as the constraint-solver
of ATS2 (Postiats) is able to infer the identity
<span class="patsyntaxstaexp">(m1+m2)*n=m1*n+m2*n</span> automatically.  The following
implementation of <span class="patsyntaxdynexp">mul_distribute2</span> is based on
<span class="patsyntaxdynexp">mul_commute</span> and <span class="patsyntaxdynexp">mul_distribute</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arith_prf_10.dats"><span class="prfexp"><span class="keyword">primplmnt</span>
mul_distribute2 <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span>
  mul_commute <span class="keyword">(</span>mul_distribute <span class="keyword">(</span>mul_commute <span class="keyword">(</span>pf1<span class="keyword">)</span><span class="keyword">,</span> mul_commute <span class="keyword">(</span>pf2<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [mul_distribute2]</span>
</pre>


<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="mul_is_associative">mul_is_associative</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
mul_is_associative
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">,</span>z<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>xy<span class="keyword">,</span>yz<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>xy_z<span class="keyword">,</span>x_yz<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">xy</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">z</span><span class="keyword">,</span> <span class="staexp">yz</span><span class="keyword">)</span>
<span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">xy</span><span class="keyword">,</span> <span class="staexp">z</span><span class="keyword">,</span> <span class="staexp">xy_z</span><span class="keyword">)</span><span class="keyword">,</span> pf4<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">yz</span><span class="keyword">,</span> <span class="staexp">x_yz</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>xy_z==x_yz<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This proof function essentially proves <span class="patsyntaxstaexp">(x*y)*z=x*(y*z)</span> for any
given integers x, y and z.  It is kept mostly for the sake of backward
compatibility as the constraint-solver of ATS2 (Postiats) is able to infer
the identity <span class="patsyntaxstaexp">(x*y)*z=x*(y*z)</span> automatically.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="DIVMOD">DIVMOD</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="staexp"><span class="keyword">absprop</span>
DIVMOD <span class="keyword">(</span>
  x<span class="keyword">:</span>int<span class="keyword">,</span> y<span class="keyword">:</span> int<span class="keyword">,</span> q<span class="keyword">:</span> int<span class="keyword">,</span> r<span class="keyword">:</span> int <span class="comment">// x = q * y + r</span>
<span class="keyword">)</span></span> <span class="comment">// end of [DIVMOD]</span></pre>
<h3>Description</h3>

Given integers x, y, q, r, the prop <span class="patsyntaxstaexp">DIVMOD(x, y, q, r)</span>
captures that <span class="patsyntaxstaexp">x=q*y+r</span> holds and r is natural number less than
y.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="div_istot">div_istot</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
div_istot
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span> x &gt;= 0<span class="keyword">;</span> y <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">DIV</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">x</span><span class="staexp">/</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="divmod_istot">divmod_istot</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
divmod_istot
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span>
   x &gt;= 0<span class="keyword">;</span> y <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>q<span class="keyword">,</span>r<span class="keyword">:</span>nat <span class="keyword">|</span> r <span class="keyword">&lt;</span> y<span class="keyword">]</span></span> <span class="staexp">DIVMOD</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">q</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="divmod_isfun">divmod_isfun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
divmod_isfun
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span> x &gt;= 0<span class="keyword">;</span> y <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>q1<span class="keyword">,</span>q2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>r1<span class="keyword">,</span>r2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">DIVMOD</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">q1</span><span class="keyword">,</span> <span class="staexp">r1</span><span class="keyword">)</span>
<span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">DIVMOD</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">q2</span><span class="keyword">,</span> <span class="staexp">r2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>q1==q2<span class="keyword">;</span>r1==r2<span class="keyword">]</span></span> <span class="staexp">void</span></span> <span class="comment">// end of [divmod_isfun]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="divmod_elim">divmod_elim</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
divmod_elim
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>int <span class="keyword">|</span> x &gt;= 0<span class="keyword">;</span> y <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>q<span class="keyword">,</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  pf<span class="keyword">:</span> <span class="staexp">DIVMOD</span> <span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">q</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>qy<span class="keyword">:</span>nat <span class="keyword">|</span> 0 &lt;= r<span class="keyword">;</span> r <span class="keyword">&lt;</span> y<span class="keyword">;</span> x==qy+r<span class="keyword">]</span></span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">q</span><span class="keyword">,</span> <span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">qy</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="EXP2">EXP2</a></h2>
<h3>Synopsis</h3>
<p>The dataprop <span class="patsyntaxstaexp">EXP2</span> is declared as follows:
<pre class="patsyntax">
<span class="keyword">dataprop</span> <span class="staexp">EXP2 <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>nat<span class="keyword">}</span></span> EXP2ind <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">2</span><span class="staexp">*</span><span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp">EXP2bas <span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [EXP2]</span>
</pre>
</p>
<h3>Description</h3>

Given integers n and p, the prop <span class="patsyntaxstaexp">EXP2(n, p)</span> captures the
relation that <span class="patsyntaxstaexp">2^n=p</span> holds and n is a natural number.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_exp2_param">lemma_exp2_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> lemma_exp2_param <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>n&gt;=0<span class="keyword">;</span>p&gt;=1<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp2_istot">exp2_istot</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> exp2_istot <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp2_isfun">exp2_isfun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> exp2_isfun <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp2_ispos">exp2_ispos</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> exp2_ispos
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p &gt;= 1<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp2_is_mono">exp2_is_mono</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> exp2_is_mono
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat <span class="keyword">|</span> n1 &lt;= n2<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1 &lt;= p2<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp2_muladd">exp2_muladd</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span> exp2_muladd
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat <span class="keyword">|</span> n1 &lt;= n2<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">,</span> pf3<span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">p1</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span> <span class="comment">// end of [exp2_muladd]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="EXP">EXP</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="staexp"><span class="keyword">absprop</span> EXP <span class="keyword">(</span>int<span class="comment">(*base*)</span><span class="keyword">,</span> int<span class="comment">(*power*)</span><span class="keyword">,</span> int<span class="comment">(*res*)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given integers b, n and p, the prop <span class="patsyntaxstaexp">EXP(b, n, p)</span> captures the
relation that <span class="patsyntaxstaexp">b^n=p</span> holds and n is a natural number, where b^n
refers to the exponential function for base b and exponent n.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_exp_param">lemma_exp_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> lemma_exp_param
  <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_istot">exp_istot</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_istot <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_isfun">exp_isfun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_isfun <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1==p2<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_0">exp_elim_0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_0 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p==0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_1">exp_elim_1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p==1<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_2">exp_elim_2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_2 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">EXP2</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_b_0">exp_elim_b_0</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_b_0 <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p==1<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_b_1">exp_elim_b_1</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_b_1 <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p==b<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_elim_b_2">exp_elim_b_2</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_elim_b_2 <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">MUL</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">p</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_muladd">exp_muladd</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_muladd
  <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>p<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">p1</span><span class="staexp">*</span><span class="staexp">p2</span><span class="keyword">)</span></span> <span class="comment">// end of [exp_muladd]</span></pre>
<h3>Description</h3>

This proof function proves <span class="patsyntaxstaexp">b^(n1+n2)=(b^n1)*(b^n2)</span> for integer
b and natural numbers n1, n2.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="exp_expmul">exp_expmul</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span> exp_expmul
  <span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bn1<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bn1n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  pf1<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">,</span> <span class="staexp">bn1</span><span class="keyword">)</span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">bn1</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">bn1n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">EXP</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">*</span><span class="staexp">n2</span><span class="keyword">,</span> <span class="staexp">bn1n2</span><span class="keyword">)</span></span> <span class="comment">// end of [exp_muladd]</span></pre>
<h3>Description</h3>

This proof function proves <span class="patsyntaxstaexp">(b^n1)^n2=b^(n1*n2)</span> for integer b
and natural numbers n1, n2.



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

