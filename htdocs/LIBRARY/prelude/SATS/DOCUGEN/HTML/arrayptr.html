
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/arrayptr</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/arrayptr</h1>


<p>
This package contains some common functions for creating/freeing and
manipulating arrayptr-values.

</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#arrayptr">arrayptr</a></li>
<li><a href="#arrayptr_vt0ype_addr_int_vtype">arrayptr_vt0ype_addr_int_vtype</a></li>
<li><a href="#arrayptrout">arrayptrout</a></li>
<li><a href="#arrayptrout_vt0ype_addr_int_vtype">arrayptrout_vt0ype_addr_int_vtype</a></li>
<li><a href="#arrayptr_encode">arrayptr_encode</a></li>
<li><a href="#arrayptr2ptr">arrayptr2ptr</a></li>
<li><a href="#arrayptrout2ptr">arrayptrout2ptr</a></li>
<li><a href="#arrayptr_takeout">arrayptr_takeout</a></li>
<li><a href="#arrayptr_addback">arrayptr_addback</a></li>
<li><a href="#arrayptr_make_elt">arrayptr_make_elt</a></li>
<li><a href="#arrayptr_make_intrange">arrayptr_make_intrange</a></li>
<li><a href="#arrayptr_make_arrpsz">arrayptr_make_arrpsz</a></li>
<li><a href="#arrayptr_make_list">arrayptr_make_list</a></li>
<li><a href="#arrayptr_make_rlist">arrayptr_make_rlist</a></li>
<li><a href="#arrayptr_make_subarray">arrayptr_make_subarray</a></li>
<li><a href="#arrayptr_make_list_vt">arrayptr_make_list_vt</a></li>
<li><a href="#arrayptr_make_uninitized">arrayptr_make_uninitized</a></li>
<li><a href="#arrayptr_imake_list">arrayptr_imake_list</a></li>
<li><a href="#arrayptr_free">arrayptr_free</a></li>
<li><a href="#arrayptr_get_at">arrayptr_get_at</a></li>
<li><a href="#arrayptr_get_at_gint">arrayptr_get_at_gint</a></li>
<li><a href="#arrayptr_get_at_guint">arrayptr_get_at_guint</a></li>
<li><a href="#arrayptr_set_at">arrayptr_set_at</a></li>
<li><a href="#arrayptr_set_at_gint">arrayptr_set_at_gint</a></li>
<li><a href="#arrayptr_set_at_guint">arrayptr_set_at_guint</a></li>
<li><a href="#arrayptr_exch_at">arrayptr_exch_at</a></li>
<li><a href="#arrayptr_exch_at_gint">arrayptr_exch_at_gint</a></li>
<li><a href="#arrayptr_exch_at_guint">arrayptr_exch_at_guint</a></li>
<li><a href="#fprint_arrayptr">fprint_arrayptr</a></li>
<li><a href="#fprint_arrayptr_sep">fprint_arrayptr_sep</a></li>
<li><a href="#arrayptr_foreach">arrayptr_foreach</a></li>
<li><a href="#arrayptr_foreach_env">arrayptr_foreach_env</a></li>
<li><a href="#arrayptr_foreach_funenv">arrayptr_foreach_funenv</a></li>
<li><a href="#arrayptr_foreach_fun">arrayptr_foreach_fun</a></li>
<li><a href="#arrayptr_rforeach">arrayptr_rforeach</a></li>
<li><a href="#arrayptr_rforeach_env">arrayptr_rforeach_env</a></li>
<li><a href="#arrayptr_initize">arrayptr_initize</a></li>
<li><a href="#arrayptr_uninitize">arrayptr_uninitize</a></li>
<li><a href="#arrayptr_freelin">arrayptr_freelin</a></li>
<li><a href="#arrayptr_tabulate">arrayptr_tabulate</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#[]">[]</a></li>
<li><a href="#ptrcast">ptrcast</a></li>
<li><a href="#free">free</a></li>
<li><a href="#fprint">fprint</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="arrayptr">arrayptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">stadef</span>
<span class="staexp">arrayptr <span class="keyword">=</span> <span class="staexp">arrayptr_vt0ype_addr_int_vtype</span></span></pre>
<pre class="patsyntax">
<span class="keyword">vtypedef</span>
<span class="staexp">arrayptr
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr <span class="keyword">with</span> arrayptr_make_arrpsz</span></pre>
<h3>Description</h3>

Given a type T, an address L and an integer N, the type
<span class="patsyntaxstaexp">arrayptr(T, L, N)</span> is for a linear array located at L that
stores N elements of the type T.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_vt0ype_addr_int_vtype">arrayptr_vt0ype_addr_int_vtype</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="staexp"><span class="keyword">absvtype</span>
arrayptr_vt0ype_addr_int_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt0ype+</span><span class="keyword">,</span> l<span class="keyword">:</span> addr<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr <span class="keyword">(</span>l<span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptrout">arrayptrout</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">stadef</span> <span class="staexp">arrayptrout <span class="keyword">=</span> <span class="staexp">arrayptrout_vt0ype_addr_int_vtype</span></span></pre>
<h3>Description</h3>

Given a type T, an address L and an integer N, the type
<span class="patsyntaxstaexp">arrayptrout(T, L, N)</span> essentially means <span class="patsyntaxstaexp">arrayptr(T, L,
N)</span> minus the array-view <span class="patsyntaxstaexp">array_v(T, L, N)</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptrout_vt0ype_addr_int_vtype">arrayptrout_vt0ype_addr_int_vtype</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="staexp"><span class="keyword">absvtype</span>
arrayptrout_vt0ype_addr_int_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">,</span> l<span class="keyword">:</span> addr<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr <span class="keyword">(</span>l<span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_encode">arrayptr_encode</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
arrayptr_encode <span class="keyword">:</span>
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">mfree_gc_v</span> <span class="staexp">l</span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr2ptr">arrayptr2ptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
arrayptr2ptr
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptrout2ptr">arrayptrout2ptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
arrayptrout2ptr
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptrout</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_takeout">arrayptr_takeout</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
arrayptr_takeout
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">arrayptrout</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_takeout]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_addback">arrayptr_addback</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
arrayptr_addback
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">array_v</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptrout</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [arrayptr_addback]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_elt">arrayptr_make_elt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p
<span class="keyword">}</span></span> arrayptr_make_elt
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an arrayptr-value of a given size
(first argument) and then initializes it with a given value
(second argument) of some non-linear type.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_intrange">arrayptr_make_intrange</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> arrayptr_make_intrange
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>r<span class="keyword">:</span>int <span class="keyword">|</span> l &lt;= r<span class="keyword">}</span></span>
  <span class="keyword">(</span>l<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">l</span><span class="keyword">,</span> r<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">r</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">intBtw</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">r</span><span class="staexp">-</span><span class="staexp">l</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an arrayptr-value of size r-l that contains the
integers from l until r-1, inclusive.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_arrpsz">arrayptr_make_arrpsz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
arrayptr_make_arrpsz
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>psz<span class="keyword">:</span> <span class="staexp">arrpsz</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">arrayptr</span>, turns an
arrpsz-value (arrayptr-with-size) into an arrayptr-value. It can be
conveniently called to build an array of fixed size.

<h3>Example</h3>

The following code builds an array of digits, prints them out and then
frees the array:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arrayptr_0.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">0</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
  <span class="dynexp"><span class="keyword">val</span> A <span class="keyword">=</span> <span class="keyword">(</span>arrayptr<span class="keyword">)</span><span class="keyword">$arrpsz</span><span class="keyword">{</span><span class="staexp">int</span><span class="keyword">}</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_arrayptr_sep&lt;<span class="staexp">int</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> A<span class="keyword">,</span> g1int2uint<span class="keyword">(</span><span class="dynexp">10</span><span class="keyword">)</span><span class="keyword">,</span> <span class="dynstr">", "</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> arrayptr_free <span class="keyword">(</span>A<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_list">arrayptr_make_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
arrayptr_make_list<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an arrayptr-value of a given size n (first argument)
and then initializes it with a given list (second argument) of length n.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_rlist">arrayptr_make_rlist</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
arrayptr_make_rlist<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an arrayptr-value of a given size n (first argument)
and then initializes it with the reverse of a given list (second argument)
of length n.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_subarray">arrayptr_make_subarray</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
arrayptr_make_subarray
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>st<span class="keyword">,</span>ln<span class="keyword">:</span>int <span class="keyword">|</span> st+ln &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">arrayref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">st</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">ln</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">ln</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a non-linear array A of size n and two non-negative integers st and
ln satisfying st+ln <= n, this function returns a linear array A2 of size
ln such that the value in each A2[i] equals the value in A[st+i], where i
ranges from 0 until ln-1, inclusive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_list_vt">arrayptr_make_list_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_make_list_vt<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an arrayptr-value of a given size n (first argument)
and then initializes it with the reverse of a given linear list (second
argument) of length n. Note that the linear list is consumed after the
function returns.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_make_uninitized">arrayptr_make_uninitized</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_make_uninitized
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function creates an uninitialized arrayptr-value of a given size.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_imake_list">arrayptr_imake_list</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_imake_list<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?!</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_imake_list]</span></pre>
<h3>Description</h3>

This function copies out the elements in a given arrayptr-value to form a
linear list. In the case where the elements are linear, the array becomes
uninitialized after the function returns. Note that the name
<span class="patsyntaxdynexp">imake</span> is a shorthand for inverse-make in the sense that the
function may alternatively be named <span class="patsyntaxdynexp">list_make_arrayptr</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_free">arrayptr_free</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> arrayptr_free
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">free</span>, frees the
memory occupied by a given arrayptr-value that contains only non-linear
elements. If there are linear elements involved, please try to use the
function <span class="patsyntaxdynexp">arrayptr_freelin</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_get_at">arrayptr_get_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_get_at <span class="keyword">with</span> arrayptr_get_at_gint</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_get_at <span class="keyword">with</span> arrayptr_get_at_guint</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_get_at_gint">arrayptr_get_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_get_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function reads out the non-linear value stored at cell i of the array
associated with its first argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_get_at_guint">arrayptr_get_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_get_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, is like
<span class="patsyntaxdynexp">arrayptr_get_at_gint</span> except that the index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_set_at">arrayptr_set_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_set_at <span class="keyword">with</span> arrayptr_set_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_set_at <span class="keyword">with</span> arrayptr_set_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_set_at_gint">arrayptr_set_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_set_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function writes a non-linear value x to cell i of the array associated
with its first argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_set_at_guint">arrayptr_set_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>t0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_set_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function, which overloads the symbol <span class="patsyntaxdynexp">[]</span>, is like
<span class="patsyntaxdynexp">arrayptr_set_at_gint</span> except that the index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_exch_at">arrayptr_exch_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_exch_at <span class="keyword">with</span> arrayptr_exch_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> arrayptr_exch_at <span class="keyword">with</span> arrayptr_exch_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_exch_at_gint">arrayptr_exch_at_gint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_exch_at_gint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1int</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function exchanges the content of cell i of the array associated with
its first argument and that of the variable x (its third argument). Note
that the type for these contents can be linear. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_exch_at_guint">arrayptr_exch_at_guint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>tk<span class="keyword">:</span>tk
<span class="keyword">}</span></span> arrayptr_exch_at_guint
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">g1uint</span> <span class="keyword">(</span><span class="staexp">tk</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">arrayptr_exch_at_gint</span> except that the
index is unsigned.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_arrayptr">fprint_arrayptr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_arrayptr
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_arrayptr]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_arrayptr_sep">fprint_arrayptr_sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_arrayptr_sep
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">,</span> A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_arrayptr_sep]</span></pre>
<h3>Description</h3>

This function prints the elements in a given array to the output channel
provided as its first argument, interspersing the string <span class="patsyntaxdynexp">sep</span>
between the printed array elements. Note that printing each array element is
handled by calling the function <span class="patsyntaxdynexp">fprint_ref</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_foreach">arrayptr_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> arrayptr_foreach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_foreach]</span></pre>
<h3>Description</h3>


This function traverses the array associated with a given arrayptr-value
from left to right, applying the function implemented by
<span class="patsyntaxdynexp">arrayptr_foreach$fwork</span> to each cell in the array.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_foreach_env">arrayptr_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> arrayptr_foreach_env<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_foreach_env]</span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">arrayptr_foreach</span>
except for taking an additional argument that serves as an environment (for
recording changes).  <h3>Example</h3>

The following code creates an array of integers, computes the sum of the
integers in the created array and then frees it.

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_arrayptr_1.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">10</span></span>
<span class="dynexp"><span class="keyword">val</span> asz <span class="keyword">=</span> g1int2uint <span class="keyword">(</span>N<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> A <span class="keyword">=</span> arrayptr_make_intrange <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> N<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">a <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="keyword">typedef</span> <span class="staexp">tenv <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="keyword">var</span> ans<span class="keyword">:</span> <span class="staexp">tenv</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="dynexp"><span class="keyword">implement</span>
array_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">tenv</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := env + x</span>
<span class="dynexp"><span class="keyword">val</span> _<span class="comment">(*ignored*)</span> <span class="keyword">=</span> arrayptr_foreach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">tenv</span><span class="keyword">&gt;</span> <span class="keyword">(</span>A<span class="keyword">,</span> asz<span class="keyword">,</span> ans<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> arrayptr_free <span class="keyword">(</span>A<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> assertloc <span class="keyword">(</span>ans <span class="keyword">=</span> N*<span class="keyword">(</span>N-<span class="dynexp">1</span><span class="keyword">)</span>/<span class="dynexp">2</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_foreach_funenv">arrayptr_foreach_funenv</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_foreach_funenv
  <span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>view<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>vt<span class="keyword">:</span>vtype<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>fe<span class="keyword">:</span>eff<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfv<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">v</span></span>
<span class="keyword">|</span> A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">v</span> <span class="keyword">|</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">vt</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp"><span class="keyword">fun</span></span><span class="keyword">,</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">vt</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is like <span class="patsyntaxdynexp">arrayptr_foreach</span> except that the function
to be applied to each array cell is provided as an argument.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_foreach_fun">arrayptr_foreach_fun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_foreach_fun
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>fe<span class="keyword">:</span>eff<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp"><span class="keyword">fun</span></span><span class="keyword">,</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [arrayptr_foreach_fun]</span></pre>
<h3>Description</h3>

This function is a special case of <span class="patsyntaxdynexp">arrayptr_foreach_funenv</span> in
that the provided function does not take an argument as its environment.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_rforeach">arrayptr_rforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> arrayptr_rforeach<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_rforeach]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_rforeach_env">arrayptr_rforeach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> arrayptr_rforeach_env<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [arrayptr_rforeach_env]</span></pre>
<h3>Description</h3>

This function does essentially the same as <span class="patsyntaxdynexp">arrayptr_rforeach</span>
except for taking an additional argument that serves as an environment.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_initize">arrayptr_initize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_initize
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [arrayptr_initize]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_uninitize">arrayptr_uninitize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_uninitize
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [arrayptr_uninitize]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_freelin">arrayptr_freelin</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_freelin
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function first uninitializes a given arrayptr-value and then frees the
memory occupied by it. In other words, <span class="patsyntaxdynexp">arrayptr_freelin</span>
combines <span class="patsyntaxdynexp">arrayptr_uninitize</span> with <span class="patsyntaxdynexp">arrayptr_free</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="arrayptr_tabulate">arrayptr_tabulate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
arrayptr_tabulate
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">arrayptr</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a non-negative integer n, this function returns a linear array A of
size n such that A is initialized from left to right by storing into A[i]
the value returned from a call to <span class="patsyntaxdynexp">array_tabulate$fopr</span> on i,
where i ranges from 0 until n-1, inclusive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayptr_get_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayptr_get_at_guint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayptr_set_at_gint <span class="keyword">of</span> 0</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> arrayptr_set_at_guint <span class="keyword">of</span> 0</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="ptrcast">ptrcast</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> ptrcast <span class="keyword">with</span> arrayptr2ptr</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> ptrcast <span class="keyword">with</span> arrayptrout2ptr</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="free">free</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> free <span class="keyword">with</span> arrayptr_free</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint">fprint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_arrayptr</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_arrayptr_sep</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

