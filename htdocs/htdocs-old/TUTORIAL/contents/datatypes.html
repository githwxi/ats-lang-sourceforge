<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .atsyntax {color:#E80000;background-color:#E0E0E0}
    .atsyntax span.comment {color:#787878;font-style:italic}
    .atsyntax span.extern  {color:#A52A2A}
    .atsyntax span.keyword {color:#000000;font-weight:bold}
    .atsyntax span.neuexp  {color:#800080}
    .atsyntax span.staexp  {color:#0000FF}
    .atsyntax span.dynexp  {color:#E80000}
    .atsyntax span.prfexp  {color:#009000}
    .atsyntax span.stacstdec  {text-decoration:none}
    .atsyntax span.stacstuse  {color:#0000CF;text-decoration:underline}
    .atsyntax span.dyncstdec  {text-decoration:none}
    .atsyntax span.dyncstimp  {color:#B80000;text-decoration:underline}
    .atsyntax span.dyncstuse  {color:#B80000;text-decoration:underline}
    .atsyntax body {color:#E80000;background-color:#E0E0E0}
  </style>
</head>
<!--
<html>
<head>
<style type="text/css">
span.comment {color:787878;font-style:italic}
span.extern  {color:A52A2A}
span.keyword {color:000000;font-weight:bold}
span.neuexp  {color:800080}
span.staexp  {color:0000FF}
span.dynexp  {color:E80000}
span.prfexp  {color:009000}
</style>
</head>
-->
<body text="#000000" bgcolor="#ffffff" link="#0000FF" vlink="#CC00CC" alink="#ff0000">
<!--
The file is automatically generated by [atsdoc] from datatypes.atxt.
-->
<!--
Time of Generation: Mon Aug 22 15:00:08 2011
-->
<!--beg of [datatypes.html]-->

<H2><A id="datatypes" name="datatypes">Datatypes</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of datatypes in ATS is directly adopted from ML. In addition to
what is available in ML, we can also form in ATS dependent datatypes and
guarded recursive datatypes (GRDTs), also known as generalized algebraic
datatypes (GADTs). There is also a form of linear datatypes (dataviewtypes)
available in ATS, which is to be explained elsewhere.

<H4>A Simple Datatype</H4>
In the first example given below, a datatype type <i>intlst0</i>
is declared to represent lists of integers and a function
<i>length_intlst0</i> for computing the length of a given
list is implemented:


<pre class="atsyntax">
<span class="keyword">datatype</span> <span class="staexp"><a name="9"><span class="stacstdec">intlst0</span></a></span> <span class="keyword">=</span> <span class="comment">// simple datatype
</span>  <span class="keyword">|</span> INTLST0nil <span class="comment">// the first bar (|) is optional
</span>  <span class="keyword">|</span> INTLST0cons <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>int<span class="keyword">,</span> intlst0<span class="keyword">)</span></span>

<span class="keyword">fun</span> length_intlst0 <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span> <span class="comment">// [case+] demands exhaustive pattern matching
</span>  <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="keyword">|</span> INTLST0cons <span class="keyword">(</span>_<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> 1 + length_intlst0 <span class="keyword">(</span>xs<span class="keyword">)</span>
  <span class="keyword">|</span> INTLST0nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="comment">// end of [length_intlst0]
</span></pre>
<!--atscode2xmld-->

Please note that any valid identifiers for variables can also be used as
identifiers for constructors. The pattern for a constructor <i>C</i> with
no arguments is <i>C( )</i>. If we write <i>C</i> instead of <i>C( )</i>,
then <i>C</i> is assumed to be a variable pattern, which matches any value.
<P>

<H4>A Dependent Datatype</H4>
In ATS, we can form a dependent datatype <i>intlst1</i> as follows to
represent integer lists:


<pre class="atsyntax">
<span class="keyword">datatype</span> <span class="staexp"><a name="9"><span class="stacstdec">intlst1 <span class="keyword">(</span>int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span> <span class="comment">// dependent datatype
</span>  <span class="keyword">|</span> INTLST1nil <span class="staexp"><span class="keyword">(</span>0<span class="keyword">)</span></span> <span class="comment">// the first bar (|) is optional
</span>  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> INTLST1cons <span class="staexp"><span class="keyword">(</span>n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>int<span class="keyword">,</span> intlst1 n<span class="keyword">)</span></span>
<span class="comment">// end of [intlst1]
</span></pre>


We may see <i>intlst1</i> as a refinement of <i>intlst0</i>.  Given an
integer <i>n</i>, <i>intlst1(n)</i> is a type for integer lists of length
<i>n</i>. The syntax for declaring <i>intlst1</i> introduces
two constructors of the following types:

<pre>
INTLST1nil : intlst1 0
INTLST1cons : {n:nat} (int, intlst1 n) -> intlst (n+1)
</pre>

So <i>INTLST1nil</i> is a list of length <i>0</i> and
<i>INTLST1cons</i> constructs a list of length <i>n+1</i>
if given an integer and an integer list of length <i>n</i>.
<P>

The function for computing the length of a given integer list can now
be implemented as follows:


<pre class="atsyntax">
<span class="keyword">fun</span> length_intlst1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst1 n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int n</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span> <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="keyword">|</span> INTLST1cons <span class="keyword">(</span>_<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> 1 + length_intlst1 <span class="keyword">(</span>xs<span class="keyword">)</span>
  <span class="keyword">|</span> INTLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="comment">// end of [length_intlst1]
</span></pre>


Note that <i>length_intlst1</i> is assigned the following type:

<pre>
{n:nat} intlst1 n -> int n
</pre>

which clearly indicates that the returned value of a call to
<i>length_intlst1</i> is the length of the argument of the call.
<P>

As another example, the following code implements the list subscripting
function:


<pre class="atsyntax">
<span class="comment">// the index is a natural number less than the size of the indexed length
</span><span class="keyword">fun</span> nth_intlst1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 &lt;= i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst1 n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="comment">// [val+] demands exhaustive pattern matching
</span>  <span class="keyword">let</span> <span class="keyword">val+</span> INTLST1cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs <span class="keyword">in</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> nth_intlst1 <span class="keyword">(</span>xs<span class="keyword">,</span> i-1<span class="keyword">)</span> <span class="keyword">else</span> x
  <span class="keyword">end</span> <span class="comment">// end of [let]
</span><span class="comment">// end of [nth_intlst1]
</span></pre>


Note that the pattern matching involved in the value declaration
<i>val+ INTLST1cons (x, xs) = xs</i> is
guaranteed to be exhaustive as <i>n</i> is positive. As a consequence, there
is no tag checking in the C code generated from the compilation of
<i>nth_intlst</i>. This simple example demonstrates that safety can
actually enhance efficiency.

<H4>A Polymorphic Datatype</H4> We can declare a datatype <i>list</i> as follows for
representing polymorphic lists:


<pre class="atsyntax">
<span class="comment">// [t@ype] is a sort for types of unrestricted size
</span><span class="keyword">datatype</span> <span class="staexp"><a name="61"><span class="stacstdec">list <span class="keyword">(</span>a<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span> <span class="comment">// polymorphic datatype
</span>  <span class="keyword">|</span> nil <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> 0<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> cons <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span></span>
</pre>


The syntax used for declaring <i>list</i> introduces
two constructors of the following types:

<pre>
nil : {a:t@ype} list (a, 0)
cons : {a:t@ype} {n:nat} (a, list (a, n)) -> list (a, n+1)
</pre>

We use <i>a:t@ype+</i> (instead of <i>a:t@ype</i>) to indicate that the type
constructor <i>list</i> is covariant at this argument, that is,
<i>list (T1, n)</i> is considered to be a subtype of
<i>list (T2, n)</i> whenever <i>T1</i> is a subtype of <i>T2</i>.
<P>

The function for appending two polymorphic lists can be implemented as
follows:


<pre class="atsyntax">
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
append_list <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> m<span class="keyword">)</span></span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> m+n<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>x<span class="keyword">,</span> append_list <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
<span class="comment">// end of [append_list]
</span></pre>


This function definition is a template. It can be typechecked but cannot be
compiled until the type variable <i>a</i> is instantiated with a type of
known size. The feature of templates in ATS is to be explained elsewhere.
<P>

As another example, the following code implements a (template) function
that zips together two given lists of the same length:


<pre class="atsyntax">
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a1<span class="keyword">,</span>a2<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
zip_list <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a1<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a2<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span><span class="keyword">'(</span>a1<span class="keyword">,</span> a2<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>cons <span class="keyword">(</span>x1<span class="keyword">,</span> xs1<span class="keyword">)</span><span class="keyword">,</span> cons <span class="keyword">(</span>x2<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span><span class="keyword">'(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span><span class="keyword">,</span> zip_list <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=/=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// none of these cases can occur
</span><span class="comment">// end of [zip_list]
</span></pre>


Note that the last clause in the definition of <i>zip_list</i> is presented
only for the purpose of illustration, and it can simply be omitted.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="datatypes.dats">here</a>.

<!-- end of [datatypes.html] -->



</body>
</html>
