<HTML>
<HEAD>
<TITLE>Home Page for ATS-tutorial-all</TITLE>
<META name="description" content="Home Page for ATS-tutorial-all">
<META name="keywords" content="">
<STYLE TYPE="text/css">
.atsyntax {color:#E80000;background-color:#E0E0E0}
.atsyntax span.comment {color:787878;font-style:italic}
.atsyntax span.extern  {color:A52A2A}
.atsyntax span.keyword {color:000000;font-weight:bold}
.atsyntax span.neuexp  {color:800080}
.atsyntax span.staexp  {color:0000FF}
.atsyntax span.dynexp  {color:E80000}
.atsyntax span.prfexp  {color:009000}
</STYLE>
</HEAD>
<BODY text="#000000" bgcolor="#ffffff" link="#0000FF" vlink="#CC00CC" alink="#ff0000">

<CENTER>
<H1><A id="top" name="top">Tutorial on ATS/Anairiats</A></H1>
<H4>(all topics in one file)</H4>
</CENTER>

<HR SIZE=6 ALIGN=LEFT COLOR="000000">

<H2>Primary Tutorial Topics</H2>
<MENU>
<LI> <A href="#syntax-coloring">Syntax Coloring</A>
<LI> <A href="#basics">Basics</A>
<LI> <A href="#file-inclusion">File Inclusion</A>
<LI> <A href="#filename-extensions">Filename Extensions</A>
<LI> <A href="#compilation">Compilation</A>
<LI> <A href="#ats-main">The Main Function in ATS</A>
<LI> <A href="#fixity">Fixity Declaration</A>
<LI> <A href="#overloading">Overloading</A>
<LI> <A href="#macros">Macros</A>
<LI> <A href="#function-or-closure">Function or Closure?</A>
<LI> <A href="#variadicity">Variadic Functions</A>
<LI> <A href="#tailrecfun">Tail-Recursive Functions</A>
<LI> <A href="#termination-metrics">Termination Metrics</A>
<LI> <A href="#types-with-effects">Types with Effects</A>
<LI> <A href="#templates">Parametric Polymorphism and Templates</A>
<LI> <A href="#lists">(Persistent) Lists</A>
<LI> <A href="#val-and-var">Val(ue) and Var(iable) Declarations</A>
<LI> <A href="#call-by-reference">Call-By-Reference</A>
<LI> <A href="#pointers">Pointers</A>
<LI> <A href="#references">References</A>
<LI> <A href="#arrays-and-matrices">Arrays and Matrices</A>
<LI> <A href="#linear-arrays">Linear Arrays</A>
<LI> <A href="#strings">Strings and String Bufferes</A>
<LI> <A href="#datatypes">Datatypes</A>
<LI> <A href="#dataprops">Dataprops</A>
<LI> <A href="#dataviews">Dataviews</A>
<LI> <A href="#dataviewtypes">Dataviewtypes</A>
<LI> <A href="#pattern-matching">Pattern Matching</A>
<LI> <A href="#exceptions">Exceptions</A>
<LI> <A href="#lazy-evaluation">Lazy Evaluation</A>
<LI> <A href="#llazy-evaluation">Linear Lazy Evaluation</A>
<LI> <A href="#input-and-output">Input and Output</A>
<LI> <A href="#ats-and-c">Combining ATS and C</A>
<LI> <A href="#PwTP">Programming with Theorem Proving</A>
</MENU>
<H2>Secondary Tutorial Topics</H2>
<MENU>
<LI> <A href="#castingfun">Casting Functions</A>
<LI> <A href="#stackalloc">Allocation in Stack Frames</A>
<LI> <A href="#statetypes">State Types</A>
<LI> <A href="#looping">Looping Constructs</A>
</MENU>

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [syntax-coloring.html] -->

<H2><A id="syntax-coloring" name="syntax-coloring">Convention for Coloring ATS Syntax</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

ATS is a rich language with a highly expressive type system, and the syntax
of ATS can be a daunting obstacle for beginners trying to understand
ATS code. In order to alleviate this problem, we may employ colors to
differentiate various syntatical components in a program written in ATS.
The convention for coloring ATS syntax is summarized as follows:

<UL>

<LI>
The keywords in ATS are all colored <FONT COLOR="#000000">black</FONT>
(and possibly in bold face).

<LI>
The comments in ATS are all colored <FONT COLOR="#787878">gray</FONT>.

<LI>
The code in the statics of ATS is colored <FONT COLOR="#0000FF">blue</FONT>.

<LI>
The code in the dynamics of ATS is colored <FONT COLOR="#E80000">red</FONT>
unless it represents proofs, for which the <FONT
COLOR="#009000">dark green</FONT> color is used.

<LI>
The external code (in C) is colored <FONT COLOR="#A52A2A">deep brown</FONT>.

</UL>

<HR SIZE=1 ALIGN=LEFT><P>

<!-- end of [syntax-coloring.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [basics.html] -->

<H2><A id="basics" name="basics">Some Basics on ATS</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

ATS consists of a static component (statics), where types are formed and
reasoned about, and a dynamic component (dynamics), where programs are
constructed and evaluated.

<H4>Some Primitive Sorts and Constants</H4>

The statics of ATS is a simply typed language. The types for terms in the
statics are called <em>sorts</em> (so as to avoid potential confusion with
the types for terms in the dynamics) and the terms in it are called
<em>static terms</em>.  We use <i>sigma</i> (or <i>$srt</i>) for sorts and
<i>s</i> (or <i>$strm</i>) for static terms.  The primitive sorts in ATS
include
<i>bool</i>,
<i>char</i>,
<i>int</i>,
<i>prop</i>,
<i>type</i>,
<i>view</i> and
<i>viewtype</i>.
<P>
There are also some primitive constants <i>c</i> in the statics, each of which
is assigned a constant sort (or c-sort, for short) of the following form:

<CENTER>
<i>(sigma_1,...,sigma_n) => sigma</i>
</CENTER>
<P>

Intuitively, given static terms <i>s_1,...,s_n</i> of sorts
<i>sigma_1,...,sigma_n</i>, respectively, <i>c(s_1,...,s_n)</i> is a static
term of sort <i>sigma</i> if <i>c</i> is assigned the c-sort
<i>(sigma_1,...,sigma_n) => sigma</i>. For instance, each boolean value is
given the sort <i>() => bool</i> and each integer is given the c-sort <i>()
=> int</i>. In the following table, we list some of the commonly used
constants in the statics of ATS:

<CENTER>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2>

<TR>
  <TD ALIGN=LEFT></TD>
  <TD ALIGN=CENTER></TD>
  <TD ALIGN=LEFT></TD>
</TR>

<TR>
  <TD><i>~</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int) => int</i></TD>
</TR>

<TR>
  <TD><i>+</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => int</i></TD>
</TR>

<TR>
  <TD><i>-</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => int</i></TD>
</TR>

<TR>
  <TD><i>*</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => int</i></TD>
</TR>

<TR>
  <TD><i>/</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => int</i></TD>
</TR>

<TR>
  <TD><i><</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i><=</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i>></i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i>>=</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i>==</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i><></i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int, int) => bool</i></TD>
</TR>

<TR>
  <TD><i>~</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(bool) => bool</i></TD>
</TR>

<TR>
  <TD><i>&&</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(bool, bool) => bool</i></TD>
</TR>

<TR>
  <TD><i>||</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(bool, bool) => bool</i></TD>
</TR>

<TR>
  <TD><i>bool</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>() => type</i></TD>
</TR>

<TR>
  <TD><i>bool</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(bool) => type</i></TD>
</TR>

<TR>
  <TD><i>int</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>() => type</i></TD>
</TR>

<TR>
  <TD><i>int</i><TD>
  <TD><i>&nbsp; : &nbsp;</i><TD>
  <TD><i>(int) => type</i></TD>
</TR>

</TABLE>
</CENTER>
<P>
Note that many symbols are overloaded in ATS. For instance,
<i>~</i> is for negation on integers as well as on booleans;
<i>bool</i> and <i>int</i> are both sorts and static constants.
In ATS, a type refers to a static term <i>s</i> of sort <i>type</i>. For
instance, <i>bool</i> and <i>bool(true)</i> are types, and <i>int</i> and
<i>int(2+3)</i> are types, too.

<H4>Subset Sorts</H4>
A subset sort is essentially a sort constrained by a predicate. For
instance, we can define a subset sort <i>nat</i> as follows:

<pre>
sortdef nat = {a:int | a >= 0}
</pre>

It is important to note that a subset sort is <em>not</em> regarded as a
(regular) sort. The sole purpose of introducing subset sorts is to provide
a form of syntactic sugar (to be used together with quantifiers), which is
to be explained shortly.  Following are some commonly used subset sorts:

<pre>
sortdef two = {a:nat | a < 2}
sortdef sgn = {a:int | -1 <= a && a <= 1}
sortdef sgn = {a:int | a == -1 || a == 0 || a == 1} // another definition
sortdef pos = {a:int | a > 0}
sortdef neg = {a:int | a < 0}
</pre>

where <i>&&</i> and <i>||</i>
stand for conjunction and disjunction, respectively.
Note that we may also use semicolon <i>;</i> for conjunction. For instance,
the subset sort <i>sgn</i> can be defined as follows:

<pre>
sortdef sgn = {a:int | -1 <= a; a <= 1}
</pre>

<H4>Some Primitive Types and Values</H4>

We use the name <em>dynamic term</em> for a term in the dynamics of ATS and
a value is a dynamic term in a special form (which is to be made clear
later). We have primitive types
<i>bool</i>, <i>char</i>, <i>int</i> and <i>string</i> for booleans,
characters, integers and strings, respectively.  Also, we have types
<i>float</i> and <i>double</i> for floating point numbers with single and
double precision, respectively.
<P>
The syntax for literal characters, literal integers, literal floats and
literal strings is the same as that specified in the ANSI C.
<P>

The use of dependent types in ATS is ubiquitous.  Given a boolean <i>b</i>,
we can form a type <i>bool(b)</i> and the only value that can be assigned
this type is the boolean value <i>b</i>.  In other words, <i>bool(b)</i> is
a singleton type.  Similarly, we can form a type <i>int(i)</i> for each
integer <i>i</i> and the only value that can be assigned this type is the
integer value <i>i</i>.  The dependent types <i>Bool</i> and <i>Int</i>,
which are for boolean values and integer values, respectively, can be
defined as follows in ATS:

<pre>
typedef Bool = [a:bool] bool(a)
typedef Int = [a:int] int(a)
</pre>

where we use <i>[...]</i> for existential quantification.  Given an integer
<i>i</i>, we can form a type <i>string(i)</i> for strings of length
<i>i</i>. The type <i>String</i> for strings is defined as follows:

<pre>
typedef String = [a:nat] string (a)
</pre>

<H4>Guarded and Asserting Types</H4>
Given a proposition <i>B</i>, that is, a static term of sort
<i>bool</i> and a type <i>T</i>, we use the name <em>guarded type</em> for
a type of the form <i>B =) T</i> and the name <em>asserting type</em> for a
type of the form <i>B /\ T</i>.  Intuitively, in order for a value of type
<i>B =) T</i> to be used, which is most likely a function, the guard <i>B</i>
needs to be discharged first. On the other hand, if an expression of type
<i>B /\ T</i> evaluates to a value <i>v</i>, then we know that the
assertion <i>B</i> holds (at the point where <i>v</i> is obtained) and
<i>v</i> is of type <i>T</i>.
<P>

<H4>Elements of Programming</H4>

We use <i>$exp</i> and <i>$typ</i> as meta-variables ranging over
expressions (dynamic terms) and types in ATS.
<P>

<MENU>
<LI><I>Naming and the Environment</I><P>
A critical aspect in programming is to be able to bind names to (complex)
computational objects. For instance, we can bind names to values through
the following syntax:

<pre>
val radius = 1.0
val pi = 3.1415926
val area = pi * radius * radius
</pre>

We can also bind a name to a function value:

<pre>
val square = lam (x: double): double => x * x
val area = pi * square (radius)
</pre>

<LI><I>Tuples</I><P>

Given expressions <i>$exp_1,..., $exp_n</i>, we can form a tuple:

<pre>
<i>'($exp_1,...,$exp_n)</i>
</pre>

of length <i>n</i> such that the <i>i</i>th
component of the tuple is <i>$exp_i</i> for <i>1 <= i <= n</i>. The use of
the quote symbol <i>'</i> is to indicate that the tuple is boxed. For
instance, a pair <i>zero_and_one</i> is formed through the following
syntax:

<pre>
val zero_and_one: '(int, int) = '(0, 1)
</pre>

We can extract the components of a tuple by pattern matching. For instance,
the following syntax binds <i>x</i> and <i>y</i> to <i>0</i> and <i>1</i>:

<pre>
val '(x, y) = zero_and_one
</pre>

If values <i>$exp_1,...,$exp_n</i> are assigned types <i>$typ_1,...,$typ_n</i>,
respectively, then the tuple

<pre>
<i>'($exp_1,...,$exp_n)</i>
</pre>

can be assigned the type

<pre>
<i>'($typ_1,...,$typ_n)</i>
</pre>

There is another kind of tuple in ATS, which is referred to as a flat or an
unboxed tuple. A tuple of this kind is like a struct in C. For instance, a
flat tuple <i>two_and_three</i> is constructed as follows:

<pre>
val two_and_three: @(int, int) = @(2, 3)
</pre>

and its components can be selected through pattern matching as follows:

<pre>
val @(x, y) = two_and_three
</pre>

If values <i>$exp_1,...,$exp_n</i> are assigned types <i>$typ_1,...,$typ_n</i>,
respectively, then the tuple

<pre>
<i>@($exp_1,...,$exp_n)</i>
</pre>

can be assigned the type

<pre>
<i>@($typ_1,...,$typ_n)</i>.
</pre>

Note that the use of the symbol <i>@</i> is optional.
<P>

<LI><I>Records</I><P>

A label <i>$lab</i> is an alphanumeric identifier or an integer.
Given <i>n</i> labels <i>$lab_1, ..., $lab_n</i>
and <i>n</i> expressions <i>$exp_1, ..., $exp_n</i>,
we can form a boxed record:

<pre>
<i>'{ $lab_1=$exp_1,...,$lab_n=$exp_n }</i>
</pre>

If the types of <i>$exp_1, ..., $exp_n</i> are <i>$typ_1, ..., $typ_n</i>,
then this record can be assgined the following type:

<pre>
<i>'{ $lab_1=$typ_1,...,$lab_n=$typ_n }</i>
</pre>

The use of the quote symbol <i>'</i> is to indicate that the record is
boxed. 
<P>

The symbol
<i>'</i> needs to be changed to <i>@</i> (or simply dropped) in order to
form flat or unboxed records.
<P>

<LI><I>Conditionals</I><P>

The syntax for forming a conditional is either

<pre>
<u>if</u> $exp_1 <u>then</u> $exp_2 <u>else</u> $exp3
</pre>

or

<pre>
<u>if</u> $exp_1 <u>then</u> $exp_2
</pre>

In either case, <i>$exp_1</i> needs to be a boolean. In the
former case, the conditional is of type <i>$typ</i> if
both <i>$exp_2</i> and <i>$exp_3</i> are of type
<i>$typ</i>. In the latter case, the conditional is of type
<i>void</i> if <i>$exp_2</i> is of type <i>void</i>.
<P>

<LI><I>Type Annotations</I><P>
The syntax for supplying a type annotation is

<pre>
$exp : $typ
</pre>

For instance, we may write <i>(1+1: Int)</i> to indicate that the
expression <i>1+1</i> can be assigned the type <i>Int</i>. The need for
type annotations is indispensable when advanced programming features in
ATS are involved.
<P>

<LI><I>Function Values</I><P>

We use <i>$var</i> a meta-variable ranging over (dynamic) variables in
ATS. A function argument <i>$funarg</i> may be of the form <i>$var</i>
(unannotated) or <i>$var: $typ</i> (annotated), and a function argument
sequence <i>$funargseq</i> is of the form:

<pre>
<i>$funarg_1,...,$funarg_n</i>
</pre>

where <i>n</i> may equal <i>0</i>.
<P>

A non-recursive function can be constructed based on the following
syntactic form:

<pre>
<u>lam</u> ($funargseq_1) ... ($funargseq_n) {: $typ} <u>=></u> $exp
</pre>

where we use <i>{...}</i> to indicate optional syntax. For instance,
the following function adds two floating numbers of double precision:

<pre>
lam (x: double, y: double): double => x + y
</pre>

The type of this function is <i>(double, double) -> double</i>, that is,
it takes two doubles and returns a double.

The curried version of this function is written as follows:
<pre>
lam (x: double) (y: double): double => x + y
</pre>

The type of this function is <i>double -> (double -> double)</i>, that is,
it takes a double and returns a function that takes a double and returns
a double.
<P>

A recursive function can be constructed based on the following
syntactic form:

<pre>
<u>fix</u> $var ($funargseq_n) ... ($funargseq_n) {: $typ} <u>=></u> $exp
</pre>

As an example, the following function, which is of the type
<i>Nat -> Nat</i>, computes the Fibonacci numbers:

<pre>
fix fib (x: Nat): Nat => if x >= 2 then fib (x-1) + fib (x-2) else x
</pre>

<LI><I>Function Declarations</I><P>

The following form of syntax declares a function named "foo":

<pre>
<u>fun</u> foo ($funargseq_1) ... ($funargseq_n) {: $typ} <u>=</u> $exp
</pre>

In the case where the defined function is not recursive, the keyword
<u>fun</u> may be replaced with the keyword <u>fn</u>. For instance,
we can declare a function as follows to compute Fibonacci numbers:

<pre>
fun fib (x: Nat): Nat = if x >= 2 then fib (x-1) + fib (x-2) else x
</pre>

Alternatively, we may write equivalent code as follows:

<pre>
val fib = fix fib (x: Nat): Nat => if x >= 2 then fib (x-1) + fib (x-2) else x
</pre>

or as follows:

<pre>
val rec fib: Nat -> Nat = lam x => if x >= 2 then fib (x-1) + fib (x-2) else x
</pre>

If we need to declare two functions "foo" and "bar" mutually recursively,
we can use the following form of syntax:

<pre>
<u>fun</u> foo ($funargseq_1_1) ... ($funargseq_1_n1) {: $typ_1} <u>=</u> $exp_1
<u>and</u> bar ($funargseq_2_1) ... ($funargseq_2_n2) {: $typ_2} <u>=</u> $exp_2
</pre>

This form can be further generalized to declare 
<i>n</i> mutual recursive functions for <i>n >= 2 </i>.

As an example, the follow code implements two mutually recursive functions:

<pre>
fun is_even (x: int): bool = if x > 0 then is_odd  (x-1) else true
and is_odd  (x: int): bool = if x > 0 then is_even (x-1) else false
</pre>

<LI><I>Local Bindings</I><P>
A common way to introduce local bindings is through the use of the keyword
<u>let</u>. As an example, the following code defines a function that
computes the roots of a quadratic equation in terms of the efficients
of the equation:

<pre>
// computing roots for [Axx + Bx + C]
fn foo (A: double, B: double, C: double): @(double, double) = let
  val Delta = B * B - 4.0 * A * C
  val () = if Delta < 0.0 then (prerr "no real roots!\n"; exit {void} 1)
  val Delta_sqrt = sqrt (Delta)
  val root1 = (~B + Delta_sqrt) / (2.0 * A)
  val root2 = (~B - Delta_sqrt) / (2.0 * A)
in
  @(root1, root2) // this a flat tuple
end // end of [foo]
</pre>

Note that the variables <i>Delta</i>, <i>Delta_sqrt</i>, <i>root1</i> and
<i>root2</i> are introduced for use only inside the <u>let</u>-expression.
Another form of local binding is introduced through the keyword
<u>where</u> as is shown below:

<pre>
val fact10 = fact 10 where {
  fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
} // end of [fact10]
</pre>

This code is just an equivalent form of the following code:

<PRE>
val fact10 = let
  fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
in
  fact 10
end // end of [fact10]
</PRE>

<LI><I>Sequencing</I><P>

Given expressions <i>$exp_1, ..., $exp_n, $exp_{n+1}</i>, where
<i>n</i> is some natural number, we can sequence them to form the
expression <i>($exp_1; ...; $exp_n; $exp_{n+1})</i>; this expression is
essentially equivalent to the following one in terms of both static and
dynamic semantics:
<PRE>
let val () = $exp_1 ... val () = $exp_n in $exp_{n+1} end
</PRE>
So it is clear that the expressions <i>$exp_1, ..., $exp_n</i> are required
to be of the void type; the type of the sequence expression is the type of
its last component <i>$exp_{n+1}</i>. If <i>$exp_{n+1}</i> is omitted, the
default is the expression <i>()</i>, which represents the void value, that
is, the only value of the void type.

</MENU>

<H4>Comments</H4>
There are currently three forms of comments in ATS/Anairiats.
<UL>

<LI>

A line comment starts with a double slash "//" and ends with a newline
character.

<LI>
A rest-of-file comment starts with a quadruple slash "////" and ends at the
end of the file in which this comment occurs. This style is often useful
for debugging or testing.

<LI>
An enclosed comment starts with the symbol "(*" and ends with "*)". Such
comments can be embedded in one another.

</UL>

As in C, it is also possible to comment out a piece of code in ATS as
follows:

<pre>
#if 0 #then // [#then] is optional

(all the code here is commented out)

#endif
</pre>

The only requirement is that the code that is commented out must represent
a list of syntactically correct declarations in ATS.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <A HREF="basics.dats">here</A>.

<!-- end of [basics.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [filename-extensions.html] -->

<H2><A id="filename-extensions" name="filename-extensions">Filename
Extensions</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

In ATS, we use the filename extensions ".sats" and ".dats" to indicate
static and dynamic files, respectively. These two extensions have
some special meaning attached to them and thus should not be replaced
arbitrarily.
<P>

A static file may contain sort definitions, datasort declarations, static
definitions, abstract type declarations, exception declarations, datatype
declarations, macro definition, interfaces for dynamic values and
functions, etc.  In terms of functionality, a static file in ATS is similar
to a header file (with the extension ".h") in C or an interface file (with
the extension ".mli") in Objective Caml.
<P>

A dynamic file may contain everything in a static file. In addition, it may
also contain defintions for dynamic values and functions.
<P>

In general, the syntax for constructing code in a static file can also be
used for constructing code in a dynamic file. The only exception involves
declaring interfaces for dynamic values and functions. For instance, in a
<em>static</em> file, we can use the following syntax to declare interfaces
(or types) for a value named <i>pi</i> and a function named
<i>area_of_circle</i>.

<pre>
val pi : double
fun area_of_circle (radius: double): double
</pre>

When doing the same thing in a <em>dynamic</em> file, we need to use the
following slightly different syntax:

<pre>
extern val pi : double
extern fun area_of_circle (radius: double): double
</pre>

where <i>extern</i> is a keyword in ATS.
<P>

As a convention, we often use the filename extension ".cats" to indicate
that a file contains some C code that is supposed to be combined with ATS
code in certain manner. However, the use of this filename extension is not
mandatory.

<!-- end of [filename-extensions.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [file-inclusion.html] -->

<H2><A id="file-inclusion" name="file-inclusion">File Inclusion</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

As is in C, file inclusion in ATS can be done by using the directive
<i>#include</i>. For instance, the following line indicates that a file
named <i>foobar</i> is included, that is, this line is to be replaced with
the content of the file <i>foobar</i>:

<pre>
#include "foobar.hats"
</pre>

Note that the included file is parsed according to the syntax for statics
or dynamics depending whether the file is included in a static or dynamic
file.  As a convention, the name of an included file often ends with the
extension ".hats".
<P>

A common use of file inclusion is to keep some constants, flags or
parameters being defined consistently across a set of files. For instance,
the file <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/params.hats">prelude/params.hats</A>
serves such a purpose.
<P>

File inclusion can also be used to emulate (in a limited but rather useful
manner) the feature of functors (a module-level language construct) as is
supported in languages such as SML and Objective Caml.  Examples
illustrating such a use of file inclusion can be found elsewhere.
<P>

<!-- end of [file-inclusion.html] -->
<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [compilation.html] -->

<H2><A id="compilation" name="compilation">Compilation</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The command for compiling ATS programs is
<i>atscc</i>, which is stored in the directory "$ATSHOME/bin/" after
ATS/Anairiats is installed. The ATS compiler translates ATS programs into C
code, which is then compiled by the GNU C compiler <i>gcc</i>. 
<P>
<i>atscc</i> accepts all the flags <i>gcc</i> recognizes and passes them to
<i>gcc</i> directly. The following is a list of flags that are special
to <i>atscc</i>:
<UL>
<LI> The flag <i>--atstc</i> or <i>-tc</i> indicates typechecking only.
<LI> The flag <i>--atscc</i> or <i>-cc</i> indicates compiling to C code only.
<LI> The flag <i>-D_ATS_GCATS</i> indicates the need for garbage collection.
</UL>
If a C compiler other than <i>gcc</i> is to be used, please
set the environment variable <i>ATSCCOMP</i> to the command name of
this C compiler.
<P>
As an example, the following command only typechecks the ATS code in
"foo.dats" and "bar.sats":

<pre>
atscc -tc foo.dats bar.sats
</pre>

while the following command compiles "foo.dats" and "bar.sats"
into "foo_dats.c" and "bar_sats.c", respectively, if typechecking
"foo.dats" and bar.sats" succeeds:

<pre>
atscc -cc foo.dats bar.sats
</pre>

Typically, <i>atscc</i> is used as follows:

<pre>
atscc -o foobar -O3 foo.dats bar.sats
</pre>

When this command is issued, <i>atscc</i> first generates "foo_dats.c" and
"bar_sats.c", and then invokes <i>gcc</i> to compile
"foo_dats.c" and "bar_sats.c" to generate an executable file named
"foobar". The flag "-O3" requires that <i>gcc</i> perform all optimizations
classified at level 3 or below.

We may also issue the following command to produce some debugging information
for tools like gdb and <a href="http://valgrind.org">valgrind</a>:

<pre>
atscc -o foobar -g foo.dats bar.sats
</pre>

ATS programs can run with or without (systematic) garbage collection.  If
garbage collection is needed, then the following command can be issued to
generate the executable "foobar":

<pre>
atscc -o foobar -O3 foo.dats bar.sats -D_ATS_GCATS 
</pre>

<P>
For your information, the command <i>atscc</i> is not implemented in a
scripting language. It is one of the very first programs implemented in
ATS/Geizella (and then ported to ATS/Anairiats). The code for <i>atscc</i>
(and several other commands) can be found at <A
HREF="https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/utils/scripts/">utils/scripts/</A>.

<!-- end of [compilation.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [ats-main.html] -->

<H2><A id="ats-main" name="ats-main">The Main Function in ATS</A></H2>
<HR SIZE=1 ALIGN=LEFT><P>

The main function in ATS is declared as follows:

<pre>
fun main {n:int | n > 0} (argc: int n, argv: &(@[string][n])): void
  = "mainats"
</pre>

So this function takes an integer <i>argc</i> greater than 0 and a string
array <i>argv</i> of size <i>argc</i> and returns no value.  The syntax
<i>argv: &(@[string][n])</i> indicates that <i>argv</i> is a
call-by-reference argument. If we followed C++ kind of syntax, then
this would be written as something like <i>&argv: @[string][n]</i>.
<P>

The name "mainats", which is global, can be used in C code to refer to this
function.  When a program in ATS is compiled that implements the main
function in ATS, the following implementation of the main function in C is
automatically included in the C code generated by the ATS compiler:
<P>

<pre>
main (int argc, char *argv[]) {

// some initialization code is included here

mainats (argc, argv) ;
return 0 ;

}
</pre>

As an example, the following ATS program prints out the command line
on the standard output:

<pre>
implement main (argc, argv) = let
  fun loop {n,i:nat | i <= n} // [loop] is tail-recursive
    (i: int i, argc: int n, argv: &(@[string][n])): void =
    if i < argc then begin
      if i > 0 then print (' '); print argv.[i]; loop (i+1, argc, argv)
    end // end of [if]
  // end of [loop]
in
  loop (0, argc, argv); print_newline ()
end // end of [main]
</pre>

There are also situations where the function <i>mainats</i> may need to be
implemented in C. If this happens, the function <i>main_dummy</i> needs to
be implemented as follows:

<pre>
implement main_dummy () = ()
</pre>

This allows the compiler to generate proper code for the main function in C.
<P>

As an example, we present as follows a typical scenario in GTK+
programming, where the function <i>gtk_init</i> needs to be called to
modify the arguments passed from a command line:

<pre>
// some function implemented in ATS
extern fun main_work {n:pos} (argc: int n, argv: &(@[string][n])): void
  = "main_work"

implement main_work (argc, argv) = ( (* some ATS code that does the main work *) )

implement main_dummy () = () // indicating [mainats] being implemented in C

%{$

ats_void_type
mainats (ats_int_type argc, ats_ptr_type argv) {
  gtk_init ((int*)&argc, (char ***)&argv) ;
  main_work (argc, argv) ;
  return ;
} /* end of [mainats] */

%}
</pre>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="ats-main.dats">here</a>.

<!-- end of [ats-main.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [fixity.html] -->

<H2><A id="fixity" name="fixity">Fixity Declaration</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Given a function <i>f</i> of arity <i>n</i>, the standard syntax for
applying <i>f</i> to <i>n</i> arguments <i>v_1</i>, ..., <i>v_n</i> is
<i>f(v_1, ..., v_n)</i>. It is, however, allowed in ATS to use infix
notation for a binary function application, and prefix or postifix notation
for a unary function application.
<P>

In ATS, each identifier can be assigned one of the following fixities:
prefix, infix and postfix.  The fixity declarations for many commonly used
identifiers can be found in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/fixity.ats">prelude/fixity.ats</A>.
We often use the name <i>operator</i> to refer to an identifier that is
assigned a fixity.
<P>

For instance, we use the following syntax to declare that <i>+</i> and
<i>-</i> are infix operators of precedence value 50:

<pre>
infixl 50 + -
</pre>

After this declaration, we can write an expression
like <i>1 + 2 - 3</i>, which is parsed into
<i>-(+(1, 2), 3)</i> in terms of the standard syntax for function
application.

The keyword <i>infixl</i> indicates that the declared infix operators are
left-associative. For right-associative and non-associative infix
operators, please use the keywords <i>infixr</i> and <i>infix</i>,
respectively. If the precedence value is omitted in a fixity declaration,
it is assumed to equal 0.
<P>

We can also use the following syntax to declare that
<i>iadd</i>, <i>fadd</i>, <i>padd</i> and <i>uadd</i> are left-associative
infix operators with a precedence value equal to that of the operator
<i>+</i>:

<pre>
infixl (+) iadd fadd padd uadd
</pre>

This is useful as it is difficult in practice to remember the precedence
values of (a large collection of) declared operators. Sometimes, we may
need to specify that the precedence value of one operator in relation to
that of another one. For instance, the following syntax declares that
<i>opr2</i> is a left-associative infix operator and its precedence value
is that of <i>opr1</i> plus 10:

<pre>
infixl (opr1 + 10) opr2
</pre>

If the plus sign (+) is changed to the minus sign (-), then the precedence
value of <i>opr2</i> is that of <i>opr1</i> minus 10.
<P>

We can also turn an identifier <i>opr</i> into a non-associative infix
operator (of precedence value 0) by putting the backslash symbol <i>\</i>
in front of it. For instance, the expression
<i>$exp_1 \opr $exp_2</i> stands for <i>opr ($exp_1, $exp_2)</i>, where
<i>$exp_1</i> and <i>$exp_2</i>
refer to some expressions, either static or dynamic.
<P>

The syntax for declaring (unary) prefix and postfix operators are
similar. For instance, the following syntax declares that
<i>~</i> and <i>?</i> are prefix and postfix operators
of precedence values 61 and 69, respectively:

<pre>
prefix 61 ~
postfix 69 ?
</pre>

Please find an example involving a postfix operator <A
HREF="fixity.dats">here</A>.
<P>

For a given occurrence of an operator, we can deprive it of its assigned
fixity by simply putting the keyword <i><u>op</u></i> in front of it. For
instance <i>1 + 2 - 3</i> can be writen as <i><u>op</u>- (<u>op</u>+ (1,
2), 3)</i>.  It is also possible to (permanently) deprive an operator of its
assigned fixity.  For instance, the following syntax does so to the
operators
<i>iadd</i>, <i>fadd</i>, <i>padd</i> and <i>uadd</i>:

<pre>
nonfix iadd fadd padd uadd
</pre>

Lastly, please note that fixity declarations are lexically scoped, and each
fixity declaration is only effective within its legal scope.
<P>

<HR SIZE=1 ALIGN=LEFT><P>

<!-- end of [fixity.html] -->
<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [overloading.html] -->

<H2><A id="overloading" name="overloading">Overloading</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A symbol in ATS can be overloaded with multiple functions. The following syntax
introduces a symbol with the name <i>foo</i> for overloading.

<pre>
symintr foo // symbol introduction for overloading
</pre>

Suppose that <i>foo1</i>, <i>foo2</i> and <i>foo3</i> are names of three
functions in ATS. Then we can overload <i>foo</i> with these three
functions as follows:

<pre>
overload foo with foo1
overload foo with foo2
overload foo with foo3
</pre>

An overloaded function symbol is resolved according to the number of
arguments it takes and, if needed, the types of these arguments.

<pre>
</pre>

<HR SIZE=1 ALIGN=LEFT><P> The code used for illustration is available
<a href="overloading.dats">here</a>.

<!-- end of [overloading.html] -->
<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [macros.html] -->

<H2><A id="macros" name="macros">Macros</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

There are two kinds of macros in ATS. One kind is C-like and the other kind
is LISP-like, though they are much simpler as well as weaker than their
counterparts in C and LISP, respectively.

<H4>C-like Macros</H4>

We use some examples to illustrate certain typical uses of C-like macros in
ATS.
<P>

The following two declarations bind the identifiers <i>N1</i> and <i>N2</i> to
<u>the abstract syntax trees</u> (not strings) representing <i>1024</i> and
<i>N1 + N1</i>, respectively:

<pre>
#define N1 1024
#define N2 N1 + N1
</pre>

Suppose we have the following value declaration appearing in the scope of
the above macro delarations:

<pre>
val x = N1 * N2
</pre>

Then <i>N1 * N2</i> first expands into <i>1024 * (N1 + N1)</i>, which
further expands into <i>1024 * (1024 + 1024)</i>. Note that if this example
is done in C, then <i>N1 * N2</i> expands into <i>1024 * 1024 + 1024</i>,
which is different from what we have here.  Also note that it makes no
difference if we reverse the order of the previous macro definitions:

<pre>
#define N2 N1 + N1
#define N1 1024
</pre>

If we declare a marco as follows:

<pre>
#define LOOP (LOOP + 1)
</pre>

then an infinite loop is entered (or more precisely, some macro expansion
depth is to be reached) when the identifier <i>LOOP</i> is expanded.
<P>

<H4>LISP-like Macros</H4>

There are two forms of LISP-like macros in ATS: short form and long form.
These (untyped) macros are highly flexible and expressive, and they
<i>can</i> certainly be used in convoluted manners that should probably be
avoided in the first place. Some commonly used macro definitions can be
found in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/macrodef.sats">prelude/macrodef.sats</A>.
In order to use LISP-like macros in ATS effectively, the programmer may
want to find some examples in LISP involving backquote-comma-notation.
<P>

<B>Macros in Long Form</B>&nbsp;&nbsp; As a macro in short form can simply
be considered a special kind of macro in long form, we first give some
explanantion on the latter.  A macro definition in long form is introduced
via the use of the keyword <i>macrodef</i>. For instance, the following
syntax introduces a macro name <i>one</i> that refers to some code, that
is, abstract syntax tree (AST) representing the integer number <i>1</i>.

<pre>
macrodef one = `(1)
</pre>

The special syntax `(...), where no space is allowed between the backquote
"`" and the left parenthsis "(", means to form an abstract syntax tree
representing what is written inside the parentheses.  This is often
referred to as backquote-notation. Intuitively, one may think that a
backquote-notation exerts an effect that "freezes" everything inside it.
Let us now define another macro as follows:

<pre>
macrodef one_plus_one = `(1 + 1)
</pre>

The defined macro name <i>one_plus_one</i> refers to some code (i.e., AST)
representing <i>1 + 1</i>. At this point, it is important to stress that
the code representing <i>1 + 1</i> is different from the code representing
<i>2</i>.  The macro name <i>one_plus_one</i> can also be defined as
follows:

<pre>
macrodef one_plus_one = `(,(one) + ,(one))
</pre>

The syntax ,(...), where no space is allowed between the comma
"," and the left parenthesis "(", indicates the need to expand (or
evaluate) whatever is written inside the parentheses. This is often
referred to as comma-notation. A comma-notation is only allowed inside a
backquote-notation. Intuitively, a comma-notation cancels out the
"freezing" effect of the enclosing backquote-notation.
<P>

In addition to macro names, we can also define macro functions. For
instance, the following syntax introduces a macro function
<i>square_mac</i>:

<pre>
macrodef square_mac (x) = `(,(x) * ,(x)) // [x] should refer to some code
</pre>

Here are some examples that make use of <i>square_mac</i>:

<pre>
fun square_fun (i: int): int = ,(square_mac `(i))
fun area_of_circle_fun (r: double): doubld = 3.1416 * ,(square_mac `(r))
</pre>

<B>Macros in Short Form</B>&nbsp;&nbsp;
The previous macro function <i>square_mac</i> can also be defined as follows:

<pre>
macdef square_mac (x) = ,(x) * ,(x) // [x] should refer to some code
</pre>

The keyword <i>macdef</i> introduces a macro definition in short form.
The previous examples that make use of <i>square_mac</i> can now be written
as follows:

<pre>
fun square_fun (i: int): int = square_mac (i)
fun area_of_circle_fun (r: double): doubld = 3.1416 * square_mac (r)
</pre>

In terms of syntax, a macro function in short form is just like an ordinary
function.  In general, if a unary macro function <i>fmac</i> in short
form is defined as as follows:

<pre>
macdef fmac (x) = $exp_def
</pre>

then one may essentially think that a macro definition in long form is
defined as follows:

<pre>
macrodef fmac_long (x) = `($exp_def) // please note the backquote
</pre>

and each occurrence of <i>fmac($exp_arg)</i> is automatically rewritten
into <i>,(fmac_long(`($exp_arg)))</i>. Note that macro functions in short
form with multiple arguments are handled in precisely the same fashion.

The primary purpose for introducing macros in short form is to provide a
form of syntax that seems more accessible. While macros in long form can be
defined recursively (as is to be explained later), macros in short form
cannot.

<P>

<B>Recursive Macro Definitions</B>&nbsp;&nbsp; (to be written later)

<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <A HREF="macros.dats">here</A>.

<!-- end of [macros.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!--
The file is automatically generated by [atsdoc] from datatypes.atxt.
-->
<!--
Time of Generation: Wed Aug 31 14:15:41 2011
-->
<!--beg of [function-or-closure.html]-->

<H2><A id="function-or-closure" name="function-or-closure">Function or
Closure?</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

It is possible in ATS to differentiate at the level of types functions
without environment from functions with environment.  This is an
indispensable feature for interfacing functions in C <EM>directly</EM>
inside ATS as these functions all have no environment. A function with an
environment is often referred to as a closure.

<H4>A problem with closures</H4>

In the programming language C, each function is at the toplevel, and it is
naturally represented as a pointer to the code heap where the code for the
function is stored. However, inner functions are supported in ATS, and they
may appear in the return value of a function call. As an example, the
following code in ATS involves an inner function <i>add_x</i> appearing in
the return value of an outer function <i>add</i>:

<pre class="atsyntax">
<span class="keyword">fn</span> add <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> int</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">let</span> <span class="keyword">fn</span> add_x <span class="keyword">(</span>y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> x + y <span class="keyword">in</span> add_x <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [add]
</span></pre>


The syntax <i>&lt;cloref&gt;</i> indicates that the defined functions
<i>add</i> and <i>add_x</i> are both (persistant) closure references.
Applying <i>add</i> to a given integer <i>i</i>, we obtain a unary function
that adds <i>i</i> to its argument. This function is represented as a pair
<i>(add_x_env, [x -> i])</i>, where we use <i>[x-&gt;i]</i> for something
often referred to as an environment that binds <i>x</i> to <i>i</i>, and
<i>add_x_env</i> for the (toplevel) function defined in the following
(pseudo) code:

<pre class="atsyntax">
<span class="keyword">fun</span> add_x_env <span class="keyword">(</span>env<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> env<span class="keyword">.</span>x + y
</pre>


Note that the (pseudo) syntax <i>env.x</i> stands for the selection of the
value to which <i>x</i> is bound in the environment <i>env</i>.
<P>

We use the name <i>closure</i> to refer to a pair like <i>(add_x_env, [x ->
i])</i>. Given that functions may occur as arguments (of other functions)
in ATS, it is necessary that all functions be represented uniformly as
closures (if functions without environments cannot be differentiated from
functions with environments at compile-time). For instance, the
previously defined (toplevel) function <i>add</i> needs to be represented
as a pair <i>(add_env, [])</i>, where <i>[]</i> stands for the empty
environment and <i>add_env</i> is the function defined in the following
(pseudo) code:

<pre>
fun add_env (env, x) = (add_x_env, [x -> x])
</pre>

In functional languages like ML and Haskell, all functions are represented
as closures. Unfortunately, this requirement for representing all functions
as closures, can cause a serious difficulty when we try to use in ATS a
higher-order function implemented in C. Let us see a concrete example.
<P>

The function <i>qsort</i> is declared in &lt;stdlib.h&gt; with the following
type:

<pre>
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
</pre>

Clearly, <i>qsort</i> demands that its fourth argument be a function (not a
closure). In order to use <i>qsort</i> in ATS directly, we need a way to
construct functions represented as code pointers (instead of closures).
<P>

<h4>Types for functions with environment</h4>

In ATS, a type of the form <i>(T_1, ..., T_n) -&lt;cloref&gt; T_0</i> is
for a closure reference, that is, a reference to a function paired with an
environment that takes <i>n</i> arguments of types <i>T_1, ..., T_n</i> and
returns a value of type <i>T_0</i>.  The following
declaration states that <i>foo</i> is a closure reference of the type
<i>(T_1, ..., T_n) -&lt;cloref&gt; T_0</i>:

<pre>
val foo : (T_1, ...., T_n) -&lt;cloref&gt; T_0
</pre>

<h4>Types for functions without environment</h4>

In ATS, a type of the form <i>(T_1, ..., T_n) -&lt;fun&gt; T_0</i>,
where <i>fun</i> can be omitted, is for a
function without environment that takes <i>n</i> arguments of types <i>T_1,
..., T_n</i> and returns a value of type <i>T_0</i>. The
following two equivalent declarations both state that <i>bar</i> is a
function of the type <i>(T_1, ..., T_n) -&lt;fun&gt; T_0</i>:

<pre>
val bar : (T_1, ...., T_n) -&lt;fun&gt; T_0
fun bar (x_1: T_1, ...., x_n: T_n): T_0
</pre>

The previously mentioned function <i>qsort</i> can be given the following
type in ATS:

<pre class="atsyntax">
<span class="keyword">fun</span> <a name="4"><span class="dyncstdec">qsort <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>viewt@ype<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>base<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span> <span class="keyword">@[</span>a<span class="keyword">]</span><span class="keyword">[</span>n<span class="keyword">]</span></span><span class="keyword">,</span> nmemb<span class="keyword">:</span> <span class="staexp">size_t n</span><span class="keyword">,</span> size<span class="keyword">:</span> <span class="staexp">sizeof_t a</span><span class="keyword">,</span> compar<span class="keyword">:</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">&amp;</span>a<span class="keyword">,</span> <span class="keyword">&amp;</span>a<span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="keyword">fun</span><span class="keyword">&gt;</span> int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></a>
</pre>


This type indicates that <i>qsort</i> itself is a function without
environment and its fourth argument is also a function without environment.
As an example, the following code implements a simple test on <i>qsort</i>:


<pre class="atsyntax">
<span class="keyword">fn</span> test_qsort <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> pr_loop <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n-i<span class="keyword">&gt;.</span></span>
    <span class="keyword">(</span>A<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span>int<span class="keyword">]</span><span class="keyword">[</span>n<span class="keyword">]</span><span class="keyword">)</span></span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> n <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> print ", "<span class="keyword">;</span> print A<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span><span class="keyword">;</span> pr_loop <span class="keyword">(</span>A<span class="keyword">,</span> n<span class="keyword">,</span> i+1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="comment">// end of [pr_loop]
</span>
  <span class="comment">// creating a linear array of size 10
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p_arr<span class="keyword">,</span> asz<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$arrsz</span> <span class="keyword">{</span>int<span class="keyword">}</span> <span class="keyword">(</span>1<span class="keyword">,</span> 9<span class="keyword">,</span> 2<span class="keyword">,</span> 8<span class="keyword">,</span> 3<span class="keyword">,</span> 7<span class="keyword">,</span> 4<span class="keyword">,</span> 6<span class="keyword">,</span> 5<span class="keyword">,</span> 0<span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>print "before quicksort:\n"<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pr_loop <span class="keyword">(</span><span class="keyword">!</span>p_arr<span class="keyword">,</span> asz<span class="keyword">,</span> 0<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>

  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">begin</span>
    qsort <span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">!</span>p_arr<span class="keyword">,</span> asz<span class="keyword">,</span> sizeof&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=&gt;</span> compare <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [val]
</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>print "after quicksort:
"<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pr_loop <span class="keyword">(</span><span class="keyword">!</span>p_arr<span class="keyword">,</span> asz<span class="keyword">,</span> 0<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  array_ptr_free <span class="staexp"><span class="keyword">{</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf_gc</span><span class="keyword">,</span> <span class="prfexp">pf_arr</span> <span class="keyword">|</span> p_arr<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [test_qsort]
</span></pre>


<H4>Implementing a function without enviroment</H4>

The following code implements <i>add</i> as a function without enviroment:

<pre class="atsyntax">
<span class="keyword">fn</span> add0 <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp"><span class="keyword">fun</span></span><span class="keyword">&gt;</span> <span class="staexp">int <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> int</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">let</span> <span class="keyword">fn</span> add0_x <span class="keyword">(</span>y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> x + y <span class="keyword">in</span> add0_x <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [add0]
</span></pre>


The syntax <i>:&lt;fun&gt</i> is an annotation indicating that the type
ascribed to <i>add0</i> is <i>int -&lt;fun&gt; (int -&lt;cloref&gt; int)</i>.  If we
change <i>int -&lt;cloref&gt; int</i> into
<i>int -&lt;fun&gt; int</i>, then an error is reported at compile-time as
the function <i>add0_x</i> does require a nonempty environment that binds
the variable <i>x</i> to some value. If <i>add0</i> is needed in a place
where a closure is expected, we can simply write
<i>lam x => add0 (x)</i> instead.
<P>
When a function is declared via the keyword <i>fun</i> or <i>fn</i>, it is
assumed by default that the function is without environment. For instance,
the following code is equivalent to the previous implementation of
<i>add0</i>:

<pre class="atsyntax">
<span class="keyword">fn</span> add0 <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> int</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">let</span> <span class="keyword">fn</span> add0_x <span class="keyword">(</span>y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> x + y <span class="keyword">in</span> add0_x <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [add0]
</span></pre>


In contrast, the following code, which is used at the beginning of this
tutorial, implements <i>add</i> as a closure:

<pre class="atsyntax">
<span class="keyword">fn</span> add <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int <span class="keyword">-&lt;</span>cloref<span class="keyword">&gt;</span> int</span> <span class="keyword">=</span> <span class="keyword">begin</span>
  <span class="keyword">let</span> <span class="keyword">fn</span> add_x <span class="keyword">(</span>y<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">cloref</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> x + y <span class="keyword">in</span> add_x <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">// end of [add]
</span></pre>


<H4>Linear Closures</H4>

As a closure is an aggregated value, memory allocation is required in order
to form closures. In ATS, linear closures are supported. As memory
allocated for linear closures can be freed explicitly by the programmer,
such closures are particularly useful in a situation where automatic
garbage collection is not allowed or its use needs to be significantly
reduced. We are to present detailed explanation on linear closures elsewhere.
<P>

<HR SIZE=1 ALIGN=LEFT><P>

The code used for illustration is available <a
href="function-or-closure.dats">here</a>.

<!--end of [function-or-closure.html]-->



<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [variadicity.html] -->

<H2><A id="variadicity" name="variadicity">Variadic Functions</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

As in C, a funciton in ATS may also take an indefinite number of arguments.
Let us use the function <i>printf</i> in ATS, which corresponds to the
function of the same name in C, as an example to explain this feature.
<P>

The type of <i>printf</i> is given as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT> printf <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>ts<FONT COLOR="#000000">:</FONT>types<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>printf_c ts<FONT COLOR="#000000">,</FONT> ts<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> void</FONT>
</FONT></PRE>

We use <i>printf_c</i> for a type constructor that forms types for format
strings (in C) when applied to lists of types. For instance,
<i>printf_c(char, double, int)</i> is a type for format strings that require
a character, a double, and an integer to be supplied. Given
a character <i>c</i>, a double <i>d</i> and an integer <i>i</i>,
<i>@(c, d, i)</i> is an argument of types <i>(char, double, int)</i>,
and the following expression is well-typed in ATS:

<PRE><span class="dynexp">printf <span class="keyword">(</span>"c = %c and d = %f and i = %i"<span class="keyword">,</span> <span class="keyword">@(</span>c<span class="keyword">,</span> d<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span>
</span></PRE>

The type of the format string
<i>"c = %c and d = %f and i = %i"</i> is computed to be
<i>printf_c (char, double, int)</i>
and then <i>@(c, d, i)</i> is checked to be of the type
<i>(char, double, int)</i>.  Note that a format string must be a constant
in order for its type to be computed during typechecking.
<P>

As an example, we present as follows a program that prints out a
multiplication table for single digits:

<PRE><span class="dynexp"><span class="keyword">#define</span> <span class="neuexp">N 9</span>

<span class="keyword">implement</span> main <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">)</span> <span class="keyword">=</span> loop1 <span class="keyword">(</span>0<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>

  <span class="comment">// [loop1] and [loop2] are verified to be terminating based on the supplied metrics
</span>
  <span class="comment">// [.&lt; N-i, 0 &gt;.] is a termination metric
</span>  <span class="comment">// Ignore it if you have not learned this feature yet
</span>  <span class="keyword">fun</span> loop1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= N<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> N-i<span class="keyword">,</span> 0 <span class="keyword">&gt;.</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&lt;</span> N <span class="keyword">then</span> loop2 <span class="keyword">(</span>i+1<span class="keyword">,</span> 0<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [loop1]
</span>
  <span class="comment">// [.&lt; N-i, N+1-j &gt;.] is a termination metric
</span>  <span class="comment">// Ignore it if you have notlearned this feature yet
</span>  <span class="keyword">and</span> loop2 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= N<span class="keyword">;</span> j &lt;= i<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> N-i<span class="keyword">,</span> i-j+1 <span class="keyword">&gt;.</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> j <span class="keyword">&lt;</span> i <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> <span class="keyword">(</span>j <span class="keyword">&gt;</span> 0<span class="keyword">)</span> <span class="keyword">then</span> print '\t'<span class="keyword">;</span>
      printf <span class="keyword">(</span>"%1d*%1d=%2.2d"<span class="keyword">,</span> <span class="keyword">@(</span>j+1<span class="keyword">,</span> i<span class="keyword">,</span> <span class="keyword">(</span>j+1<span class="keyword">)</span> * i<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span>
      loop2 <span class="keyword">(</span>i<span class="keyword">,</span> j+1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      print_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> loop1 <span class="keyword">(</span>i<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="comment">// end of [loop2]
</span>
<span class="keyword">}</span> <span class="comment">// end of [main]
</span></span></PRE>

The following text is the output of the program:
<pre>
1*1=01
1*2=02	2*2=04
1*3=03	2*3=06	3*3=09
1*4=04	2*4=08	3*4=12	4*4=16
1*5=05	2*5=10	3*5=15	4*5=20	5*5=25
1*6=06	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36
1*7=07	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49
1*8=08	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64
1*9=09	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81
</pre>

<HR SIZE=1 ALIGN=LEFT><P>

The code used for illustration is available <a href="variadicity.dats">here</a>.

<!-- end of [variadicity.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [tail-recusive-functions.html] -->

<H2><A id="tailrecfun" name="tailrecfun">Tail-Recursive Functions</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Probably the single most important optimization performed by the
ATS/Anairiats compiler is the translation of tail-recursive function calls
into direct (local) jumps.

<H4>Tail-Recursion</H4>

When applied to an integer <i>n</i>, the following defined function
<i>sum1</i> sums up integers from <i>1</i> to <i>n</i>.

<PRE><span class="dynexp"><span class="comment">// [sum1] is recursive but not tail-recursive
</span><span class="keyword">fun</span> sum1 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> n + sum1 <span class="keyword">(</span>n-1<span class="keyword">)</span> <span class="keyword">else</span> 0</span></PRE>

This function is recursive but not tail-recursive. The stack space it
consumes is proportional to the value of its argument. Essentially,
the ATS compiler translates the definition of
<i>sum1</i> into the following C code:

<pre>
int sum1 (int n) {
  if (n > 1) return n + sum1 (n-1) ; else return 1 ;
}
</pre>

When applied to an integer <i>n</i>,
the following defined function <i>sum2</i> also sums up
integers from <i>1</i> to <i>n</i>.

<PRE><span class="dynexp><span class="keyword">fn</span> sum2 <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span> <span class="comment">// sum2 is non-recursive
</span>  <span class="comment">// [loop] is tail-recursive
</span>  <span class="keyword">fun</span> loop <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> loop <span class="keyword">(</span>n-1<span class="keyword">,</span> res+n<span class="keyword">)</span> <span class="keyword">else</span> res
  <span class="comment">// end of [loop]
</span><span class="keyword">in</span>
  loop <span class="keyword">(</span>n<span class="keyword">,</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [sum2]
</span></span></PRE>

The inner function <i>loop</i> in the definition of <i>sum2</i> is
tail-recursive.  The stack space consumed by <i>loop</i> is a constant
independent of th value of the argument of <i>sum2</i>.  Essentially, the
ATS compiler translates the definition of <i>sum2</i> into the following C
code:

<pre>
int sum2_loop (int n, int res) {
  loop:
  if (n > 1) {
    res = res + n ; n = n - 1; goto loop; 
  } else {
    // do nothing
  }
  return res ;
}

int sum2 (int n) { return sum2_loop (n, 0) ; }
</pre>

<H4>Mutual Tail-Recursion</H4>

Sometimes, mutually tail-recursive functions are encountered.  For
instance, in the following example, the functions <i>even</i> and
<i>odd</i> are mutually tail-recursive.

<PRE><span class="dynexp"><span class="comment">// [fn*] indicates the need to combine two or more functions
</span><span class="comment">// so as to translate tail-recursive calls into direct jumps
</span><span class="keyword">fn*</span> even <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> odd <span class="keyword">(</span>n-1<span class="keyword">)</span> <span class="keyword">else</span> true
<span class="keyword">and</span> odd <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> even <span class="keyword">(</span>n-1<span class="keyword">)</span> <span class="keyword">else</span> false</span></PRE>

The keyword <i>fn*</i> is used to indicate to the ATS compiler
that the functions <i>even</i> and
<i>odd</i> need to be combined together so as to turn (mutually)
tail-recursive function calls into direct jumps. Essentially, the ATS
compiler emits the following C code after compiling this example:

<pre>
bool even_odd (int tag, int n) {

bool res ;

switch (tag) {
  0: goto even ;
  1: goto odd ;
  default : exit (1) ;
}

even: if (n > 0) { n = n - 1; goto odd; } else { res = true; goto done; }

odd: if (n > 0) { n = n - 1; goto even; } else { res = false; goto done; }

done: return res ;

} /* end of [even_odd] */

bool even (int n) { return even_odd (0, n) ; }
bool odd (int n) { return even_odd (1, n) ; }
</pre>

Note that mutually recursive functions can be combined in such a manner
only if <u>they all have the same return type</u>. In the above case, both
<i>even</i> and <i>odd</i> have the same return type <i>bool</i>.
<P>

When translating C code involving embedded loops, we often encounter mutual
tail-recursion. For instance, the following C code prints out ordered pairs
of digits:

<pre>
int main (int argc, char *argv[]) {
  int i, j ;

  for (i = 0; i <= 9; i += 1) {
    for (j = i; j <= 9; j += 1) {
      if (i < j) printf (", ") ; printf ("(%i, %i)", i, j) ;
    } /* for */
    printf ("\n") ;
  } /* for */

  return 0 ;
}
</pre>

A straightforward translation of the C code into ATS (in functional style)
is given as follows:

<PRE><span class="dynexp"><span class="keyword">implement</span> main <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fn*</span> loop1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i &lt;= 9 <span class="keyword">then</span> loop2 <span class="keyword">(</span>i<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="comment">// end of [loop1]
</span>
  <span class="keyword">and</span> loop2 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
    <span class="keyword">if</span> j &lt;= 9 <span class="keyword">then</span> <span class="keyword">begin</span>
      <span class="keyword">if</span> i <span class="keyword">&lt;</span> j <span class="keyword">then</span> <span class="keyword">begin</span>
        print ", "<span class="keyword">;</span> printf <span class="keyword">(</span>"(%i, %i)"<span class="keyword">,</span> <span class="keyword">@(</span>i<span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> loop2 <span class="keyword">(</span>i<span class="keyword">,</span> j+1<span class="keyword">)</span>
      <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
      print_newline <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">;</span> loop1 <span class="keyword">(</span>i+1<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="comment">// end of [loop2]
</span><span class="keyword">in</span>
  loop1 0
<span class="keyword">end</span> <span class="comment">// end of [main]
</span></span></PRE>

where the mutually tail-recursive funtions <i>loop1</i> and <i>loop2</i>
correspond to the outer and inner loops in the C code, respectively.
<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="tail-recursive-functions.dats">here</a>.

<!-- end of [tail-recusive-functions.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [termination-metrics.html] -->

<H2><A id="termination-metrics" name="termination-metrics">Termination
Metrics</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

In ATS, the programmer is allowed to supply termination metrics for
verifing the termination of recursively defined functions. This is really
an indispensable feature for supporting programming with theorem proving as
proof functions, namely, functions representing proofs, must be proven to
be pure and terminating.
<P>

A termination metric is a tuple <i>(M1, ..., Mn)</i> of natural numbers,
where <i>n >= 0 </i>. We use the standard well-founded lexicographical
ordering on natural numbers to order such tuples.

<H4>A Primitive Recursive Function</H4>

The kind of recursion in the following implementation of the
factorial function is primitive recursion:

<PRE><span class="dynexp"><span class="comment">// [fact] implements the factorial function
</span><span class="keyword">fun</span> fact <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> n <span class="keyword">&gt;.</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Int</span> <span class="keyword">=</span> <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> n * fact <span class="keyword">(</span>n-1<span class="keyword">)</span> <span class="keyword">else</span> 1</span></PRE>

The syntax <i>.< n >.</i> indicates that the metric supplied for verifying
the termination of the defined function is a singleton tuple <i>(n)</i>. In
the definition of <i>fact</i>, the metric for the recursive call to
<i>fact</i> is <i>(n-1)</i>, which is strictly less than <i>(n)</i>. So the
function <i>fact</i> is terminating.

<H4>Some General Recursive Functions</H4>

We implement as follows a function <i>gcd</i> that computes the greatest
common division of two given positive integers:

<PRE><span class="dynexp"><span class="comment">// [gcd] computes the greates common divisors of two positive integers
</span><span class="keyword">fun</span> gcd <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m <span class="keyword">&gt;</span> 0<span class="keyword">;</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> m+n <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>nat <span class="keyword">|</span> 1 &lt;= r<span class="keyword">;</span> r &lt;= min<span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">]</span> int r</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> n <span class="keyword">then</span> gcd <span class="keyword">(</span>m - n<span class="keyword">,</span> n<span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">if</span> m <span class="keyword">&lt;</span> n <span class="keyword">then</span> gcd <span class="keyword">(</span>m<span class="keyword">,</span> n - m<span class="keyword">)</span>
  <span class="keyword">else</span> m</span></PRE>

The syntax <i>.< m+n >.</i> indicates that the termination metric
<i>(m+n)</i> should be used to verify that the defined function <i>gcd</i>
is terminating. In the definition of <i>gcd</i>, the termination metric for
the first recursive call to <i>gcd</i> is <i>(m-n)+n=m</i>, which is
strictly less than the original termination metri <i>m+n</i> (as <i>n</i>
is positive); the termination metric for the second recursive call to
<i>gcd</i> is <i>m+(n-m)=n</i>, which is also strictly less than the
original termination metric <i>m+n</i> (as <i>m</i> is positive).  Thus,
<i>gcd</i> is a terminating function.
<P>

As another example, we implement as follows the Ackermann's function:

<PRE><span class="dynexp"><span class="comment">// [ack] implements the Ackermann's function
</span><span class="keyword">fun</span> ack <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> m<span class="keyword">,</span> n <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>m<span class="keyword">:</span> <span class="staexp">int m</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Nat</span> <span class="keyword">=</span>
  <span class="keyword">if</span> m <span class="keyword">&gt;</span> 0 <span class="keyword">then</span>
    <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> ack <span class="keyword">(</span>m-1<span class="keyword">,</span> ack <span class="keyword">(</span>m<span class="keyword">,</span> n-1<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> ack <span class="keyword">(</span>m-1<span class="keyword">,</span> 1<span class="keyword">)</span>
  <span class="keyword">else</span> n+1</span></PRE>

The syntax <i>.< m, n >.</i> indicates that the termination metric is
a pair of natural numbers: <i>(m, n)</i>. We use the lexicographical
ordering on natural numbers to compare such metrics.
To verify that <i>ack</i> is terminating, we need to solve the
following constraints:
<UL>

<LI>
<i>(m-1, k)</i> is less than <i>(m, n)</i> under the assumption
<i>m > 0</i>, where <i>k</i> is an arbitrary natural number.

<LI>
<i>(m, n-1)</i> is less than <i>(m, n)</i> under the assumption
<i>m > 0</i> and <i>n > 0</i>.

<LI>
<i>(m-1, 1)</i> is less than <i>(m, n)</i> under the assumption
<i>m > 0</i>.

</UL>
As all of these constraints can be readily solved, we conclude that
<i>ack</i> is a terminating funciton.
<P>

<H4>Mutually Recursive Functions</H4>

When mutually recursive functions are to be verified, the termination
metrics for these functions, which are tuples of natural numbers, must be
of the same tuple length. We given a simple example as follows:

<PRE><span class="dynexp"><span class="comment">// mutually recursive functions
</span><span class="keyword">fun</span> isEven <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> 2*n+2 <span class="keyword">&gt;.</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> <span class="keyword">~</span><span class="keyword">(</span>isOdd n<span class="keyword">)</span> <span class="keyword">else</span> true
<span class="keyword">and</span> isOdd <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> 2*n+1 <span class="keyword">&gt;.</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">=</span>
  <span class="keyword">if</span> n <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> isEven <span class="keyword">(</span>n-1<span class="keyword">)</span> <span class="keyword">else</span> false</span></PRE>

Clearly, we may also verify the termination of these two functions by using
the metrics
<i> .< n, 1 >. </i>
and
<i> .< n, 0 >. </i>
for <i>isEven</i> and <i>isOdd</i>, respectively.

<H4>Termination Checking at Run-time</H4>
Suppose that <i>foo</i> and <i>bar</i> are declared as follows:

<PRE>
fun foo ():<> void and bar ():<> void
</PRE>

Moreover, suppose that the following implementation of <i>foo</i>
is given in a file named <i>foo.dats</i>:

<PRE>
implement foo () = $Bar.bar ()
</PRE>

while the following implementation of <i>bar</i> is given in another file
named <i>bar.dats</i>:

<PRE>
implement bar () = $Foo.foo ()
</PRE>

Clearly, neither <i>foo</i> nor <i>bar</i> is terminating. In practice, it
is difficult to resolve this issue of calling cycles among terminating
functions by solely relying on termination metrics. Instead, <i>atscc</i>
can generate run-time code for detecting calling cycles among terminating
functions if the flag <i>-D_ATS_TERMINATION_CHECK</i> is present. For
instance, if <i>foo.dats</i> and <i>bar.dats</i> are compiled as follows:

<PRE>
atscc -D_ATS_TERMINATION_CHECK foo.dats and bar.dats
</PRE>

then a run-time error is to be reported to indicate a calling cycle when
either <i>foo.dats</i> or <i>bar.dats</i> is loaded dynamically.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="termination-metrics.dats">here</a>.

<!-- end of [termination-metrics.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [types-with-effects.html] -->

<H2><A id="types-with-effects" name="types-with-effects">Types with
Effects</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The type system of ATS can currently track the following list of effects
that a program may incur during its execution:

<UL>

<LI>
The <i>exn</i> (exception) effect is incurred if a program raises an
exception during its execution. This covers the case where the execution of
a program is terminated abnormally, for instance, by calling <i>exit</i>.

<LI>
The <i>ntm</i> (nontermination) effect refers to potential nonterminating
excecution of a program.

<LI>
The <i>ref</i> (reference) effect essentially means that a program may
potentially update the content of some shared memory.

</UL>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="types-with-effects.dats">here</a>.

<!-- end of [types-with-effects.html] -->


<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [templates.html] -->

<H2><A id="templates" name="templates">Parametric Polymorphism and
Templates</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Parametric polymorphism (or polymorphism for short) offers a flexible and
effective approach to supporting code reuse. For instance, given a pair
<i>(v1, v2)</i> where <i>v1</i> is a a boolean and <i>v2</i> a character,
the function
<i>swap_bool_char</i> defined below returns a pair <i>(v2, v1)</i>:

<pre>
fun swap_bool_char (xy: @(bool, char)): @(char, bool) = (xy.1, xy.0)
</pre>

Now suppose that a pair of integers need to be swapped, and this results in
the implementation of the following function <i>swap_int_int</i>:

<pre>
fun swap_int_int (xy: @(int, int)): @(int, int) = (xy.1, xy.0)
</pre>

The code duplication between <i>swap_bool_char</i> and
<i>swap_int_int</i> is obvious, and it can be easily avoided by implementing a
function template as follows:

<pre>
fun{a,b:t@ype} swap (xy: @(a, b)): @(b, a) = (xy.1, xy.0)
</pre>

Now the functions <i>swap_bool_char</i> and <i>swap_int_int</i> can
simply be replaced with <i>swap&lt;bool,char&gt;</i> and
<i>swap&lt;int,int&gt;</i>, respectively. The function template
<i>swap</i> cannot be compiled into executable binary code directly as the sizes
of type variables <i>a</i> and <i>b</i> are unknown: The special sort
<i>t@ype</i> is for classifying types whose sizes are unspecified. If
<i>swap&lt;T1,T2&gt;</i> is used for some types <i>T1</i> and <i>T2</i> of known
sizes, then an instantiation of <i>swap</i> is created where type variables
<i>a</i> and <i>b</i> are replaced with <i>T1</i> and <i>T2</i>,
respectively, and then compiled into executable binary code. For those who
know the feature of templates in C++, this should sound rather familiar.

In contrast to <i>swap</i>, <i>swap_type_type</i> is defined below as a
polymorphic function (rather than a function template):

<pre>
fun swap_type_type {a,b:type} (xy: @(a, b)): @(b, a) = (xy.1, xy.0)
</pre>

This function can be compiled into executable binary code as the sizes of
type variables <i>a</i> and <i>b</i> are known: The special sort <i>type</i> is for
classifying types whose sizes equal exactly one word, that is, the size of
a pointer. For example, the size of a string is one word, and the size of
any declared datatype is also one word.  Given strings <i>s1</i> and <i>s2</i>, an
application of <i>swap_type_type</i> to <i>@(s1, s2)</i> can be written as
follows:

<pre>
swap_type_type {string,string} @(s1, s2)
</pre>

where the expression <i>{string,string}</i> is often referred to as a static
argument. As in this case, most static arguments do not have to be provided
explicitly since they can be automatically inferred.  However, such static
arguments, if provided, can often enhance the quality and precision of the
error messages reported in case of typechecking failure. This is a topic to
be explored elsewhere in great depth.

<H4>Template Declaration and Implementation</H4>

Often, the interface for a template may need to be declared alone.  For
instance, the interface for the above <i>swap</i> function template can be
declared as follows:

<pre>
extern fun{a,b:t@ype} swap (xy: @(a, b)): @(b, a)
</pre>

Just like a declared function interface, a declared template interface can
be implemented.  For instance, the following code implements the interface
declared for the <i>swap</i> function template:

<pre>
implement{a,b} swap (xy) = (xy.1, xy.0)
</pre>

This form of template implementation is often referred to as generic
template implementation in contrast to specialized template implementation
presented as follows.

It is also allowed to implement specialized templates in ATS. For instance,
the following code implements the above <i>swap</i> function template that
is specialized with the type variables <i>a</i> and <i>b</i> being set to
<i>int</i> and <i>int</i>, respectively:

<pre>
implement swap&lt;int,int&gt; (xy) = let
  val x = xy.0 and y = xy.1; val s = x + y in (s - x, s - y)
end // end of [swap&lt;int,int&gt;]
</pre>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="templates.dats">here</a>.

<!-- end of [templates.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [lists.html] -->

<H2><A id="lists" name="lists">Persistent Lists</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Lists are by far the most commonly used data structure in functional
programming. We say that a data structure is <EM>persistent</EM> if it is
heap-allocated and can only be freed by the GC. In contrast, a data
structure is said to be linear if it is either stack-allocated or
heap-allocated and can be freed by the user as well as by the GC.
<P>

The datatype for persistent lists in ATS is declared as follows:

<PRE><span class="dynexp"><span class="keyword">datatype</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="comment">// t@ype+: covariant
</span>  <span class="keyword">|</span> list_nil <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> 0<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">n &gt;= 0</span><span class="keyword">}</span> list_cons <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span></span></span></PRE>

Given a type <i>T</i> and an integer <i>I</i>, the type <i>list(T, I)</i>
is for lists of length <i>I</i> in which each element is of type <i>T</i>.
<P>

Let us first introduce some abbreviations for the list constructors:
<PRE><FONT COLOR="#000000">#define</FONT> <FONT COLOR="#800080">nil list_nil</FONT>
<FONT COLOR="#000000">#define</FONT> <FONT COLOR="#800080">cons list_cons</FONT>
<FONT COLOR="#000000">#define</FONT> <FONT COLOR="#800080">:: list_cons</FONT></PRE>

The following syntax creates a list consisting of 1, 2 and 3:

<pre>
cons (1, cons (2, cons (3, nil ()))) // [nil ()] can be replaced with [nil]
</pre>

This kind of syntax is a bit unwieldy if longer lists need to be handled,
and some alternatives are given as follows:

<pre>
'[1, 2, 3] // the first character is quote (')
$lst (1, 2, 3) // this is equivalent to '[1, 2, 3]
$lst {Nat} (1, 2, 3) // [Nat] is given as the type for the list elements
</pre>

The interfaces for various functions on lists can be found in the file <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/list.sats">prelude/SATS/list.sats</A>.
<P>

We now present some simple programs involving lists.  The following code
implements a function template that computes the length of a given list:

<PRE><span class="dynexp"><span class="comment">// This implementation is not tail-recursive
</span><span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> length <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int n</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span> _ :: xs <span class="keyword">=&gt;</span> 1 + length xs <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0</span></PRE>

This is a rather poor implementation as it is not tail-recursive.
A better one, which is tail-recursive, is given as follows:

<PRE><span class="dynexp"><span class="comment">// This implementation is tail-recursive
</span><span class="keyword">fn</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> length <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int n</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">,</span>j<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> i<span class="keyword">)</span></span><span class="keyword">,</span> j<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int <span class="keyword">(</span>i+j<span class="keyword">)</span></span> <span class="keyword">=</span>
    <span class="keyword">case+</span> xs <span class="keyword">of</span> _ :: xs <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>xs<span class="keyword">,</span> j+1<span class="keyword">)</span> <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> j
<span class="keyword">in</span>
  loop <span class="keyword">(</span>xs<span class="keyword">,</span> 0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [length]
</span></span></PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="lists.dats">here</a>.

<!-- end of [lists.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [val-and-var.html] -->

<H2><A id="val-and-var" name="val-and-var">Val(ue) and Var(iable)
Declarations</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The keywords for introducing value identifiers
and variable identifiers are <u>val</u> and
<u>var</u>, respectiveily.  The essential difference between a value
identifier and a variable identifier is that the value referred to by the
former cannot be changed during the course of evaluation while the value
referred to by the latter can. This difference is clearly reflected in the
following two styles of implementation of the factorial function:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000"><FONT COLOR="#787878">// functional style
</FONT>fn</FONT> fact_val <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> 1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> x <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> loop <FONT COLOR="#000000">(</FONT>x-1<FONT COLOR="#000000">,</FONT> x * res<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> res
  <FONT COLOR="#787878">// end of [loop]
</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [fact_val]
</FONT>
<FONT COLOR="#787878">// imperative style
</FONT><FONT COLOR="#000000">fn</FONT> fact_var <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">var</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> x<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">var</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> 1
  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">while</FONT> <FONT COLOR="#000000">(</FONT>x <FONT COLOR="#000000">&gt;</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">(</FONT>res := x * res<FONT COLOR="#000000">;</FONT> x := x - 1<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  res  
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [fact_var]
</FONT></FONT></PRE>

In a functional language such as ML, where variable identifiers are not
available, an imperative style of implementation of the factorial function
may have to be written as follows:

<PRE><FONT COLOR="#E80000">
<FONT COLOR="#787878">// imperative style based on persistent references, which looks
</FONT><FONT COLOR="#787878">// awkward and runs inefficiently (in terms of both time and memory)
</FONT><FONT COLOR="#000000">fn</FONT> fact_ref <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">val</FONT> x <FONT COLOR="#000000">=</FONT> ref&lt;<FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">val</FONT> res <FONT COLOR="#000000">=</FONT> ref&lt;<FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">while</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>x <FONT COLOR="#000000">&gt;</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>res := <FONT COLOR="#000000">!</FONT>x * <FONT COLOR="#000000">!</FONT>res<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">!</FONT>x := <FONT COLOR="#000000">!</FONT>x - 1<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">!</FONT>res
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [fact_ref]
</FONT></FONT></PRE>

An implementation as such is often written by a beginner in functional
programming who has previously programmed in imperative languages (e.g., C,
C++, Java). The function <i>fact_ref</i> is clearly inefficient as each
call to it needs to allocate two references on heap (corresponding to
<i>x</i> and <i>res</i>), which can only be reclaimed by GC later.


<H4>No Local Variable Escapes</H4>

In a language like C that supports local variables, many problems are
caused by a local variable escaping its legal scope. This, however, is not
an issue in ATS as the type system of ATS guarantees that local
variables cannot be accessed out of its legal scope (while allowing
the addresses of local variables to be passed as function parameters).
<P>

We give another implementation of the factorial function as follows that
involves passing the addresses of local variables as function parameters:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>x<FONT COLOR="#000000">,</FONT>res<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>int @ x</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>int @ res</FONT></FONT> <FONT COLOR="#000000">|</FONT> p_x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr x</FONT><FONT COLOR="#000000">,</FONT> p_res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr res</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">if</FONT> <FONT COLOR="#000000">!</FONT>p_x <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">begin</FONT>
    <FONT COLOR="#000000">!</FONT>p_res := <FONT COLOR="#000000">!</FONT>p_x * <FONT COLOR="#000000">!</FONT>p_res<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">!</FONT>p_x := <FONT COLOR="#000000">!</FONT>p_x - 1<FONT COLOR="#000000">;</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_x</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_res</FONT> <FONT COLOR="#000000">|</FONT> p_x<FONT COLOR="#000000">,</FONT> p_res<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [loop]
</FONT><FONT COLOR="#787878">// end of [loop]
</FONT>
<FONT COLOR="#000000">fn</FONT> fact_var2 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">var</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> x<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">var</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> 1
<FONT COLOR="#000000">in</FONT>
  loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">view@ x</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">view@ res</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">&amp;</FONT>x<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">&amp;</FONT>res<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> res
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [fact_var2]
</FONT></FONT></PRE>

Each variable identifier is assoicated with two pieces of properties: its
address <i>L</i>, which is referred to by the same identifier, and a proof
of <i>VT@L</i>, where <i>VT</i> is the viewtype of the content stored at
<i>L</i>. For instance, in the implementation of <i>fact_var2</i>, we use
<i>view@ x</i> for the proof associated with the variable <i>x</i> and
<i>&x</i> for the address of <i>x</i>.
<P>

For each variable that is declared of viewtype <i>VT</i>, it is required
that a proof of <i>VT?@L</i> is available at the end of the legal scope of
the variable, where <i>L</i> is the address of the variable. This
requirement guarantees that a local variable, while its address can be
taken out of its scope, can never be accessed out of its scope due to the
unavailability of a proof needed for accessing the address.
<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="val-and-var.dats">here</a>.

<!-- end of [val-and-var.html] -->
<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [call-by-reference.html] -->

<H2><A id="call-by-reference"
name="call-by-reference">Call-By-Reference</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of call-by-reference in ATS is similar to the corresponding one
in C++. What is special in ATS is the way in which this feature is handled
by the type system.  In general, if <i>f</i> is given a type of the following
form for some viewtypes <i>VT1</i> and <i>VT2</i>:
<pre>
(..., &VT1 >> VT2, ...) -> ...
</pre>
then a function call
<i>f(..., x, ...)</i> on some variable <i>x</i> of the viewtype <i>VT1</i>
is to change the viewtype of <i>x</i> into <i>VT2</i> upon its return.  In
the case where <i>VT1</i> and <i>VT2</i> are the same, <i>&VT1 >> VT2</i>
can simply be written as <i>&VT1</i>. Note that the variable <i>x</i> may
be replaced with other forms of left-values.
<P>

As an example, an implementation of the factorial function is given as
follows that makes use of call-by-reference:

<PRE><FONT COLOR="#E80000">
<FONT COLOR="#000000">fun</FONT> fact <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> x <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">(</FONT>res := res * x<FONT COLOR="#000000">;</FONT> loop <FONT COLOR="#000000">(</FONT>x-1<FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">var</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> 1
<FONT COLOR="#000000">in</FONT>
  loop <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> res
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [fact]
</FONT>
</FONT></PRE>

Note that if the line for introducing the variable
<i>res</i> in the implementation is replaced with the following one:
<pre>
  val res: int = 1 // [res] is now a value, not a variable!
</pre>
then a type error should occur as <i>res</i> is no longer a left-value
when it is passed as an argument to <i>loop</i>.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="call-by-reference.dats">here</a>.

<!-- end of [call-by-reference.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [pointers.html] -->

<H2><A id="pointers" name="pointers">Pointers</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A significant achievement of ATS lies in its support for
<i>safe and flexible</i> use of pointers. This is done in a programming
paradigm that is often referred to as <EM>programming with theorem
proving</EM>.
<P>

Generally speaking, stateful views are <EM>linear</EM> propositions for
describing memory layouts. For instance, given a type <i>T</i> and a memory
location <i>L</i>, <i>T@L</i> is a primitive (stateful) view stating that a
value of type <i>T</i> is stored at <i>L</i>.  We can also form compound
views in terms of primitive views. For instance, given types <i>T_1</i> and
<i>T_2</i> and an address <i>L</i>, we can form a view
<i>(T_1@L, T_2@L+sizeof(T_1))</i> to mean that a value of type <i>T_1</i> and
another value of type <i>T_2</i> are stored at addresses <i>L</i> and
<i>L+sizeof(T_1)</i>, respectively, where <i>sizeof(T_1)</i> is the
size of a value of type <i>T</i>.  Given a term of some view <i>V</i>, we
often say that the term proves the view <i>V</i> and thus refer to the term
as a <EM>proof</EM> (of <i>V</i>).
<P>

There are two built-in functions
<i>ptr_get_t</i> and <i>ptr_set_t</i>
that are given the following types:
<PRE><FONT COLOR="#E80000">
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> ptr_get_t <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>a @ l &gt;&gt; a @ l <FONT COLOR="#000000">|</FONT> ptr l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;&gt;</FONT> a</FONT>
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> ptr_set_t <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>a? @ l &gt;&gt; a @ l <FONT COLOR="#000000">|</FONT> ptr l<FONT COLOR="#000000">,</FONT> a<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;&gt;</FONT> void</FONT>
</FONT></PRE>

These two functions are used to read from and write to a given pointer.
Clearly, the type of
<i>ptr_get_t</i> indicates that <i>ptr_get_t</i> requires a proof of view
<i>T@L</i> for some type <i>T</i> when reading from a pointer
<i>L</i>. This requirement disallows reading from a dangling pointer as
such a proof cannot be found for any dangling pointers. Similarly, the type
of <i>ptr_set_t</i> means that writing to a dangling pointer is also
disallowed.  When reading from a pointer <i>L</i> with a proof of view
<i>T@L</i>, <i>ptr_get_t</i> consumes the proof and then generates a proof
of the same view (and stores it in the same variable where the orginal
proof was stored).  On the other hand, when writing a value of type
<i>T</i> to a pointer with a proof of view <i>T?@L</i>, where the type
<i>T?</i> is for possibly uninitialized values of type <i>T</i>,
<i>ptr_set_t</i> consumes the proof and then generates a proof of the view
<i>T@L</i>, which simply attests to the fact that a value of type <i>T</i>
is stored at <i>L</i> after the writing is done.
<P>

As an example, we implement a (template) function <i>swap1</i> as follows
that swaps the contents stored at two memory locations:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT> swap1 <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">l1<FONT COLOR="#000000">,</FONT>l2<FONT COLOR="#000000">:</FONT>addr</FONT><FONT COLOR="#000000">}</FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>a @ l1</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>a @ l2</FONT></FONT> <FONT COLOR="#000000">|</FONT> p1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l1</FONT><FONT COLOR="#000000">,</FONT> p2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> tmp <FONT COLOR="#000000">=</FONT> ptr_get_vt&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf1</FONT> <FONT COLOR="#000000">|</FONT> p1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">in</FONT>
    ptr_set_vt&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf1</FONT> <FONT COLOR="#000000">|</FONT> p1<FONT COLOR="#000000">,</FONT> ptr_get_vt <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf2</FONT> <FONT COLOR="#000000">|</FONT> p2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT>
    ptr_set_vt&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf2</FONT> <FONT COLOR="#000000">|</FONT> p2<FONT COLOR="#000000">,</FONT> tmp<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

Note that the (linear) proofs are manipulated explicitly in the
implementation of <i>swap1</i>.  This can be burdensome in practice. In
ATS/Anairiats, (certain) proof manipulation can also be done implicitly by
the typechecker. For instance, the following code implements a (template)
function <i>swap2</i> that is equivalent to <i>swap1</i>:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT> swap2 <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">l1<FONT COLOR="#000000">,</FONT>l2<FONT COLOR="#000000">:</FONT>addr</FONT><FONT COLOR="#000000">}</FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>a @ l1</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>a @ l2</FONT></FONT> <FONT COLOR="#000000">|</FONT> p1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l1</FONT><FONT COLOR="#000000">,</FONT> p2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> tmp <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p1
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">!</FONT>p1 := <FONT COLOR="#000000">!</FONT>p2<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">!</FONT>p2 := tmp
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

There is no explicit manipulation of (linear) proofs in the implementation
of <i>swap2</i>.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="pointers.dats">here</a>.

<!-- end of [pointers.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [references.html] -->

<H2><A id="references" name="references">References</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A reference is essentially a persistent array of size 1.  Given a viewtype
<i>VT</i>, the type for references to values of viewtype <i>VT</i> is
<i>ref(VT)</i>. The type constructor <i>ref</i> is abstract in ATS, though
it can be defined as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">typedef</FONT> <FONT COLOR="#0000FF">ref <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT> viewt@ype<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">[</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">(</FONT>vbox <FONT COLOR="#000000">(</FONT>a@l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> ptr l<FONT COLOR="#000000">)</FONT></FONT>
</FONT></PRE>

The interfaces for various functions on references can be found in the file
<A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/reference.sats">prelude/SATS/reference.sats</A>.
<P>

<B>Reference Creation</B>&nbsp;&nbsp;
There is a function template <i>ref_make_elt</i> of the following type:

<PRE>
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT> ref_make_elt <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a <FONT COLOR="#000000">-&lt;&gt; </FONT>ref a</FONT>
</PRE>

Given a value <i>v</i> of some viewtype <i>VT</i>,
<i>ref_make_elt&lt;VT&gt; (v)</i> creates a reference of type
<i>ref(VT)</i>. For instance, the following code creates some references:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">val</FONT> r_int <FONT COLOR="#000000">=</FONT> ref_make_elt&lt;<FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">val</FONT> r_double <FONT COLOR="#000000">=</FONT> ref_make_elt&lt;<FONT COLOR="#0000FF">double</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>0.0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">val</FONT> r_fun <FONT COLOR="#000000">=</FONT> ref_make_elt&lt;<FONT COLOR="#0000FF">int<FONT COLOR="#000000">-&gt;</FONT>int</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> x+1<FONT COLOR="#000000">)</FONT>
</FONT></PRE>

There is also a function <i>ref_make_view_ptr</i> of the following type for
turning pointers into references:

<PRE>
<FONT COLOR="#000000">fun</FONT> ref_make_view_ptr <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>vbox<FONT COLOR="#000000">(</FONT>a @ l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> ptr l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> ref a</FONT>
</PRE>

Note that <i>ref_make_view_ptr</i> is a polymorphic function; it is not a
function template.
<P>

<B>Reference Read and Write</B>&nbsp;&nbsp;

Given a reference <i>r</i>, the syntax for reading from <i>r</i> is
<i>!r</i> and the syntax for writing (a value <i>v</i>) to <i>r</i> is
<i>!r := v</i>. Note that in both SML and Objective Caml, the
syntax for writing (a value <i>v</i>) to a reference <i>r</i>
is <i>r := v</i> (instead of <i>!r := v</i>).
<P>

There are also two function templates
<i>ref_get_elt</i> and <i>ref_set_elt</i> of the following types:

<PRE>
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@type</FONT><FONT COLOR="#000000">}</FONT> ref_get_elt <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ref a <FONT COLOR="#000000">-&lt;</FONT><FONT COLOR="#000000">!</FONT>ref<FONT COLOR="#000000">&gt;</FONT> a</FONT>
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@type</FONT><FONT COLOR="#000000">}</FONT> ref_set_elt <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>ref a<FONT COLOR="#000000">,</FONT> a<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT><FONT COLOR="#000000">!</FONT>ref<FONT COLOR="#000000">&gt;</FONT> void</FONT>
</PRE>

which can used to read from and write to a given reference, respectively.
As an example, we give a simple implementation of counters as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [int64] is the type for 64-bit integers in ATS
</FONT><FONT COLOR="#000000">typedef</FONT> <FONT COLOR="#0000FF">counter <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">'{</FONT> <FONT COLOR="#787878">// the type for counter objects
</FONT>  get<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> int64 <FONT COLOR="#787878">// get the value of the counter
</FONT><FONT COLOR="#000000">,</FONT> set<FONT COLOR="#000000">=</FONT> int64 <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> void <FONT COLOR="#787878">// set the value of the counter
</FONT><FONT COLOR="#000000">,</FONT> inc<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> void <FONT COLOR="#787878">// increase the value of the counter
</FONT><FONT COLOR="#000000">,</FONT> dec<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> void <FONT COLOR="#787878">// decrease the value of the counter
</FONT><FONT COLOR="#000000">}</FONT></FONT>

<FONT COLOR="#000000">fn</FONT> counter_make <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">counter</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#787878">// [int64_of_int] coerce an integer into a 64-bit integer
</FONT>  <FONT COLOR="#000000">val</FONT> r <FONT COLOR="#000000">=</FONT> ref_make_elt&lt;<FONT COLOR="#0000FF">int64</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>int64_of_int 0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">'{</FONT> <FONT COLOR="#787878">// record creation
</FONT>  get<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">!</FONT>r <FONT COLOR="#787878">// read from [r]
</FONT><FONT COLOR="#000000">,</FONT> set<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">!</FONT>r := x <FONT COLOR="#787878">// write to [r]
</FONT><FONT COLOR="#000000">,</FONT> inc<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">!</FONT>r := succ <FONT COLOR="#000000">!</FONT>r
<FONT COLOR="#000000">,</FONT> dec<FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">!</FONT>r := pred <FONT COLOR="#000000">!</FONT>r
<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [counter_make]
</FONT>
</FONT></PRE>

<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="references.dats">here</a>.

<!-- end of [references.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [arrays-and-matrices.html] -->

<H2><A id="arrays-and-matrices" name="arrays-and-matrices">Persistent
Arrays and Matrices</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Though arrays are widely used in practice, there are many difficult issues
involving arrays that seem to have not been adequately addressed in type
theory.  In particular, programming can become rather tricky when arrays
are used to store resources (e.g., pointers to allocated memory).
<P>

In ATS, there are two forms of arrays: linear arrays and persistent
arrays. On one hand, a linear array cannot be shared but a persistent array
can. On the other hand, a linear array can be explicitly freed but a
persistent one cannot. However, a persistent array may be freed by GC.

Although persistent arrays are built in terms of linear arrays, it seems
easier to explain persistent arrays as such arrays are available in
probably any programming language that may be considered practical.

<H3>Persistent Arrays</H3>

The interfaces for various functions on persistent arrays can be found in
the file <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/array.sats">prelude/SATS/array.sats</A>.

Given a viewtype <i>VT</i> and an integer <i>I</I>, the type <i>array(VT,
I)</i> is for persistent arrays of size <i>I</i> in which each element is
of viewtype <i>VT</i>. Internally, a value of the type <i>array(VT, I)</i>
is just a pointer to a piece of consecutive memory holding <i>I</i> elements of
the type <i>VT</i>. Note that there is no size information directly attached to
such an array, that is, <u>no function of the following type is available</u>:

<pre>
fun{a:viewt@ype} array_size {n:nat} (A: array (a, n)): int n
</pre>

If the size of such an array is needed, it may be stored somewhere
explicitly by the programmer.
<P>

<B>Array Creation</B>&nbsp;&nbsp;
There are several approaches to creating persistent arrays in ATS.
For instance, the following code in ATS creates an array of integers:

<pre>
val digits = array $arrsz{int}(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>

The type assigned to the variable <i>digits</i> is <i>array(int, 10)</i>.
We can certainly be more precise by stating that <i>digits</i> is indeed an
array of digits:

<pre>
typedef digit = [i:nat | i &lt; 10] int (i)

// digits: array (digit, 10)
val digits = array $arrsz{digit}(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>
<P>

<B>Array Subscripting</B>&nbsp;&nbsp;

The following two function templates
<i>array_get_elt_at</i> and <i>array_set_elt_at</i>
are for accessing and updating a persistent array, respectively:

<pre>
fun{a:t@ype} array_get_elt_at {n:nat} (A: array (a, n), i: sizeLt n):&lt;!ref&gt; a
fun{a:t@ype} array_set_elt_at {n:nat} (A: array (a, n), i: sizeLt n, x: a):&lt;!ref&gt; void
</pre>

The symbol <i>[]</i> is overloaded with both <i>array_get_elt_at</i> and
<i>array_set_elt_at</i>:

<pre>
overload [] with array_get_elt_at
overload [] with array_set_elt_at
</pre>

As an example, we implement as follows a function that squares each element
in a given array of doubles:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT> array_square <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array <FONT COLOR="#000000">(</FONT>double<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> sz<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n-i<FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloptr1</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">&lt;</FONT> sz <FONT COLOR="#000000">then</FONT>
      <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> x <FONT COLOR="#000000">=</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">in</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := x * x<FONT COLOR="#000000">;</FONT> loop <FONT COLOR="#000000">(</FONT>i+1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [array_square]
</FONT></FONT></PRE>

In this code, <i>A[i]</i> and <i>A[i] := x * x</i> 
are shorthands for
<i>array_get_elt_at(A, i)</i> and <i>array_set_elt_at(A, i, x * x)</i>,
respectively.
<P>

<H3>Persistent Matrices</H3>

A matrix is an array of 2 dimensions. Note that the 2 dimensions of a
matrix are not necessarily the same. If they are the same, then the matrix
is often referred to as a square matrix.
<P>

The interfaces for various functions on matrices can be found in the file
<a href="../../IMPLEMENTATION/Anairiats/ATS/prelude/SATS/matrix.sats">prelude/SATS/matrix.sats
</a>.

Given a viewtype <i>VT</i> and an integer <i>I</I> and another integer
<i>J</i>, the type <i>matrix(VT, I, J)</i> is for persistent matrices of
dimensions <i>I</i> (row) and <i>J</i> (column) in which each element is of
type <i>VT</i>.  Internally, a value of the type <i>matrix(VT, I, J)</i> is
just a pointer to a piece of consecutive memory holding <i>I*J</i> elements
of the type <i>VT</i>, where the elements are placed in the row-major
format.
<P>

<B>Matrix Creation</B>&nbsp;&nbsp;
The approaches to creating matrices resemble those to creating arrays.
For instance, the following code creates a square matrix of dimension
10 by 10:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">val</FONT> mat_10_10 <FONT COLOR="#000000">=</FONT>
  matrix <FONT COLOR="#000000">(</FONT>10<FONT COLOR="#000000">,</FONT> 10<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">$arrsz</FONT> <FONT COLOR="#000000">{</FONT>Int<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>
   0<FONT COLOR="#000000">,</FONT>  1<FONT COLOR="#000000">,</FONT>  2<FONT COLOR="#000000">,</FONT>  3<FONT COLOR="#000000">,</FONT>  4<FONT COLOR="#000000">,</FONT>  5<FONT COLOR="#000000">,</FONT>  6<FONT COLOR="#000000">,</FONT>  7<FONT COLOR="#000000">,</FONT>  8<FONT COLOR="#000000">,</FONT>  9
<FONT COLOR="#000000">,</FONT> 10<FONT COLOR="#000000">,</FONT> 11<FONT COLOR="#000000">,</FONT> 12<FONT COLOR="#000000">,</FONT> 13<FONT COLOR="#000000">,</FONT> 14<FONT COLOR="#000000">,</FONT> 15<FONT COLOR="#000000">,</FONT> 16<FONT COLOR="#000000">,</FONT> 17<FONT COLOR="#000000">,</FONT> 18<FONT COLOR="#000000">,</FONT> 19
<FONT COLOR="#000000">,</FONT> 20<FONT COLOR="#000000">,</FONT> 21<FONT COLOR="#000000">,</FONT> 22<FONT COLOR="#000000">,</FONT> 23<FONT COLOR="#000000">,</FONT> 24<FONT COLOR="#000000">,</FONT> 25<FONT COLOR="#000000">,</FONT> 26<FONT COLOR="#000000">,</FONT> 27<FONT COLOR="#000000">,</FONT> 28<FONT COLOR="#000000">,</FONT> 29
<FONT COLOR="#000000">,</FONT> 30<FONT COLOR="#000000">,</FONT> 31<FONT COLOR="#000000">,</FONT> 32<FONT COLOR="#000000">,</FONT> 33<FONT COLOR="#000000">,</FONT> 34<FONT COLOR="#000000">,</FONT> 35<FONT COLOR="#000000">,</FONT> 36<FONT COLOR="#000000">,</FONT> 37<FONT COLOR="#000000">,</FONT> 38<FONT COLOR="#000000">,</FONT> 39
<FONT COLOR="#000000">,</FONT> 40<FONT COLOR="#000000">,</FONT> 41<FONT COLOR="#000000">,</FONT> 42<FONT COLOR="#000000">,</FONT> 43<FONT COLOR="#000000">,</FONT> 44<FONT COLOR="#000000">,</FONT> 45<FONT COLOR="#000000">,</FONT> 46<FONT COLOR="#000000">,</FONT> 47<FONT COLOR="#000000">,</FONT> 48<FONT COLOR="#000000">,</FONT> 49
<FONT COLOR="#000000">,</FONT> 50<FONT COLOR="#000000">,</FONT> 51<FONT COLOR="#000000">,</FONT> 52<FONT COLOR="#000000">,</FONT> 53<FONT COLOR="#000000">,</FONT> 54<FONT COLOR="#000000">,</FONT> 55<FONT COLOR="#000000">,</FONT> 56<FONT COLOR="#000000">,</FONT> 57<FONT COLOR="#000000">,</FONT> 58<FONT COLOR="#000000">,</FONT> 59
<FONT COLOR="#000000">,</FONT> 60<FONT COLOR="#000000">,</FONT> 61<FONT COLOR="#000000">,</FONT> 62<FONT COLOR="#000000">,</FONT> 63<FONT COLOR="#000000">,</FONT> 64<FONT COLOR="#000000">,</FONT> 65<FONT COLOR="#000000">,</FONT> 66<FONT COLOR="#000000">,</FONT> 67<FONT COLOR="#000000">,</FONT> 68<FONT COLOR="#000000">,</FONT> 69
<FONT COLOR="#000000">,</FONT> 70<FONT COLOR="#000000">,</FONT> 71<FONT COLOR="#000000">,</FONT> 72<FONT COLOR="#000000">,</FONT> 73<FONT COLOR="#000000">,</FONT> 74<FONT COLOR="#000000">,</FONT> 75<FONT COLOR="#000000">,</FONT> 76<FONT COLOR="#000000">,</FONT> 77<FONT COLOR="#000000">,</FONT> 78<FONT COLOR="#000000">,</FONT> 79
<FONT COLOR="#000000">,</FONT> 80<FONT COLOR="#000000">,</FONT> 81<FONT COLOR="#000000">,</FONT> 82<FONT COLOR="#000000">,</FONT> 83<FONT COLOR="#000000">,</FONT> 84<FONT COLOR="#000000">,</FONT> 85<FONT COLOR="#000000">,</FONT> 86<FONT COLOR="#000000">,</FONT> 87<FONT COLOR="#000000">,</FONT> 88<FONT COLOR="#000000">,</FONT> 89
<FONT COLOR="#000000">,</FONT> 90<FONT COLOR="#000000">,</FONT> 91<FONT COLOR="#000000">,</FONT> 92<FONT COLOR="#000000">,</FONT> 93<FONT COLOR="#000000">,</FONT> 94<FONT COLOR="#000000">,</FONT> 99<FONT COLOR="#000000">,</FONT> 96<FONT COLOR="#000000">,</FONT> 97<FONT COLOR="#000000">,</FONT> 98<FONT COLOR="#000000">,</FONT> 99
<FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// end of [val]
</FONT></FONT></PRE>

<B>Matrix Subscripting</B>&nbsp;&nbsp;

The following two function templates
<i>matrix_get_elt_at</i> and <i>matrix_set_elt_at</i>
are for accessing and updating a persistent matrix, respectively:

<pre>
fun{a:t@ype} matrix_get_elt_at {m,n:nat} (A: matrix (a,m,n), i: sizeLt m, n: int n, j: sizeLt n): &lt;!ref&gt; a
fun{a:t@ype} matrix_set_elt_at {m,n:nat} (A: matrix (a,m,n), i: sizeLt m, n: int n, j: sizeLt n, x: a): &lt;!ref&gt; void
</pre>

Note that the number of columns in a matrix as well as the row and column
indices are needed in order to perform matrix subscripting. As an example,
the following code implements a function template that transposes a given
square matrix in-situ:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> matrix_transpose <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">matrix <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fn</FONT> get <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">;</FONT> j <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT>
   <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">matrix <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloref1</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">a</FONT> <FONT COLOR="#000000">=</FONT>
   matrix_get_elt_at__intsz <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">)</FONT>

  <FONT COLOR="#000000">fn</FONT> set <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">;</FONT> j <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT>
   <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">matrix <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloref1</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
   matrix_set_elt_at__intsz <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">)</FONT>

  <FONT COLOR="#000000">overload</FONT> <FONT COLOR="#800080"><FONT COLOR="#000000">[</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">with</FONT> get</FONT><FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">overload</FONT> <FONT COLOR="#800080"><FONT COLOR="#000000">[</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">with</FONT> set</FONT>

  <FONT COLOR="#787878">// [fn*] indicates a request for tail-call optimization
</FONT>  <FONT COLOR="#000000">fn*</FONT> loop1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> n-i+1<FONT COLOR="#000000">,</FONT> 0 <FONT COLOR="#000000">&gt;.</FONT></FONT>
    <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloptr1</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT>
    <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">&lt;</FONT> n <FONT COLOR="#000000">then</FONT> loop2 <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>

  <FONT COLOR="#000000">and</FONT> loop2 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">;</FONT> j &lt;= i<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> n-i<FONT COLOR="#000000">,</FONT> i-j+1 <FONT COLOR="#000000">&gt;.</FONT></FONT>
    <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloptr1</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT>
    <FONT COLOR="#000000">if</FONT> j <FONT COLOR="#000000">&lt;</FONT> i <FONT COLOR="#000000">then</FONT>
      <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> x <FONT COLOR="#000000">=</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">in</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> := A[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">;</FONT> A[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := x<FONT COLOR="#000000">;</FONT> loop2 <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> j+1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
      loop1 <FONT COLOR="#000000">(</FONT>i+1<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [loop2]
</FONT><FONT COLOR="#000000">in</FONT>
  loop1 0
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [matrix_transpose]
</FONT>
<FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> matrix_transpose <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>M<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">matrix <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf <FONT COLOR="#000000">=</FONT> unit_v <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> matrix_iforeach_clo&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>unit_v<FONT COLOR="#000000">}</FONT></FONT>
    <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf</FONT> <FONT COLOR="#000000">|</FONT> M<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_f<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT> <FONT COLOR="#787878">
</FONT>    <FONT COLOR="#000000">var</FONT> <FONT COLOR="#000000">!</FONT>p_f <FONT COLOR="#000000">=</FONT> @lam
      <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>unit_v</FONT></FONT> <FONT COLOR="#000000">|</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">sizeLt n</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">sizeLt n</FONT><FONT COLOR="#000000">,</FONT> _<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=&lt;</FONT><FONT COLOR="#0000FF">clo</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#000000">!</FONT><FONT COLOR="#0000FF">ref</FONT><FONT COLOR="#000000">&gt;</FONT>
      <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">&gt;</FONT> j <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">val</FONT> x <FONT COLOR="#000000">=</FONT> M[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">n</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">in</FONT> M[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">n</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> := M[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">n</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">;</FONT> M[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">n</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := x
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT>    <FONT COLOR="#787878">// end of [var]
</FONT>  <FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [val]
</FONT>  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">unit_v <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf</FONT>
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#787878">// empty
</FONT><FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [matrix_transpose]
</FONT></FONT></PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="arrays-and-matrices.dats">here</a>.

<!-- end of [arrays-and-matrices.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [linear-arrays.html] -->

<H2><A id="linear-arrays" name="linear arrays">Linear Arrays</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Given a viewtype <i>VT</i> and integer <i>I</i>, the special static term
<i>@[VT][I]</i> is a viewtype for an array of elements of the type <i>VT</i>
(and thus the size of <i>@[VT][I]</i> is <i>I</i> times the size of
<i>VT</i>). If <i>VT</i> happens to be a type (instead of viewtype), then
<i>@[VT][I]</i> is also a type. If a linear proof of the view <i>(@[VT][I])
@ L</i> is available, then we say that a linear array of size <i>I</i> is
stored at the location <i>L</i> in which each element is of the type
<i>VT</i>. A view of the form <i>@[VT][I] @ L</i> is often referred to
as an array view.
<P>

The interfaces for various functions on linear arrays can be found in the
file <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/array.sats">prelude/SATS/array.sats</A>.
In particular, we have the following functions for manipulating array views:

<pre>
viewdef array_v (a:viewt@ype, n:int, l: addr) = @[a][n] @ l

praxi array_v_nil :
  {a:viewt@ype} {l:addr} () -&lt;prf&gt; array_v (a, 0, l)

praxi array_v_unnil :
  {a:viewt@ype} {l:addr} array_v (a, 0, l) -&lt;prf&gt; void

praxi array_v_cons : {a:viewt@ype} {n:nat} {l:addr}
  (a @ l, array_v (a, n, l+sizeof a)) -&lt;prf&gt; array_v (a, n+1, l)

praxi array_v_uncons : {a:viewt@ype} {n:int | n > 0} {l:addr}
  array_v (a, n, l) -&lt;prf&gt; (a @ l, array_v (a, n-1, l+sizeof a))
</pre>

<H4>Linear Array Creation</H4>
The following function template <i>array_ptr_alloc</i> can be called to
allocate memory for storing an array of elements:

<pre>
fun{a:viewt@ype}
  array_ptr_alloc {n:nat} (asz: int n):<>
    [l:addr | l <> null] (free_gc_v (a, n, l), array_v (a?, n, l) | ptr l)
</pre>

The view constructor <i>free_gc_v</i> is abstract, and a proof of the view
<i>free_gc_v (a, n, l)</i> can be thought of as a certificate that must be
provided when the allocated array is to be freed. The array view
<i>array_v (a?, n, l)</i> is for an uninitialized array of size
<i>n</i> in which each element should be of the type <i>a</i> if
initialized.

<H4>Linear Array Initialization</H4>

After an uninitialized array is created, it needs to be initialized for
use. There are various functions for initializing linear arrays in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/array.sats">prelude/SATS/array.sats</A>.
As an example, we implement as follows a function that initializes an array
with a list of elements:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT>
  array_ptr_initialize_list <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">@[</FONT>a?<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT> &gt;&gt; <FONT COLOR="#000000">@[</FONT>a<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">]</FONT></FONT><FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">view@ A</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">&amp;</FONT>A<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT> nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n<FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT> <FONT COLOR="#787878">// [loop] is tail-recursive!
</FONT>      <FONT COLOR="#009000">pf_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>array_v <FONT COLOR="#000000">(</FONT>a?<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT> &gt;&gt; array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT></FONT> <FONT COLOR="#000000">|</FONT> p_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
    <FONT COLOR="#000000">|</FONT> list_cons <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf1_at<FONT COLOR="#000000">,</FONT> pf2_arr<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_uncons <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a?<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">)</FONT></FONT>
        <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p_arr := x
        <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf2_arr</FONT> <FONT COLOR="#000000">|</FONT> p_arr + sizeof&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT><FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">in</FONT>
        pf_arr := array_v_cons <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf1_at<FONT COLOR="#000000">,</FONT> pf2_arr<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [list_cons]
</FONT>    <FONT COLOR="#000000">|</FONT> list_nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_unnil <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a?<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">in</FONT> pf_arr := array_v_nil <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [list_nil]
</FONT>  <FONT COLOR="#787878">// end of [loop]
</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [array_ptr_initialize_list]  
</FONT></FONT></PRE>

Note that the first argument of the function
<i>array_ptr_initialize_list</i> is passed as a reference
(call-by-reference).  We use the expression <i>view@ A</i> for some
particular left-value in which a proof of the view associated with the
variable <i>A</i> is stored, and the expression <i>&A</i> for the address
of the variable <i>A</i>.

<H4>Linear Array Subscription</H4>

Let <i>A</i> be an array of the type <i>@[T][I]</i> for some type (but not
viewtype) <i>T</i> and integer <i>I</i>. For each natural number less than
<i>I</i>, the expression <i>A.[i]</i>, which can be used as a left-value,
refers to the <i>i</i>th elemement of the array (where counting starts from
<i>0</i>). A function template <i>array_ptr_swap</i> is implemented as
follows for swapping two elements in a given array:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> array_ptr_swap
  <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">;</FONT> j <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">@[</FONT>a<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT>
  <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> tmp <FONT COLOR="#000000">=</FONT> A<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT><FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">in</FONT> A<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT><FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := A<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT><FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">;</FONT> A<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT><FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> := tmp <FONT COLOR="#000000">end</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// endof [array_ptr_swap]
</FONT></FONT></PRE>

The following two function templates are also available:

<pre>
fun{a:t@ype} array_ptr_get_elt_at
  {n:nat} (A: &(@[a][n]), i: natLt n):<> a

fun{a:t@ype} array_ptr_set_elt_at
  {n:nat} (A: &(@[a][n]), i: natLt n, x:a):<> void

overload [] with array_ptr_get_elt_at
overload [] with array_ptr_set_elt_at
</pre>

Because of the overloading of <i>[]</i> with both
<i>array_ptr_get_elt_at</i> and <i>array_ptr_set_elt_at</i>, the function
<i>array_ptr_swap</i> can also be implemented as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> array_ptr_swap
  <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">;</FONT> j <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>A<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">@[</FONT>a<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int i</FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT>
  <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> tmp <FONT COLOR="#000000">=</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">in</FONT> A[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := A[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">;</FONT> A[<FONT COLOR="#009000">j</FONT><FONT COLOR="#000000">]</FONT> := tmp <FONT COLOR="#000000">end</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// endof [array_ptr_swap]
</FONT></FONT></PRE>

The use of <i>[i]</i> for <i>.[i]</i> possibly makes the code look more conventional.
<P>

For accessing an array of linear elements, the following function template
<i>array_ptr_takeout</i> can be used:

<PRE>
fun{a:viewt@ype}
  array_ptr_takeout {n,i:nat | i < n} {l0:addr} (
    pf: array_v (a, n, l0) | base: ptr l0, offset: int i
  ) :<> [l:addr] (
      a @ l
    , a @ l -&lt;lin,prf&gt; array_v (a, n, l0)
    | ptr l
    )
// end of [array_ptr_takeout]
</PRE>

<H4>Linear Array Destruction</H4>
The following function is for freeing the memory occupied by a linear
array:

<pre>
fun array_ptr_free {a:viewt@ype} {n:int} {l:addr}
  (pf_gc: free_gc_v (a, n, l), pf_arr: array_v (a?, n, l) | _: ptr l):<> void
</pre>

Note that in order to free an array of <i>I</i> elements allocated at an
address <i>L</i>, a proof of the view <i>free_gc_v (VT, I, L)</i> must be
provided, where the viewtype <i>VT</i> is employed for specifying the size
of each element in the array.

<H4>An Example</H4>

Linear arrays are used extensively in this implementation of FFT: <A
HREF="http://www.ats-lang.org/EXAMPLE/MISC/fft.dats">fft.dats</A>


<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="linear-arrays.dats">here</a>.

<!-- end of [linear-arrays.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [strings.html] -->

<H2><A id="strings" name="strings">Strings and String Buffers</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The representation of a string in ATS is exactly the same as in C, allowing
most functions declared in the header file &lt;string.h&gt; to be imported
into ATS directly. A variety of string functions are declared in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/string.sats">prelude/SATS/string.sats</A>.
<P>

Given an integer <i>I</i>, a string of length <i>I</i> is a pointer to some
memory location where a seqence of bytes are stored: the first <i>I</i>
bytes in this sequence are non-null bytes, and the next one is the null byte,
and then the rest of bytes are unspecified.  We use <i>string</i> both as a
type and a type constructor of the sort <i>int -&gt; type</i>.  The type
<i>string</i> is for strings of unspecified length while the type
<i>string (I)</i> is for strings whose length equals <i>I</i>, and the
following casting function is relating the former to the latter:

<pre>
castfn string1_of_string (s: string): [n:nat] string n
</pre>

<H4>Common Functions for Processing Strings</H4>

The following function <i>string_is_at_end</i> is of great use for
processing strings sequentially:

<pre>
fun string_is_at_end
  {n,i:nat | i <= n} (s: string n, i: int i):<> bool (i == n)
  = "atspre_string_is_at_end"
</pre>

Given a string of length <i>n</i> and a natural number <i>i</i> bounded by
<i>n</i>, the function <i>string_is_at_end</i> tests whether <i>i</i>
equals <i>n</i>. Essentially, it checks whether the <i>i</i>th character in
the string, where counting starts from <i>0</i>, is the null byte.
<P>

As an example, the following implementation of the length function for
strings makes use of the function <i>string_is_at_end</i>:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT> string_length <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">string n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">size_t n</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n-i<FONT COLOR="#000000">&gt;.</FONT></FONT>
    <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">string n</FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t i</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">size_t n</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> string_is_at_end <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">then</FONT> i <FONT COLOR="#000000">else</FONT> loop <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> i+1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#787878">// end of [loop]
</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [string_length]
</FONT></FONT></PRE>

The following two functions
<i>string_get_char_at</i> and <i>string_set_char_at</i> are for accessing
and updating charaters stored in a string:

<pre>
#define NUL '\000'

fun string_get_char_at {n:nat}
  (s: string n, i: natLt n):&lt;&gt; [c:char | c <> NUL] char c

fun string_set_char_at {n:nat} {c:char | c <> NUL}
  (s: string n, i: natLt n, c: char c):&lt;!ref&gt; void

overload [] with string_get_char_at
overload [] with string_set_char_at
</pre>

Note that only non-null characters can be stored in a string.

<H4>String Buffers</H4>

A string buffer in ATS is just a linear string.  Given two integers
<i>M</i> and <i>N</i> satisfying <i>M &lt;= N</i>, the type
<i>strbuf (M, N)</i> is for a sequence of <i>M</i> bytes such that the first
<i>N</i> bytes in this sequence are not null and the next one (following
the first <i>N</i> bytes) is null.

The following declared functions for string buffers are just the variant of
the previously introduced functions for strings:

<pre>
fun strbuf_is_at_end
  {m,n,i:nat | i <= n} (sb: &strbuf (m, n), i: int i):<> bool (i == n)

fun strbuf_get_char_at {m,n:nat}
  (sb: &strbuf (m, n), i: natLt n):<> [c:char | c <> NUL] char c

fun strbuf_set_char_at {m,n:nat} {c: char | c <> NUL}
  (sb: &strbuf (m, n), i: natLt n, c: char c):<> void
</pre>

As an example, the following program implements a function that turns each
lowercase letter in a string buffer into the corresponding uppercase one:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT> strbuf_toupper <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>strbuf <FONT COLOR="#000000">(</FONT>m<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">fun</FONT> toupper <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">c1har</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">c1har</FONT> <FONT COLOR="#000000">=</FONT> "atspre_char_toupper"
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n-i<FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>strbuf <FONT COLOR="#000000">(</FONT>m<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t i</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> strbuf_is_at_end <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> s[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT> := toupper <FONT COLOR="#000000">(</FONT>s[<FONT COLOR="#009000">i</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> loop <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">,</FONT> i+1<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [strbuf_toupper]
</FONT></FONT></PRE>

Note that <i>c1har</i> is just a shorthand for
<i>[c:char | c <> NUL] char c</i>, which is a type for all non-null
characters.

Let us see another example. In C, the length of a string can be computed as follows:

<pre>
int strlen (char *s) {
  char *p = s ;
  while (*p != '\000') ++p ;
  return (p - s) ;
}
</pre>

We give as follows an implementation for computing
the length of a string buffer that corresponds to the above C code:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">fun</FONT> strlen <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>strbuf <FONT COLOR="#000000">(</FONT>m<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">size_t n</FONT>

<FONT COLOR="#000000">implement</FONT> strlen <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>s<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">stadef</FONT> <FONT COLOR="#0000FF">bsz <FONT COLOR="#000000">=</FONT> sizeof<FONT COLOR="#000000">(</FONT>byte<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">macdef</FONT> <FONT COLOR="#800080">bsz <FONT COLOR="#000000">=</FONT> sizeof&lt;byte<FONT COLOR="#000000">&gt;</FONT></FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>ofs<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>m<FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT>
      <FONT COLOR="#009000">pf<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>strbuf <FONT COLOR="#000000">(</FONT>m<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT> @ l</FONT></FONT>
    <FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">MUL <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> bsz<FONT COLOR="#000000">,</FONT> ofs<FONT COLOR="#000000">)</FONT></FONT></FONT>
    <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT>
    <FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">:&lt;&gt;</FONT> <FONT COLOR="#0000FF">ptr <FONT COLOR="#000000">(</FONT>l + ofs<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> strbuf_v_uncons <FONT COLOR="#000000">(</FONT>pf<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">val</FONT> c <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">if</FONT> <FONT COLOR="#000000">(</FONT>c <FONT COLOR="#000000">=</FONT> NUL<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">strbufopt_v_none pf2 <FONT COLOR="#000000">=</FONT> pf2</FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
    <FONT COLOR="#000000">in</FONT>
      pf := strbuf_v_null <FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> p
    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> eqsize_byte_char <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">strbufopt_v_some pf2 <FONT COLOR="#000000">=</FONT> pf2</FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf1_mul <FONT COLOR="#000000">=</FONT> mul_add_const <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>~1<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_mul<FONT COLOR="#000000">)</FONT></FONT>
      <FONT COLOR="#000000">val</FONT> p_end <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf2</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf1_mul</FONT> <FONT COLOR="#000000">|</FONT> p+bsz<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">in</FONT>
      pf := strbuf_v_cons <FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> p_end
    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT>  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [loop]
</FONT>  <FONT COLOR="#000000">val</FONT> p_beg <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">&amp;</FONT>s
  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_mul <FONT COLOR="#000000">=</FONT> mul_istot <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>bsz<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">val</FONT> p_end <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">view@ s</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul</FONT> <FONT COLOR="#000000">|</FONT> p_beg<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> eqsize_byte_one <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
    <FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">praxi</FONT> <FONT COLOR="#009000">eqsize_byte_one <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">[</FONT>bsz == 1<FONT COLOR="#000000">]</FONT> void</FONT></FONT>
  <FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#787878">// end of [val]
</FONT>  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> mul_elim <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>1<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_mul<FONT COLOR="#000000">)</FONT></FONT>
<FONT COLOR="#000000">in</FONT>
  size1_of_ptrdiff1 <FONT COLOR="#000000">(</FONT>p_end - p_beg<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [strlen]
</FONT></FONT></PRE>

Please see <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/string.sats">prelude/SATS/string.sats</A>
for various dataview constructors and proof functions in this
implementation.  In general, it can be quite involved in ATS to handle
strings in a style that is often employed in C code.

<H4>String Creation</H4>

There are various function for creating strings that are delcared in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/string.sats">prelude/SATS/string.sats</A>.
For instance, the following function <i>string_make_substring</i> creates a
string by copying a segment of another string:

<pre>
fun string_make_substring
  {n:int} {st,ln:nat | st + ln <= n}
  (s: string n, st: int st, ln: int ln):<> string ln
</pre>

In order to implement a string creation function, we often need a function
such as the following one for initializing a string buffer:

<pre>
fun strbuf_initialize_cloptr {m,n:nat | m > n} (
    pf_buf: !b0ytes m @ l >> strbuf (m, n) @ l
  | p: ptr l, n: int n, f: !natLt n -<cloref> c1har
  ) :<> void
</pre>

An implementation of <i>strbuf_initialize_cloptr</i> is given below:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">implement</FONT> strbuf_initialize_cloptr <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_buf</FONT> <FONT COLOR="#000000">|</FONT> p_buf<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_buf</FONT> <FONT COLOR="#000000">|</FONT> p_buf<FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n-i<FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT>
      <FONT COLOR="#009000">pf<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>b0ytes <FONT COLOR="#000000">(</FONT>m-i<FONT COLOR="#000000">)</FONT> @ l &gt;&gt; strbuf <FONT COLOR="#000000">(</FONT>m-i<FONT COLOR="#000000">,</FONT> n-i<FONT COLOR="#000000">)</FONT> @ l</FONT></FONT>
    <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>sizeLt n <FONT COLOR="#000000">-&lt;</FONT>cloptr<FONT COLOR="#000000">&gt;</FONT> c1har</FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t i</FONT><FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">cloref</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> eqsize_byte_char <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_uncons <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>byte?<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf1 <FONT COLOR="#000000">=</FONT> char_v_of_b0yte_v <FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">&lt;</FONT> n <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p := f <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf2</FONT> <FONT COLOR="#000000">|</FONT> p + sizeof&lt;<FONT COLOR="#0000FF">byte</FONT><FONT COLOR="#000000">&gt;</FONT><FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">,</FONT> i + 1<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf := strbuf_v_cons <FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">in</FONT>
      <FONT COLOR="#787878">// empty
</FONT>    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p := NUL
      <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf := strbuf_v_null <FONT COLOR="#000000">(</FONT>pf1<FONT COLOR="#000000">,</FONT> pf2<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">in</FONT>
      <FONT COLOR="#787878">// empty
</FONT>    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT>  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [loop]
</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// end of [val]
</FONT></FONT></PRE>

With <i>strbuf_initialize_cloptr</i>, the string creation function
<i>string_make_substring</i> can be readily implemented as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">implement</FONT> string_make_substring <FONT COLOR="#000000">(</FONT>str<FONT COLOR="#000000">,</FONT> st<FONT COLOR="#000000">,</FONT> ln<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_gc</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_buf</FONT> <FONT COLOR="#000000">|</FONT> p_buf<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> malloc_gc <FONT COLOR="#000000">(</FONT>ln + 1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> free_gc_elim <FONT COLOR="#000000">(</FONT>pf_gc<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#787878">// give the certificate to GC
</FONT>  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> strbuf_initialize_cloptr <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_buf</FONT> <FONT COLOR="#000000">|</FONT> p_buf<FONT COLOR="#000000">,</FONT> ln<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> str[<FONT COLOR="#009000">st + i</FONT><FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  string1_of_strbuf <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_buf</FONT> <FONT COLOR="#000000">|</FONT> p_buf<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [string_make_substring]
</FONT></FONT></PRE>

Note that a linear closure (cloptr) representing
<i>lam (i) => str[st + i]</i> is formed for each call to
<i>strbuf_initialize_cloptr</i> and this closure is freed once the call
returns. The string created by a call to <i>string_make_substring</i> is
persistent, and it can only be freed by GC.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <A HREF="strings.dats">here</A>.

<!-- end of [strings.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!--
The file is automatically generated by [atsdoc] from datatypes.atxt.
-->
<!--
Time of Generation: Wed Aug 31 14:15:32 2011
-->
<!--beg of [datatypes.html]-->

<H2><A id="datatypes" name="datatypes">Datatypes</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of datatypes in ATS is directly adopted from ML. In addition to
what is available in ML, we can also form in ATS dependent datatypes and
guarded recursive datatypes (GRDTs), also known as generalized algebraic
datatypes (GADTs). There is also a form of linear datatypes (dataviewtypes)
available in ATS, which is to be explained elsewhere.

<H4>A Simple Datatype</H4>
In the first example given below, a datatype type <i>intlst0</i>
is declared to represent lists of integers and a function
<i>length_intlst0</i> for computing the length of a given
list is implemented:


<pre class="atsyntax">
<span class="keyword">datatype</span> <span class="staexp"><a name="9"><span class="stacstdec">intlst0</span></a></span> <span class="keyword">=</span> <span class="comment">// simple datatype
</span>  <span class="keyword">|</span> INTLST0nil <span class="comment">// the first bar (|) is optional
</span>  <span class="keyword">|</span> INTLST0cons <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>int<span class="keyword">,</span> intlst0<span class="keyword">)</span></span>

<span class="keyword">fun</span> length_intlst0 <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span> <span class="comment">// [case+] demands exhaustive pattern matching
</span>  <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="keyword">|</span> INTLST0cons <span class="keyword">(</span>_<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> 1 + length_intlst0 <span class="keyword">(</span>xs<span class="keyword">)</span>
  <span class="keyword">|</span> INTLST0nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="comment">// end of [length_intlst0]
</span></pre>
<!--atscode2xmld-->

Please note that any valid identifiers for variables can also be used as
identifiers for constructors. The pattern for a constructor <i>C</i> with
no arguments is <i>C( )</i>. If we write <i>C</i> instead of <i>C( )</i>,
then <i>C</i> is assumed to be a variable pattern, which matches any value.
<P>

<H4>A Dependent Datatype</H4>
In ATS, we can form a dependent datatype <i>intlst1</i> as follows to
represent integer lists:


<pre class="atsyntax">
<span class="keyword">datatype</span> <span class="staexp"><a name="9"><span class="stacstdec">intlst1 <span class="keyword">(</span>int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span> <span class="comment">// dependent datatype
</span>  <span class="keyword">|</span> INTLST1nil <span class="staexp"><span class="keyword">(</span>0<span class="keyword">)</span></span> <span class="comment">// the first bar (|) is optional
</span>  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> INTLST1cons <span class="staexp"><span class="keyword">(</span>n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>int<span class="keyword">,</span> intlst1 n<span class="keyword">)</span></span>
<span class="comment">// end of [intlst1]
</span></pre>


We may see <i>intlst1</i> as a refinement of <i>intlst0</i>.  Given an
integer <i>n</i>, <i>intlst1(n)</i> is a type for integer lists of length
<i>n</i>. The syntax for declaring <i>intlst1</i> introduces
two constructors of the following types:

<pre>
INTLST1nil : intlst1 0
INTLST1cons : {n:nat} (int, intlst1 n) -> intlst (n+1)
</pre>

So <i>INTLST1nil</i> is a list of length <i>0</i> and
<i>INTLST1cons</i> constructs a list of length <i>n+1</i>
if given an integer and an integer list of length <i>n</i>.
<P>

The function for computing the length of a given integer list can now
be implemented as follows:


<pre class="atsyntax">
<span class="keyword">fun</span> length_intlst1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst1 n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int n</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span> <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="comment">// the bar (|) in the first clause is optional
</span>  <span class="keyword">|</span> INTLST1cons <span class="keyword">(</span>_<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> 1 + length_intlst1 <span class="keyword">(</span>xs<span class="keyword">)</span>
  <span class="keyword">|</span> INTLST1nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> 0
<span class="comment">// end of [length_intlst1]
</span></pre>


Note that <i>length_intlst1</i> is assigned the following type:

<pre>
{n:nat} intlst1 n -> int n
</pre>

which clearly indicates that the returned value of a call to
<i>length_intlst1</i> is the length of the argument of the call.
<P>

As another example, the following code implements the list subscripting
function:


<pre class="atsyntax">
<span class="comment">// the index is a natural number less than the size of the indexed length
</span><span class="keyword">fun</span> nth_intlst1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 0 &lt;= i<span class="keyword">;</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">intlst1 n</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span>
  <span class="comment">// [val+] demands exhaustive pattern matching
</span>  <span class="keyword">let</span> <span class="keyword">val+</span> INTLST1cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs <span class="keyword">in</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> nth_intlst1 <span class="keyword">(</span>xs<span class="keyword">,</span> i-1<span class="keyword">)</span> <span class="keyword">else</span> x
  <span class="keyword">end</span> <span class="comment">// end of [let]
</span><span class="comment">// end of [nth_intlst1]
</span></pre>


Note that the pattern matching involved in the value declaration
<i>val+ INTLST1cons (x, xs) = xs</i> is
guaranteed to be exhaustive as <i>n</i> is positive. As a consequence, there
is no tag checking in the C code generated from the compilation of
<i>nth_intlst</i>. This simple example demonstrates that safety can
actually enhance efficiency.

<H4>A Polymorphic Datatype</H4> We can declare a datatype <i>list</i> as follows for
representing polymorphic lists:


<pre class="atsyntax">
<span class="comment">// [t@ype] is a sort for types of unrestricted size
</span><span class="keyword">datatype</span> <span class="staexp"><a name="61"><span class="stacstdec">list <span class="keyword">(</span>a<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span> <span class="comment">// polymorphic datatype
</span>  <span class="keyword">|</span> nil <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> 0<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> cons <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span></span>
</pre>


The syntax used for declaring <i>list</i> introduces
two constructors of the following types:

<pre>
nil : {a:t@ype} list (a, 0)
cons : {a:t@ype} {n:nat} (a, list (a, n)) -> list (a, n+1)
</pre>

We use <i>a:t@ype+</i> (instead of <i>a:t@ype</i>) to indicate that the type
constructor <i>list</i> is covariant at this argument, that is,
<i>list (T1, n)</i> is considered to be a subtype of
<i>list (T2, n)</i> whenever <i>T1</i> is a subtype of <i>T2</i>.
<P>

The function for appending two polymorphic lists can be implemented as
follows:


<pre class="atsyntax">
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
append_list <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> m<span class="keyword">)</span></span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> m+n<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case+</span> xs <span class="keyword">of</span>
  <span class="keyword">|</span> cons <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span>x<span class="keyword">,</span> append_list <span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys
<span class="comment">// end of [append_list]
</span></pre>


This function definition is a template. It can be typechecked but cannot be
compiled until the type variable <i>a</i> is instantiated with a type of
known size. The feature of templates in ATS is to be explained elsewhere.
<P>

As another example, the following code implements a (template) function
that zips together two given lists of the same length:


<pre class="atsyntax">
<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a1<span class="keyword">,</span>a2<span class="keyword">:</span>t@ype</span><span class="keyword">}</span>
zip_list <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a1<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a2<span class="keyword">,</span> n<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span><span class="keyword">'(</span>a1<span class="keyword">,</span> a2<span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>cons <span class="keyword">(</span>x1<span class="keyword">,</span> xs1<span class="keyword">)</span><span class="keyword">,</span> cons <span class="keyword">(</span>x2<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> cons <span class="keyword">(</span><span class="keyword">'(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span><span class="keyword">,</span> zip_list <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> nil <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=/=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// none of these cases can occur
</span><span class="comment">// end of [zip_list]
</span></pre>


Note that the last clause in the definition of <i>zip_list</i> is presented
only for the purpose of illustration, and it can simply be omitted.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="datatypes.dats">here</a>.

<!-- end of [datatypes.html] -->



<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!--
The file is automatically generated by [atsdoc] from datatypes.atxt.
-->
<!--
Time of Generation: Wed Aug 31 14:15:37 2011
-->
<!--beg of [dataprops.html]-->

<H2><A id="dataprops" name="dataprops">Dataprops</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A prop is similar to a type. If a prop is assigned to a dynamic term, then
the term is guaranteed to be pure and total, that is, the evaluation of the
term generates no effects and always terminates. We refer to dynamic terms
classified by props as proof terms, or simply proofs. 

Dataprops are often declared for encoding recursively defined relations.
For instance, multiplication on integers can be defined as follows in
terms of integer addition:

<CENTER>
<TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2>

<TR>
  <TD ALIGN=RIGHT></TD>
  <TD ALIGN=CENTER></TD>
  <TD ALIGN=LEFT></TD>
  <TD ALIGN=LEFT></TD>
</TR>

<TR>
  <TD><i>0 * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>0</i></TD>
  <TD></TD>
<TR>

<TR>
  <TD><i>(m+1) * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>m * n + n</i></TD>
  <TD>; if <i>m >= 0 </i></TD>
<TR>

<TR>
  <TD><i>m * n</i>
  <TD><i>&nbsp;=&nbsp;</i><TD>
  <TD><i>-(-m * n)</i></TD>
  <TD>; if <i>m < 0 </i></TD>
<TR>

</TABLE>
</CENTER>
<P>

Let <i>MUL(m, n, p)</i> be a relation on integers such that
<i>MUL(m, n, p)</i> holds if and only if <i>m * n = p</i>.
Then this relation can be encoded by the followng dataprop:


<pre class="atsyntax">
<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><a name="9"><span class="stacstdec">MUL <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span></span></a></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">}</span> MULbas <span class="staexp"><span class="keyword">(</span>0<span class="keyword">,</span> n<span class="keyword">,</span> 0<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">m &gt;= 0</span><span class="keyword">}</span> MULind <span class="staexp"><span class="keyword">(</span>m+1<span class="keyword">,</span> n<span class="keyword">,</span> p+n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>n<span class="keyword">,</span>p<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">m <span class="keyword">&gt;</span> 0</span><span class="keyword">}</span> MULneg <span class="staexp"><span class="keyword">(</span><span class="keyword">~</span>m<span class="keyword">,</span> n<span class="keyword">,</span> <span class="keyword">~</span>p<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span></span>
<span class="comment">// end of [MUL]
</span></pre>


<I>Proposition (Totality)
For each pair of integers <i>m</i> and <i>n</i>, there exists an
integer <i>p</i> such that <i>m * n = p</i> holds.
</I>
<P>

This proposition can be encoded as the following prop in ATS:

<pre>
{m,n:int} () -< prf > [p:int] MUL (m, n, p)
</pre>

which is assigned to the function <i>MULprop_total</i> defined below:


<pre class="atsyntax">
<span class="keyword">prfun</span> <span class="prfexp">MULprop_total
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">.&lt;</span> max<span class="keyword">(</span>2*m<span class="keyword">,</span>~2*m+1<span class="keyword">)</span> <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int<span class="keyword">]</span> MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">m <span class="keyword">&gt;</span> 0</span> <span class="keyword">then</span> MULind <span class="keyword">(</span>MULprop_total <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">sif</span> <span class="staexp">m <span class="keyword">&lt;</span> 0</span> <span class="keyword">then</span> MULneg <span class="keyword">(</span>MULprop_total <span class="staexp"><span class="keyword">{</span><span class="keyword">~</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">else</span> MULbas <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [MULprop_total]
</span></pre>


Note that we use <i>sif</i> for constructing a static conditional in which
the condition is a static proposition, that is, a static term of sort
<i>bool</i>. The conditions for the two occurrences of <i>sif</i> are
<i>m > 0</i> and <i>m < 0</i>, which are both static propositions.
<P>
Given that the prop <i>{m,n:int} () -< prf > [p:int] MUL (m, n, p)</i>
is inhabited, we know that the proposition it encodes must hold.
<P>

<I>Proposition (Uniqueness)
Given integers <i>m,n,p1,p2</i> such that
<i>m * n = p1</i> and <i>m * n = p2</i>, then
<i>p1 = p2</i> holds.
</I>
<P>

This proposition can be encoded as the following prop in ATS:

<pre>
{m,n,p1,p2:int} (MUL (m, n, p1), MUL (m, n, p2)) -< prf > [p1 == p2] void
</pre>

which is assigned to the function <i>MULprop_unique</i> defined below:


<pre class="atsyntax">
<span class="keyword">prfun</span> <span class="prfexp">MULprop_unique
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">,</span>p1<span class="keyword">,</span>p2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span> max<span class="keyword">(</span>2*m<span class="keyword">,</span> ~2*m+1<span class="keyword">)</span> <span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p1<span class="keyword">)</span></span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">MUL <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> p2<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p1 == p2<span class="keyword">]</span> void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> MULbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULind pf1<span class="keyword">,</span> MULind pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULprop_unique <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
    <span class="keyword">|</span> <span class="keyword">(</span>MULneg pf1<span class="keyword">,</span> MULneg pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> MULprop_unique <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span></span>
<span class="comment">// end of [MULprop_unique]
</span></pre>


Therefore, the prop is inhabited and thus the proposition it
encodes must hold.

<P>

The distributivity (over addition), commutativity and associativity of
multiplication can all be esstablished similarly.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="dataprops.dats">here</a>.

<!--end of [dataprops.html]-->



<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [dataviews.html] -->

<H2><A id="dataviews" name="dataviews">Dataviews</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A view is a linear prop, where the meaning of the word
<i>linear</i> is in the sense of linear logic. Dataviews are often declared
to encode recursively defined relations on linear resources.  As an
example, we declare a dataview as follows to describe and then reason about
the probably most common data structure in use: arrays.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">dataview</FONT> <FONT COLOR="#009000"><FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT> viewt@ype+<FONT COLOR="#000000">,</FONT> int<FONT COLOR="#000000">,</FONT> addr<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">l<FONT COLOR="#000000">:</FONT>addr</FONT><FONT COLOR="#000000">}</FONT> array_v_none <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">n<FONT COLOR="#000000">:</FONT>nat</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">l<FONT COLOR="#000000">:</FONT>addr</FONT><FONT COLOR="#000000">}</FONT> array_v_some <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n+1<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a @ l<FONT COLOR="#000000">,</FONT> array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l+sizeof a<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT></FONT>
</FONT></PRE>

The syntax introduces a view constructor <i>array_v</i> and two
proof constructors <i>array_v_none</i> and <i>array_v_some</i>
associated with <i>array_v</i>, which are assigned the following
props:

<pre>
<FONT COLOR="#009000">array_v_none <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT></FONT>
<FONT COLOR="#009000">array_v_some <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT>a @ l<FONT COLOR="#000000">,</FONT> array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l+sizeof a<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> array_v_some <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n+1<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT></FONT>
</pre>

Given a viewtype <i>VT</i>, an integer <i>I</i> and an address <i>L</i>,
the view <i>array_v(VT, I, L)</i> indicates that an array of size <i>I</i>
is located at the address <i>L</i> and each element in the array is of
viewtype <i>VT</i>.
<P>
The prop assigned to <i>array_v_none</i> indicates that we can assume an
array of size <i>0</i> located at any given address, while the prop
assigned to <i>array_v_some</i> states that an array of <i>I+1</i>
elements of viewtype <i>VT</i> is located at some address <i>L</i>
if an element of viewtype <i>VT</i> is located at <i>L</i>
and also an array of <i>I</i> elements of viewtype <i>VT</i> is located
at <i>L+sizeof(VT)</i>, where <i>sizeof(VT)</i> is the size of
<i>VT</i>, or more precisely, the size of an element of viewtype
<i>VT</i>.
<P>

Let us establish some propoerties on arrays.  The following proof function
<i>array_v_split</i> shows that an array of size <i>N</i> can be decomposed
into two adjacently located arrays of sizes <i>I</i> and <i>N - I</i>,
respectively, where <i>I</i> can be any natural number satisfying <i>I <=
N</i>.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">(*
 * array_v_split
 *   {a:viewt@ype} {n,i:nat | i &lt;= n} {l:addr} {off: int} .&lt;i&gt;.
 *   (pf_arr: array_v (a, n, l), pf_mul: MUL (i, sizeof a, off))
 *   : (array_v (a, i, l), array_v (a, n-i, l+off))
 *)</FONT>

<FONT COLOR="#000000">prfun</FONT> <FONT COLOR="#009000">array_v_split
  <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i &lt;= n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>off<FONT COLOR="#000000">:</FONT> int<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>i<FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">MUL <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> sizeof a<FONT COLOR="#000000">,</FONT> off<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n-i<FONT COLOR="#000000">,</FONT> l+off<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#009000"><FONT COLOR="#000000">sif</FONT> <FONT COLOR="#0000FF">i <FONT COLOR="#000000">&gt;</FONT> 0</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_arr</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULind pf_mul <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf_arr1<FONT COLOR="#000000">,</FONT> pf_arr2<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_split <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT>array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr1<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> pf_arr2<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT>array_v_none <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT></FONT></FONT>
</FONT></PRE>

The next proof function <i>array_v_unsplit</i> is the
inverse of <i>array_v_split</i>: It states that two adjacently
located arrays of sizes <i>N_1</i> and <i>N_2</i> can be
combined into a single array of sizes <i>N_1+N_2</i>.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">(*
 * array_v_unsplit
 *   {a:viewt@ype} {n1,n2:nat} {l:addr} {off: int} .&lt;n1&gt;.
 *   (pf_arr1: array_v (a, n1, l),
 *    pf_arr2: array_v (a, n2, l+off),
 *    pf_mul: MUL (n1, sizeof a, off))
 *   : array_v (a, n1+n2, l)
 *)</FONT>

<FONT COLOR="#000000">prfun</FONT> <FONT COLOR="#009000">array_v_unsplit
  <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n1<FONT COLOR="#000000">,</FONT>n2<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>off<FONT COLOR="#000000">:</FONT> int<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>n1<FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>pf_arr1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n1<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> pf_arr2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n2<FONT COLOR="#000000">,</FONT> l+off<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">MUL <FONT COLOR="#000000">(</FONT>n1<FONT COLOR="#000000">,</FONT> sizeof a<FONT COLOR="#000000">,</FONT> off<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n1+n2<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#009000"><FONT COLOR="#000000">sif</FONT> <FONT COLOR="#0000FF">n1 <FONT COLOR="#000000">&gt;</FONT> 0</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_arr1</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULind pf_mul <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_arr <FONT COLOR="#000000">=</FONT> array_v_unsplit <FONT COLOR="#000000">(</FONT>pf_arr1<FONT COLOR="#000000">,</FONT> pf_arr2<FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">in</FONT>
    array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">array_v_none <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_arr1</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
  <FONT COLOR="#000000">in</FONT>
    pf_arr2
  <FONT COLOR="#000000">end</FONT></FONT></FONT>
</FONT></PRE>

The following proof function states that given an array of size
<i>N</i> and a natural number <i>I</i> satisfying <i>I < N</i>,
the element indexed by <i>I</i> can be taken out of the array,
leaving the array with a hole inside.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">(*
 * array_v_takeout
 *   {n,i:nat | i &lt; n} {l:addr} {off: int}
 *   (pf_arr: array_v (a, n, l), pf_mul: MUL (i, sizeof a, off))
 *   : (a @ (l+off), a @ (l+off) -&lt;lin&gt; array_v (a, n, l))
 *)</FONT>

<FONT COLOR="#000000">prfun</FONT> <FONT COLOR="#009000">array_v_takeout
  <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>off<FONT COLOR="#000000">:</FONT> int<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT>i<FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">MUL <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> sizeof a<FONT COLOR="#000000">,</FONT> off<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a @ <FONT COLOR="#000000">(</FONT>l+off<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> a @ <FONT COLOR="#000000">(</FONT>l+off<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>lin<FONT COLOR="#000000">&gt;</FONT> array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#009000"><FONT COLOR="#000000">sif</FONT> <FONT COLOR="#0000FF">i <FONT COLOR="#000000">&gt;</FONT> 0</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_arr</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULind pf_mul <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf_out<FONT COLOR="#000000">,</FONT> pf_rst<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_takeout <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT>pf_out<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">llam</FONT> pf_out <FONT COLOR="#000000">=&gt;</FONT> array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_rst pf_out<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> pf_mul</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT>  <FONT COLOR="#000000">=</FONT> pf_arr</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">llam</FONT> pf_at <FONT COLOR="#000000">=&gt;</FONT> array_v_some <FONT COLOR="#000000">(</FONT>pf_at<FONT COLOR="#000000">,</FONT> pf_arr<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT></FONT></FONT>
</FONT></PRE>

The following code shows how the proof function
<i>array_v_takeout</i> can be used to implement functions
for accessing and updating arrays.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#787878">// a template function for read through a pointer
</FONT><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> ptr_get <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a @ l</FONT></FONT> <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a @ l <FONT COLOR="#000000">|</FONT> a<FONT COLOR="#000000">)</FONT></FONT>

<FONT COLOR="#000000">extern</FONT> <FONT COLOR="#787878">// a template function for write through a pointer
</FONT><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> ptr_set <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a @ l</FONT></FONT> <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a @ l <FONT COLOR="#000000">|</FONT> void<FONT COLOR="#000000">)</FONT></FONT>

<FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// a template function for array read
</FONT>  array_ptr_get_at <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT></FONT> <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t i</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> a<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mul</FONT> <FONT COLOR="#000000">|</FONT> off<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> mul2_size1_size1 <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> sizeof&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT><FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf_elt<FONT COLOR="#000000">,</FONT> pf_rst<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_takeout <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_elt</FONT> <FONT COLOR="#000000">|</FONT> x<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> ptr_get&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_elt</FONT> <FONT COLOR="#000000">|</FONT> p + off<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_rst pf_elt</FONT> <FONT COLOR="#000000">|</FONT> x<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>

<FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// a template function for array write
</FONT>  array_ptr_set_at <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">,</FONT>i<FONT COLOR="#000000">:</FONT>nat <FONT COLOR="#000000">|</FONT> i <FONT COLOR="#000000">&lt;</FONT> n<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_arr<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT></FONT></FONT> <FONT COLOR="#000000">|</FONT> p<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l</FONT><FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">size_t i</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>array_v <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> void<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mul</FONT> <FONT COLOR="#000000">|</FONT> off<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> mul2_size1_size1 <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">,</FONT> sizeof&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT><FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT>pf_elt<FONT COLOR="#000000">,</FONT> pf_rst<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> array_v_takeout <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>pf_arr<FONT COLOR="#000000">,</FONT> pf_mul<FONT COLOR="#000000">)</FONT></FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_elt</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> ptr_set&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_elt</FONT> <FONT COLOR="#000000">|</FONT> p + off<FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_rst pf_elt</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

Note that the code here is primarily for the purpose of illustration. In
practice, array access and update functions in ATS/Anairiats are implemented
as primtives for the sake of efficiency.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="dataviews.dats">here</a>.

<!-- end of [dataviews.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [dataviewtypes.html] -->

<H2><A id="dataviewtypes" name="dataviewtypes">Dataviewtypes</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of dataviewtype in ATS is an advanced one.
<P>
A viewtype is just a linear type. The name <i>viewtype</i> is chosen as a
viewtype often consists of a view and a type. A dataviewtype is similar to
a datatype, but it is linear.  With a dataviewtype, the programmer is
allowed to explicitly free (or deallocate) in a safe manner the memory used
for storing constructors associated with the dataviewtype. This is
particularly important in a situation where garbage collection needs to be
significantly reduced or even completely avoided.
<P>

An an example, the following dataviewtype
<i>list_vt</i> is declared to model singly-linked lists in ATS:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [list_vt] is declared to model singly-linked lists
</FONT><FONT COLOR="#000000">dataviewtype</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype+<FONT COLOR="#000000">,</FONT> int<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">|</FONT> list_vt_nil <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">n<FONT COLOR="#000000">:</FONT>nat</FONT><FONT COLOR="#000000">}</FONT> list_vt_cons <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n+1<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT></FONT></PRE>

Given a viewtype <i>VT</i> and an integer <i>I</i>, the viewtype
<i>list_vt(VT, I)</i> is for singly-linked lists of length <i>I</i> in
which each element is of viewtype <i>VT</i>. Let us define
<i>List_vt</i> as follows:

<PRE>
<FONT COLOR="#000000">viewtypedef</FONT> <FONT COLOR="#0000FF">List_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">]</FONT> list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT>
</PRE>

Then roughly speaking, the viewtype <i>List_vt(VT)</i> corresponds to the
following struct type in C:

<pre>
typedef struct sllist_struct {
  VT head ;
  sllist_struct *tail ;
} *sllist ;
</pre>
where <i>VT</i> refers to some type in C.
<P>
We now assume that <i>nil</i> and <i>cons</i> have been introduced as
shorthands for <i>list_vt_nil</i> and <i>list_vt_cons</i>, respectively.

<H4>Computing the length of a singly-linked list</H4>
The following code implements a function that computes the length
of a given linked-list in ATS:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// An implementation of the length function on singly-linked lists
</FONT><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT>
  list_vt_length <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>xs0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>i<FONT COLOR="#000000">,</FONT>j<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> i <FONT COLOR="#000000">&gt;.</FONT></FONT>
    <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">!</FONT>list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> i<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> j<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int j</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int <FONT COLOR="#000000">(</FONT>i+j<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
    <FONT COLOR="#000000">|</FONT> cons <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">begin</FONT>
        <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> n <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">,</FONT> j+1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> fold@ xs<FONT COLOR="#000000">;</FONT> n <FONT COLOR="#000000">end</FONT>
      <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">|</FONT> nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">(</FONT>fold@ xs<FONT COLOR="#000000">;</FONT> j<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  loop <FONT COLOR="#000000">(</FONT>xs0<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [list_vt_length]
</FONT></FONT></PRE>

The function <i>list_vt_length</i> approximately corresponds to the
following function <i>sllist_length</i> implemented in C:

<pre>
int sllist_length (sllist xs) {
  int i = 0 ;
  while (xs != NULL) { i += 1 ; xs = xs->tail ; }
  return i ;
}
</pre>

<H4>Appending two singly-linked lists</H4>

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// An implementation of the append function on singly-linked lists
</FONT><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT> list_vt_append <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>xs0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> m<FONT COLOR="#000000">)</FONT> &gt;&gt; list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> m+n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#000000">(</FONT>xs0<FONT COLOR="#000000">:</FONT> list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> m+n<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> xs0 <FONT COLOR="#000000">of</FONT>
  <FONT COLOR="#000000">|</FONT> cons <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_xs<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">(</FONT>list_vt_append <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> fold@ xs0<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">~</FONT>nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">(</FONT>xs0 := ys<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#787878">// end of [list_vt_append]
</FONT></FONT></PRE>

The function <i>list_vt_append</i> approximately corresponds to the
following function <i>sllist_append</i> implemented in C:

<PRE>
void sllist_append (sllist *p_xs, sllist ys) {
  sllist xs ;
  xs = *p_xs ;
  while (xs != NULL) { p_xs = &xs->tail ; xs = *p_xs ; }
  *p_xs = ys ;
  return ;
} /* end of [sllist_append] */
</PRE>

<H4>Reversing a singly-linked lists</H4>

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// An implementation of the reverse function on singly-linked lists
</FONT><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT> list_vt_reverse <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">&amp;</FONT>list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fun</FONT> revapp <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>m<FONT COLOR="#000000">,</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> m <FONT COLOR="#000000">&gt;.</FONT></FONT>
    <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> m<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> m+n<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
    <FONT COLOR="#000000">|</FONT> cons <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">begin</FONT>
        <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> xs1 <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p_xs1 <FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">!</FONT>p_xs1 := ys<FONT COLOR="#000000">;</FONT> fold@ xs<FONT COLOR="#000000">;</FONT> revapp <FONT COLOR="#000000">(</FONT>xs1<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
      <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">~</FONT>nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> ys
<FONT COLOR="#000000">in</FONT>
  xs := revapp <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>    
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [list_vt_reverse]
</FONT></FONT></PRE>

The function <i>list_vt_reverse</i> approximately corresponds to the
following function <i>sllist_reverse</i> implemented in C:

<PRE>
void sllist_reverse (sllist *p_xs) {
  sllist xs, ys, *p_xs1, xs1 ;
  xs = !p_xs ; ys = NULL ;
  while (xs != NULL) {
    p_xs1 = &xs->tail ; xs1 = *p_xs1 ; *p_xs1 = ys ; ys = xs ; xs = xs1
  }
  *p_xs = xs ;
  return ;
} /* end of [sllist_reverse] */
</PRE>

<H4>Sorting a singly-linked list</H4>

The following code implements quicksort on a singly-linked list in
ATS. Note that there is no memory allocation/deallocation, either implicit
or explict, involved in this code.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// An implementation of quicksort on singly-linked lists
</FONT><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>viewt@ype</FONT><FONT COLOR="#000000">}</FONT>
  list_vt_qsort <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> n<FONT COLOR="#000000">,</FONT> 0 <FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>lte<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>a<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>a<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> bool</FONT><FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
  <FONT COLOR="#000000">|</FONT> cons <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_x1<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT>
    <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> xs1 <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p_xs1 <FONT COLOR="#000000">in</FONT>
      list_vt_par&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>
        <FONT COLOR="#009000">view@ <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_x1<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">view@ <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">|</FONT> lte<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">,</FONT> p_xs1<FONT COLOR="#000000">,</FONT> p_x1<FONT COLOR="#000000">,</FONT> xs1<FONT COLOR="#000000">,</FONT> nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">|</FONT> nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">(</FONT>fold@ xs<FONT COLOR="#000000">;</FONT> xs<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#787878">// end of [list_vt_qsort]
</FONT>
<FONT COLOR="#000000">and</FONT> <FONT COLOR="#787878">// [list_vt_par] for partition
</FONT>  list_vt_par <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>l0<FONT COLOR="#000000">,</FONT>l1<FONT COLOR="#000000">:</FONT>addr<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>p<FONT COLOR="#000000">,</FONT>q<FONT COLOR="#000000">,</FONT>r<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> p+q+r<FONT COLOR="#000000">,</FONT> p+1 <FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a @ l0</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">List_vt a? @ l1</FONT></FONT> <FONT COLOR="#000000">|</FONT>
   lte<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>a<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>a<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> bool</FONT><FONT COLOR="#000000">,</FONT>
   node<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt_cons_unfold <FONT COLOR="#000000">(</FONT>l0<FONT COLOR="#000000">,</FONT> l1<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> node1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l1</FONT><FONT COLOR="#000000">,</FONT>
   p_x0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">ptr l0</FONT><FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> p<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> q<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list_vt <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> p+q+r+1<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
  <FONT COLOR="#000000">|</FONT> cons <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_x1<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_xs1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">val</FONT> xs1 <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>p_xs1
    <FONT COLOR="#000000">in</FONT>
      <FONT COLOR="#000000">if</FONT> lte <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>p_x1<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">!</FONT>p_x0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">begin</FONT>
        <FONT COLOR="#000000">!</FONT>p_xs1 := l<FONT COLOR="#000000">;</FONT> fold@ xs<FONT COLOR="#000000">;</FONT>
        list_vt_par&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf0</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf1</FONT> <FONT COLOR="#000000">|</FONT> lte<FONT COLOR="#000000">,</FONT> node<FONT COLOR="#000000">,</FONT> node1<FONT COLOR="#000000">,</FONT> p_x0<FONT COLOR="#000000">,</FONT> xs1<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
        <FONT COLOR="#000000">!</FONT>p_xs1 := r<FONT COLOR="#000000">;</FONT> fold@ xs<FONT COLOR="#000000">;</FONT>
        list_vt_par&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf0</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf1</FONT> <FONT COLOR="#000000">|</FONT> lte<FONT COLOR="#000000">,</FONT> node<FONT COLOR="#000000">,</FONT> node1<FONT COLOR="#000000">,</FONT> p_x0<FONT COLOR="#000000">,</FONT> xs1<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT>    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [cons]
</FONT>  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">~</FONT>nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">let</FONT>
      <FONT COLOR="#000000">var</FONT> l <FONT COLOR="#000000">=</FONT> list_vt_qsort&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>lte<FONT COLOR="#000000">,</FONT> l<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">and</FONT> r <FONT COLOR="#000000">=</FONT> list_vt_qsort&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>lte<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">in</FONT>
      <FONT COLOR="#000000">!</FONT>node1 := r<FONT COLOR="#000000">;</FONT> fold@ node<FONT COLOR="#000000">;</FONT> r := node<FONT COLOR="#000000">;</FONT> list_vt_append&lt;<FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>l<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> l
    <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [nil]
</FONT><FONT COLOR="#787878">// end of [list_vt_par]
</FONT></FONT></PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="dataviewtypes.dats">here</a>.

<!-- end of [dataviewtypes.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [pattern-matching.html] -->

<H2><A id="pattern-matching" name="pattern-matching">Pattern
Matching</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of pattern matching in ATS is adopted from ML. However, this
feature becomes much more elaborated in the presence of dependent types as
well as linear types. We present as follows several examples to illustrate
some typical uses of pattern matching in ATS.
<P>
Let us first declare a polymorphic datatype <i>list0</i> as follows
for representing lists:
<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">datatype</FONT> <FONT COLOR="#0000FF">list0 <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>t@ype<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT> nil0 <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">|</FONT> cons0 <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> list0 a<FONT COLOR="#000000">)</FONT></FONT>
</FONT></PRE>

Notice that this is not a dependent datatype. Suppose we need to implement
a function <i>zip0</i> that should only zip together two lists of <em>the
same length</em>. This may be done as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a1<FONT COLOR="#000000">,</FONT>a2<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// [zip0] is a template
</FONT>zip0 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 a1</FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 a2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 <FONT COLOR="#000000">'(</FONT>a1<FONT COLOR="#000000">,</FONT> a2<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#787878">// [case+] indicates the exhaustiveness of pattern matching
</FONT>  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>cons0 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> cons0 <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> cons0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> zip0 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
</FONT></PRE>

The problem with this implementation is that a pattern matching failure
occurs if the function <i>zip0</i> is mistakenly applied to two lists of
unequal length, resulting in a run-time exception. In practice, a special
exception is often declared as follows to handle the case of pattern
matching failure, enabling more accurate run-time information to be
reported.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">exception</FONT> ZipException

<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a1<FONT COLOR="#000000">,</FONT>a2<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// [zip0] is a template
</FONT>zip0 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 a1</FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 a2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list0 <FONT COLOR="#000000">'(</FONT>a1<FONT COLOR="#000000">,</FONT> a2<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#787878">// [case+] indicates the exhaustiveness of pattern matching
</FONT>  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>cons0 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> cons0 <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> cons0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> zip0 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> nil0 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> _<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">$raise</FONT> ZipException
</FONT></PRE>

We can also declare a polymorphic dependent datatype <i>list1</i> as
follows for representing lists:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">datatype</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>t@ype<FONT COLOR="#000000">,</FONT> int<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">|</FONT> nil1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">n<FONT COLOR="#000000">:</FONT>nat</FONT><FONT COLOR="#000000">}</FONT> cons1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n+1<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> list1 <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT>
</FONT></PRE>

Given a type <i>T</i> and an integer <i>I</i>, the type
<i>list1(T, I)</i> is for lists of length <i>I</i> in which each element is
of type <i>T</i>. The function for zipping two lists of the same length can
now be implemented as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a1<FONT COLOR="#000000">,</FONT>a2<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// [zip1] is a template
</FONT>zip1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a1<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a2<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>a1<FONT COLOR="#000000">,</FONT> a2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#787878">// [case+] indicates the exhaustiveness of pattern matching
</FONT>  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>cons1 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> cons1 <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> cons1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> zip1 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
</FONT></PRE>

Note that the typechecker can verify that pattern matching in this
implementation is exhaustive.
<P>

Given that pattern matching in ATS is done sequentially, that is, from left
to right in a given row and from top to bottom for all the clauses in a
given case-expression, it is natural to expect that the following code
gives an equivalent implementation of <i>zip1</i>:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a1<FONT COLOR="#000000">,</FONT>a2<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT>
zip1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a1<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a2<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>a1<FONT COLOR="#000000">,</FONT> a2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">case+</FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#787878">// [case+] indicates the exhaustiveness of pattern matching
</FONT>  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>cons1 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> cons1 <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> cons1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> zip1 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> _<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT></PRE>

This, however, is not the case as typechecking in ATS does not assume the
sequentiality of pattern matching. In this example, the second pattern
matching clause is typechecked indepenent of the first one, resulting in a
type error. In order to demand that the second clause be typechecked under
the assumption that the first clause is not chosen at run-time, the
following special syntax is needed:

<PRE><FONT COLOR="#E80000">    <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">(</FONT>_<FONT COLOR="#000000">,</FONT> _<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;&gt;</FONT> nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT></PRE>

The special arrow <i>=&gt;&gt;</i> indicates that a clause formed with this
arrow needs to be typechecked under the assumption that all of the previous
clauses (in the same case-expression) are not chosen at run-time.
<P>

In the C code generated from compiling the function <i>zip1</i>, there are
two tag checkes: they check whether the first and the second arguments of
<i>zip1</i> are empty. Clearly, only one tag check is necessary as both
arguments are of the same length. We can modify the implementation of
<i>zip1</i> as follows so as to use only one check:

<PRE><FONT COLOR="#E80000">
<FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a1<FONT COLOR="#000000">,</FONT>a2<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#787878">// only one tag check
</FONT>zip1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a1<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT>a2<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">list1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>a1<FONT COLOR="#000000">,</FONT> a2<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT> <FONT COLOR="#000000">case+</FONT> xs <FONT COLOR="#000000">of</FONT>
  <FONT COLOR="#000000">|</FONT> cons1 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> xs<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">begin</FONT>
      <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val+</FONT> cons1 <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> ys <FONT COLOR="#000000">in</FONT> cons1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">'(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> zip1 <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> ys<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">|</FONT> _ <FONT COLOR="#000000">=&gt;&gt;</FONT> nil1 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [zip1]
</FONT>
</FONT></PRE>

Note that the keyword <i>val+</i> indicates that the patthern matching
following it is exhaustive and thus needs no tag check.  This simple
example demonstrates in concrete terms that safety can enhance efficiency.

<HR SIZE=1 ALIGN=LEFT><P>

The code used for illustration is available <a href="pattern-matching.dats">here</a>.

<!-- end of [pattern-matching.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [exception.html] -->

<H2><A id="exceptions" name="exceptions">Exceptions</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Exceptions can provide a convenient approach to handling abnormal or
erroneous cases. This convenience, however, is not without a cost as
programs making use of exceptions can often become rather difficult to
reason about.
<P>

In ATS, the type for exceptions is denoted by <i>exn</i>, which actually is
a viewtype of the sort <i>viewtype</i>. So the size of
<i>exn</i> equals the size of a pointer. The type <i>exn</i> may be thought
of as a dataviewtype (i.e., linear datatype) with which an extensible set
of constructors are associated.  The syntax for declaring an exception is
rather similar to that for declaring a constructor (associated with a
datatype). For instance, three exceptions (or more precisely, exception
constructors) are declared as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">exception</FONT> Fail <FONT COLOR="#787878">// Fail: exn
</FONT><FONT COLOR="#000000">exception</FONT> Fail_msg <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF">string</FONT> <FONT COLOR="#787878">// Fail_msg: string -&gt; exn
</FONT>
<FONT COLOR="#787878">// Fail_msgs : {n:nat} (int n, list (string n)) -&gt; exn
</FONT><FONT COLOR="#000000">exception</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">n<FONT COLOR="#000000">:</FONT>nat</FONT><FONT COLOR="#000000">}</FONT> Fail_msgs <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>int n<FONT COLOR="#000000">,</FONT> list <FONT COLOR="#000000">(</FONT>string<FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT>
</FONT></PRE>

All exceptions in ATS are static and there is no issue of exceptions being
generative as is in Standard ML. It is allowed that an exception be
declared in a closed scope so that the declared exception becomes
inaccessible outside the closed scope. This is analogous to declaring a
static variable inside the body of a function in C.
<P>

We present as follows an example that involves an exception being raised
and then captured.  A binary tree is a Braun tree if it is empty or it
satisfies the property that its left and right children are Braun trees and
the size of the left child minus the size of the right child equals 0 or 1.
The following code implements a function that checks whether a binary tree
is a Braun tree:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">datatype</FONT> <FONT COLOR="#0000FF">bt</FONT> <FONT COLOR="#000000">=</FONT> E <FONT COLOR="#000000">|</FONT> B <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>bt<FONT COLOR="#000000">,</FONT> bt<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#787878">// datatype for binary trees
</FONT>
<FONT COLOR="#000000">fn</FONT> isBraunTree <FONT COLOR="#000000">(</FONT>bt0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">bt</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">bool</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">exception</FONT> NotBraunTree
  <FONT COLOR="#000000">fun</FONT> aux <FONT COLOR="#000000">(</FONT>bt<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">bt</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">case+</FONT> bt <FONT COLOR="#000000">of</FONT>
    <FONT COLOR="#000000">|</FONT> B <FONT COLOR="#000000">(</FONT>bt1<FONT COLOR="#000000">,</FONT> bt2<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">val</FONT> ls <FONT COLOR="#000000">=</FONT> aux bt1 <FONT COLOR="#000000">and</FONT> rs <FONT COLOR="#000000">=</FONT> aux bt2
      <FONT COLOR="#000000">in</FONT>
        <FONT COLOR="#000000">if</FONT> <FONT COLOR="#000000">(</FONT>ls &gt;= rs &amp;&amp; rs+1 &gt;= ls<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">then</FONT> ls+rs+1 <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">$raise</FONT> NotBraunTree<FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">|</FONT> E <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> 0
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">try</FONT> <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> s <FONT COLOR="#000000">=</FONT> aux bt0 <FONT COLOR="#000000">in</FONT> true <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">with</FONT> <FONT COLOR="#000000">~</FONT>NotBraunTree<FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> false
<FONT COLOR="#000000">end</FONT>
</FONT></PRE>

The type of an exception constructor cannot contain free static variables.
In other words, each exception constructor can be lifted to the toplevel.
For instance, the following code is illegal: the exception constructor
<i>Foo</i> cannot be lifted to the toplevel as its type contains a free type
variable.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> f <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">exception</FONT> Foo <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF">a</FONT> <FONT COLOR="#787878">// Foo: a -&gt; exn
</FONT><FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#787878">// ...
</FONT><FONT COLOR="#000000">end</FONT>
</FONT></PRE>

Sometimes, we may want to raise an exception carrying a value of some
variable type.  This is shown, for instance, in the following illegal code
that tries to implement the list subscripting function:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT>
  list_iforeach <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">List a</FONT><FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>Nat<FONT COLOR="#000000">,</FONT> a<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&gt;</FONT> void</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT>

<FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> nth <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">List a</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">exception</FONT> Found <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF">a</FONT>
  <FONT COLOR="#000000">fn</FONT> f <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">=</FONT> n <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">$raise</FONT> <FONT COLOR="#000000">(</FONT>Found x<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">try</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> list_iforeach <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">$raise</FONT> ListSubscriptException <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">with</FONT>
    <FONT COLOR="#000000">~</FONT>Found x <FONT COLOR="#000000">=&gt;</FONT> x
  <FONT COLOR="#787878">// end of [try]
</FONT><FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [nth]
</FONT></FONT></PRE>

A method to work around the issue is shown in the following code:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fn</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> nth <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">List a</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">exception</FONT> Found <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">val</FONT> ans <FONT COLOR="#000000">=</FONT> ref_make_elt&lt;<FONT COLOR="#0000FF">Option a</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>None<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">fn</FONT> f <FONT COLOR="#000000">(</FONT>i<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">a</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> i <FONT COLOR="#000000">=</FONT> n <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">!</FONT>ans := Some x<FONT COLOR="#000000">;</FONT> <FONT COLOR="#000000">$raise</FONT> Found <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">try</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> list_iforeach <FONT COLOR="#000000">(</FONT>xs<FONT COLOR="#000000">,</FONT> f<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">$raise</FONT> ListSubscriptException <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">with</FONT>
    <FONT COLOR="#000000">~</FONT>Found <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#787878">// end of [try]
</FONT><FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">case</FONT> <FONT COLOR="#000000">!</FONT>ans <FONT COLOR="#000000">of</FONT>
  <FONT COLOR="#000000">|</FONT> Some x <FONT COLOR="#000000">=&gt;</FONT> x <FONT COLOR="#000000">|</FONT> None <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> <FONT COLOR="#000000">$raise</FONT> ListSubscriptException <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [nth]
</FONT></FONT></PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="exceptions.dats">here</a>.

<!-- end of [exception.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<HTML>
<BODY text="#000000" bgcolor="#ffffff" link="#0000FF" vlink="#CC00CC" alink="#ff0000">

<H2>Higher-Order Functions</H2>

<HR SIZE=1 ALIGN=LEFT><P>

The core of ATS is a functional language in which functions are first-class
values. A higher-order function is a function whose arguments also include
functions.
<P>
Let us use <i>BT</i> to range over base types such as
<i>char</i>, <i>double</i>, <i>int</i>, <i>string</i>, etc.
A simple type <i>T</i> is formed according to the following
inductive definition:

<UL>

<LI>
<i>BT</i> is a simple type.

<LI>
<i>(T_1, ..., T_n) -&gt; T_0</i> is a simple type if <i>T_0, T_1, ...,
T_n</i> are simple types.

</UL>

Let <i>order</i> be a function from simply types to natural numbers
defined as follows:

<UL>

<LI>
<i>order(BT) = 0</i>

<LI>
<i>order((T_1, ..., T_n) -> T_0) = 
max (order(T_0), 1 + order (T_1), ..., 1 + order(T_n))</i>

</UL>

Given a function <i>f</i> of simple type <i>T</i>, we say that
<i>f</i> is a <i>n</i>th-order function if <i>order(T) = n</i>.
For instance, a function of the type
<i>(int, int) -&gt; int</i> is 1st-order,
and a function of the type
<i>int -&gt; (int -&gt; int)</i> is also 1st-order,
and a function of the type
<i>((int -&gt; int), int) -&gt; int</i> is 2nd-order.
In practice, most higher-order functions are 2nd-order.
<P>

As an example, we implement as follows a 2nd-order function
<i>find_root</i> that takes a function <i>f</i> from integers to integers
as its argument and searches for a root of <i>f</i> by enumeration:

<PRE><FONT COLOR="#E80000">
<FONT COLOR="#000000">fn</FONT> find_root <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fun</FONT> aux <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> int</FONT><FONT COLOR="#000000">,</FONT> n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT>
    <FONT COLOR="#000000">if</FONT> f <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> 0 <FONT COLOR="#000000">then</FONT> n <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
      <FONT COLOR="#000000">if</FONT> n &lt;= 0 <FONT COLOR="#000000">then</FONT> aux <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">~</FONT>n + 1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> aux <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">~</FONT>n<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">end</FONT>
<FONT COLOR="#000000">in</FONT>
  aux <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">,</FONT> 0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [fint_root]
</FONT>
</FONT></PRE>

The function
<i>find_root</i> computes <i>f(0)</i>, <i>f(1)</i>, <i>f(-1)</i>,
<i>f(2)</i>, <i>f(-2)</i>, ... until it finds the first integer
<i>i</i> satisfying <i>f(i) = 0</i>.
<P>

As another example, we implement the Newton-Raphson's
method for finding roots of functions on reals:

<PRE><FONT COLOR="#E80000">
<FONT COLOR="#000000">val</FONT> epsilon <FONT COLOR="#000000">=</FONT> 1E-6 <FONT COLOR="#787878">(* precision *)</FONT>

<FONT COLOR="#787878">// Newton-Raphson's method for finding roots
</FONT><FONT COLOR="#787878">// [f1] is a derivative of [f]
</FONT><FONT COLOR="#000000">fn</FONT> newton_raphson <FONT COLOR="#000000">(</FONT>
    f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> double</FONT>
  <FONT COLOR="#000000">,</FONT> f1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> double</FONT>
  <FONT COLOR="#000000">,</FONT> x0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT>
  <FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#000000">(</FONT>
      f<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> double</FONT>
    <FONT COLOR="#000000">,</FONT> f1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double <FONT COLOR="#000000">-&lt;</FONT>cloref1<FONT COLOR="#000000">&gt;</FONT> double</FONT>
    <FONT COLOR="#000000">,</FONT> x0<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT>
    <FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> y0 <FONT COLOR="#000000">=</FONT> f x0
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">if</FONT> abs <FONT COLOR="#000000">(</FONT>y0 / x0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">&lt;</FONT> epsilon <FONT COLOR="#000000">then</FONT> x0 <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
      <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> y1 <FONT COLOR="#000000">=</FONT> f1 x0 <FONT COLOR="#000000">in</FONT> loop <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">,</FONT> f1<FONT COLOR="#000000">,</FONT> x0 - y0 / y1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
    <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [loop]</FONT>
<FONT COLOR="#000000">in</FONT>
  loop <FONT COLOR="#000000">(</FONT>f<FONT COLOR="#000000">,</FONT> f1<FONT COLOR="#000000">,</FONT> x0<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [newton_raphson]
</FONT>
<FONT COLOR="#787878">// square root function
</FONT><FONT COLOR="#000000">fn</FONT> sqrt <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT> <FONT COLOR="#000000">=</FONT>
  newton_raphson <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> x * x - c<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> 2.0 * x<FONT COLOR="#000000">,</FONT> 1.0<FONT COLOR="#000000">)</FONT>

<FONT COLOR="#787878">// cubic root function
</FONT><FONT COLOR="#000000">fn</FONT> cbrt <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">double</FONT> <FONT COLOR="#000000">=</FONT>
  newton_raphson <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> x * x * x - c<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> 3.0 * x * x<FONT COLOR="#000000">,</FONT> 1.0<FONT COLOR="#000000">)</FONT>
</FONT></PRE>
<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available
<a href="higher-order-functions.dats">here</a>.

</BODY>
</HTML>

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [lazy-evaluation.html] -->

<H2><A id="lazy-evaluation" name="lazy-evaluation">Lazy Evaluation</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

Though ATS is a language based on eager call-by-value evaluation, it also
allows the programmer to perform lazy call-by-need evaluation.
In ATS, there is a special language construct
<i>$delay</i> that can be used to delay or suspend the evaluation of
an expression and a special function <i>lazy_force</i>
that can be called to resume a suspended computation.
<P>

There is a special type constructor <i>lazy</i> of the sort <i>(t@ype) =>
type</i> in ATS, which forms a (boxed) type when applied to a type.  On one
hand, given an expression <i>exp</i> of type <i>T</i>, <i>$delay (exp)</i>
forms a value of type <i>lazy(T)</i> that represents the suspended
evaluation of <i>exp</i>.  On the other hand, given a value <i>v</i> of
type <i>lazy(T)</i> for some type <i>T</i>, <i>lazy_force(v)</i> resumes
the suspended evaluation represented by <i>v</i> and returns a result of
type <i>T</i> (if the resumed evaluation terminates). The interface for the
(template) function <i>lazy_force</i> is:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT><FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">a<FONT COLOR="#000000">:</FONT>t@ype</FONT><FONT COLOR="#000000">}</FONT> lazy_force <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">lazy a <FONT COLOR="#000000">-&gt;</FONT> a</FONT>
</FONT></PRE>

The special operatior <i>!</i> in ATS is overloaded with the function <i>lazy_force</i>.

<P>

In the file
<a href="../../IMPLEMENTATION/Anairiats/ATS/prelude/SATS/lazy.sats">prelude/SATS/lazy.sats</a>,
the following datatype <i>stream_con</i> and type <i>stream</i> are
declared for representing (lazy) streams:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">datatype</FONT> <FONT COLOR="#0000FF">stream_con <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>t@ype+<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">|</FONT> stream_nil <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">|</FONT> stream_cons <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">,</FONT> stream a<FONT COLOR="#000000">)</FONT></FONT>

<FONT COLOR="#000000">where</FONT> <FONT COLOR="#0000FF">stream <FONT COLOR="#000000">(</FONT>a<FONT COLOR="#000000">:</FONT>t@ype<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> lazy <FONT COLOR="#000000">(</FONT>stream_con a<FONT COLOR="#000000">)</FONT></FONT>
</FONT></PRE>

Also, a number of common functions on streams are implemented in
<a href="../../IMPLEMENTATION/Anairiats/ATS/prelude/DATS/lazy.dats">prelude/DATS/lazy.dats</a>.
<P>

To simplify the presentation, we use the following
syntax to create shorthands for
the stream constructors <i>stream_nil</i> and <i>stream_cons</i>:

<pre>
<FONT COLOR="#000000">#define</FONT> <FONT COLOR="#800080">nil stream_nil</FONT>
<FONT COLOR="#000000">#define</FONT> <FONT COLOR="#800080">:: stream_cons</FONT>
</pre>

The following code implements a stream representing
the sequence of natural numbers starting from 2:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">typedef</FONT> <FONT COLOR="#0000FF">N2 <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">:</FONT>int <FONT COLOR="#000000">|</FONT> n &gt;= 2<FONT COLOR="#000000">]</FONT> int n</FONT>
<FONT COLOR="#000000">val</FONT> N2s<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream N2</FONT> <FONT COLOR="#000000">=</FONT> from 2 <FONT COLOR="#000000">where</FONT> <FONT COLOR="#000000">{</FONT>
  <FONT COLOR="#000000">fun</FONT> from <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">N2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream N2</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>n :: from <FONT COLOR="#000000">(</FONT>n+1<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">}</FONT>
</FONT></PRE>

More interestingly, the stream of prime numbers can be readily computed
as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT> sieve <FONT COLOR="#000000">(</FONT>ns<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream N2</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:&lt;</FONT><FONT COLOR="#0000FF">1</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#000000">~</FONT><FONT COLOR="#0000FF">ref</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#0000FF">stream N2</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#787878">// [val-] means no warning message from the compiler
</FONT>  <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val-</FONT> n :: ns <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">!</FONT>ns <FONT COLOR="#000000">in</FONT>
     <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>n :: sieve <FONT COLOR="#000000">(</FONT>stream_filter&lt;<FONT COLOR="#0000FF">N2</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>ns<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">lam</FONT> x <FONT COLOR="#000000">=&gt;</FONT> x nmod n <FONT COLOR="#000000">&gt;</FONT> 0<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>

<FONT COLOR="#000000">val</FONT> primes<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream N2</FONT> <FONT COLOR="#000000">=</FONT> sieve N2s

<FONT COLOR="#787878">// find the nth prime
</FONT><FONT COLOR="#000000">fn</FONT> nprime <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT> pos<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">N2</FONT> <FONT COLOR="#000000">=</FONT> stream_nth <FONT COLOR="#000000">(</FONT>primes<FONT COLOR="#000000">,</FONT> n-1<FONT COLOR="#000000">)</FONT></FONT></PRE>

Note that the keyword <i>val-</i> indicates to the typechecker that
no message warning of nonexhaustive pattern matching should be reported.
<P>

As another example, the following code based on lazy evaluation computes
Fibonacci numbers:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">val</FONT> <FONT COLOR="#787878">// the following values are defined mutually recursively
</FONT><FONT COLOR="#000000">rec</FONT> fibs_1<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream int64</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>one :: fibs_2<FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// fib1, fib2, ...
</FONT><FONT COLOR="#000000">and</FONT> fibs_2<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream int64</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>one :: fibs_3<FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// fib2, fib3, ...
</FONT><FONT COLOR="#000000">and</FONT> fibs_3<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">stream int64</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#787878">// fib3, fib4, ...
</FONT>  stream_map2&lt;<FONT COLOR="#0000FF">int64</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#0000FF">int64</FONT><FONT COLOR="#000000">,</FONT><FONT COLOR="#0000FF">int64</FONT><FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">(</FONT>fibs_1<FONT COLOR="#000000">,</FONT> fibs_2<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">lam</FONT> <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=&gt;</FONT> x + y<FONT COLOR="#000000">)</FONT>

<FONT COLOR="#787878">// find the nth Fibonacci number (counting starts from 1)
</FONT><FONT COLOR="#000000">fn</FONT> nfib <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>pos<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int64</FONT> <FONT COLOR="#000000">=</FONT> stream_nth <FONT COLOR="#000000">(</FONT>fibs_1<FONT COLOR="#000000">,</FONT> n-1<FONT COLOR="#000000">)</FONT>
</FONT></PRE>
<P>

Please find extensive use of lazy evaluation in the implementation of
a package for parsing combinators: <A
HREF="https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/contrib/parcomb">contrib/parcomb</A>.
<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="lazy-evaluation.dats">here</a>.

<!-- end of [lazy-evaluation.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [llazy-evaluation.html] -->

<H2><A id="llazy-evaluation" name="llazy-evaluation">Linear
Lazy Evaluation</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The feature of linear lazy evaluation, which is considerably advanced,
addresses the issue of freeing up resources held by a lazy value (that is,
a thunk representing a delayed computation). Let us first see a concrete
example involving the issue. In <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/file.sats">prelude/SATS/file.sats</A>
the following function <i>char_stream_make_file</i> is declared:

<PRE>
// making a lazy char stream out of a file handle
fun char_stream_make_file (fil: FILEref):<1,~ref> stream (char)
</PRE>

Note that the syntax <i>&lt;1,~ref&gt;</i> indicates that the function may
have all kinds of effects except <i>ref</i>. As suggested by its type, the
function <i>char_stream_make_file</i> turns a file handle into a (lazy)
stream of characters. We give an implementation of this function as
follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">implement</FONT> char_stream_make_file <FONT COLOR="#000000">(</FONT>fil<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">val</FONT> c <FONT COLOR="#000000">=</FONT> fgetc0_err <FONT COLOR="#000000">(</FONT>fil<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">if</FONT> c &lt;&gt; EOF <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> c <FONT COLOR="#000000">=</FONT> char_of_int <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>stream_cons <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">,</FONT> char_stream_make_file fil<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
    <FONT COLOR="#000000">let</FONT> <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> fclose0_exn <FONT COLOR="#000000">(</FONT>fil<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">$delay</FONT> <FONT COLOR="#000000">(</FONT>stream_nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT><FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [char_stream_make_file]
</FONT></FONT></PRE>

Clearly, there is an opened file handle inside each character stream formed
by calling <i>char_stream_make_file</i> until all the characters in the
file are put into the stream. If such a character stream is discarded
during evaluation, then the file handle inside it may be left unclosed
<u>indefinitely</u>. This can cause a serious problem in a situation where
a large number of character streams need to be formed by calling
<i>char_stream_make_file</i>. In general, the inability (or the lack of the
ability) to directly free the resources held by lazy values often makes it
rather difficult or even infeasible to employ lazy evaluation in a setting
that requires great precision in resource management.

<H4>A Direct Approach to Freeing Resources inside Lazy Values</H4>

The following function <i>char_stream_vt_make_file</i> is also declared
in <A
HREF="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/prelude/SATS/file.sats">prelude/SATS/file.sats</A>:

<PRE>
// making a linear lazy char stream out of a file handle
fun char_stream_vt_make_file {m:file_mode} {l:addr}
  (pf_mod: file_mode_lte (m, r), pf_fil: FILE m @ l | p_fil: ptr l)
  :<1,~ref> stream_vt (char)
</PRE>

As suggested by its type, the function <i>char_stream_vt_make_file</i>
turns a file handle into a linear stream of characters. An implementation
of this function is given as follows:


<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">implement</FONT> char_stream_vt_make_file <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mod</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_fil</FONT> <FONT COLOR="#000000">|</FONT> p_fil<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">let</FONT>
  <FONT COLOR="#000000">val</FONT> c <FONT COLOR="#000000">=</FONT> fgetc1_err <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mod</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">!</FONT>p_fil<FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">in</FONT>
  <FONT COLOR="#000000">if</FONT> c &gt;= 0 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT> <FONT COLOR="#787878">// c &lt;&gt; EOF
</FONT>    <FONT COLOR="#000000">val</FONT> c <FONT COLOR="#000000">=</FONT> char_of_int <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">$ldelay</FONT> <FONT COLOR="#000000">(</FONT>
      stream_vt_cons <FONT COLOR="#000000">(</FONT>c<FONT COLOR="#000000">,</FONT> char_stream_vt_make_file <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mod</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_fil</FONT> <FONT COLOR="#000000">|</FONT> p_fil<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">,</FONT> fclose1_exn <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fil</FONT> <FONT COLOR="#000000">|</FONT> p_fil<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// end of [$ldelay]
</FONT>  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> fclose1_exn <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fil</FONT> <FONT COLOR="#000000">|</FONT> p_fil<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">in</FONT> <FONT COLOR="#000000">$ldelay</FONT> <FONT COLOR="#000000">(</FONT>stream_vt_nil <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [if]
</FONT><FONT COLOR="#000000">end</FONT> <FONT COLOR="#787878">// end of [char_stream_vt_make_file]
</FONT></FONT></PRE>

The keyword <i>$ldelay</i> is used to form a linear lazy value.  Given
two dynamic expressions <i>exp1</i> and <i>exp2</i>, the linear lazy value
<i>$ldelay (exp1, exp2)</i> essentially contains two thunks whose bodies
are <i>exp1</i> and <i>exp2</i>, repectively.  The first thunk represents a
suspended computation while the second thunk represents a finalizer that
can be called to free up the resources held in the first thunk. In the case
where <i>exp2</i> is missing, <i>exp1</i> is assumed to hold no resources.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="llazy-evaluation.dats">here</a>.

<!-- end of [llazy-evaluation.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [input-and-output.html] -->

<H2><A id="input-and-output" name="input-and-output">Input and
Output</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

The I/O is done in ATS/Anairiats by providing interfaces for various I/O
functions in C. In particular, most functions declared in &lt;stdio.h&gt;
have their counterparts declared in <a
href="http://www.ats-lang.org/IMPLEMENTATION/Anairiats/ATS/libc/SATS/stdio.sats">libc/SATS/stdio.sats</a>.
<P>

There is a datasort <i>file_mode</i> and an abstract type constructor
<i>FILE</i> in ATS that are declared as follows:

<pre>
datasort file_mode =
  | file_mode_r | file_mode_w | file_mode_rw

absviewt@ype FILE (file_mode) = $extype "ats_FILE_type"
</pre>

where the external type <i>ats_FILE_type</i> is an alias of the type
<i>FILE</i> in C. We now use <i>r</i>, <i>w</i> and <i>rw</i> for
<i>file_mode_r</i>, <i>file_mode_w</i> and <i>file_mode_rw</i> in the
following presentation.

If a file is assigned the type <i>FILE(r)</i>, then it is read-only; if it
is assigned the type <i>FILE(w)</i>, then it is write-only; it is assigned
the type <i>FILE(rw)</i>, then it can be read from and also written to.
<P>

There is also an abstract type constructor<i>file_mode</i> declared as
follows:

<pre>
abst@ype file_mode (file_mode)
</pre>

Note that <i>file_mode</i> is overloaded: it refers to a type constructor
as well as a datasort. The following values are available that represent
various file modes:

<pre>
val file_mode_r : file_mode (r) // = "r"
val file_mode_rr : file_mode (rw) // = "r+"
val file_mode_w : file_mode (w) // = "w"
val file_mode_ww : file_mode (rw) // = "w+"
val file_mode_a : file_mode (w) // = "a"
val file_mode_aa : file_mode (rw) // = "a+"
</pre>
<P>

<H4>Opening a File</H4>
The function <i>fopen</i> in C is for opening a file of a given name. In
ATS, there is a function <i>fopen_exn</i> that is assigned the following type:
<pre>
fun fopen_exn {m:file_mode}
  (path: string, m: file_mode m): [l:addr] (FILE m @ l | ptr l)
</pre>
Note that we use
<i>_exn</i> in the name of <i>fopen_exn</i> as a convention to indicate
that an exception is raised if a call to this function results in an error.
There is another function
<i>fopen_err</i> in ATS that is assigned the following type:

<pre>
fun fopen_err {m:file_mode}
  (path: string, m: file_mode m): [l:addr] (FILE_opt_v (m, l) | ptr l)
</pre>

where <i>FILE_opt_v (m, l)</i> is defined as follows:

<pre>
viewdef FILE_opt_v (m:file_mode, l:addr) = option_v (FILE m @ l, l <> null)
</pre>

The function <i>fopen_err</i> exactly corresponds to <i>fopen</i> in C: It
returns a null pointer in case of error.
<P>

<H4>Closing a File</H4>
The function <i>fclose</i> in C is for closing an opened file. In ATS,
there is a function <i>fclose_exn</i> that is assigned the following type:

<pre>
fun fclose_exn {m:file_mode} {l:addr} (pf: FILE m @ l | p: ptr l): void
</pre>

The function <i>fclose_exn</i> raises an exception if a call to it results
in an error. There is another function
<i>fclose_err</i> that is assigned the following type:

<pre>
fun fclose_exn {m:file_mode} {l:addr} (pf: FILE m @ l | p: ptr l): int
</pre>

The function <i>fclose_err</i> exactly corresponds to <i>fclose</i> in C: It
returns 0 in case of success and EOF in case of error.

<H4>Reading from a File</H4>
The function <i>fgetc</i> in C is for reading a character from an opened file. In
ATS, there is a function <i>fget_err</i> that is assigned the following type:

<pre>
fun fgetc_err {m:file_mode}
  (pf: file_mode_lte (m, r) | f: &FILE m): [i:int | i <= UCHAR_MAX] int i
</pre>

where <i>UCHAR_MAX</i> is defined to be 255.
This function exactly corresponds to
<i>fgetc</i> in C: It returns the obtained character (cast into <i>unsigned
char</i>) if successful, or it returns EOF in case of failure.  The file
argument of the function <i>fgets_err</i>, i.e., its first non-proof argument,
is passed as a reference (call-by-reference).
<P>

Note that <i>file_mode_lte</i> is a prop constructor. Given two file modes
<i>m1</i> and <i>m2</i>, if a proof of the prop
<i>file_mode_lte (m1, m2)</i> can be formed, then <i>m1</i> is less than or
equal to <i>m2</i>. The following proofs are available:

<pre>
prval file_mode_lte_r_r : file_mode_lte (r, r)
prval file_mode_lte_rw_r : file_mode_lte (rw, r)
prval file_mode_lte_w_w : file_mode_lte (w, w)
prval file_mode_lte_rw_w : file_mode_lte (rw, w)
prval file_mode_lte_rw_rw : file_mode_lte (rw, rw)
</pre>

In order to read from a file of the type <i>FILE (m)</i>, it is necessary
to prove that <i>m</i> is less than or equal to <i>r</i>.
<P>

There is currently no function <i>fget_exn</i>, which would be given the
following type if defined:

<pre>
fun fgetc_exn {m:file_mode}
  (pf: file_mode_lte (m, r) | f: &FILE m): [i:nat | i <= UCHAR_MAX] int i
</pre>

The problem with <i>fgetc_exn</i> is that it is not a function of much
use. If implemented, this function should probably be called on a file
after it is made certain (e.g., by calling <i>feof</i>) that the file has
not reached its end.

<H4>Writing to a File</H4>

The function <i>fputc</i> in C is for writing a character into a file. In
ATS, there is a function <i>fputc_err</i> that is assigned the following type:

<pre>
fun fputc_err {m:file_mode}
  (pf: file_mode_lte (m, w) | c: char, f: &FILE m): [i:int | i <= UCHAR_MAX] int i
</pre>

This function exactly corresponds to <i>fputc</i> in C: It returns the
charater being written in case of success, or EOF in case of failure. There
is another function <i>fputc_exn</i> that is assigned the following type:

<pre>
fun fputc_exn {m:file_mode} (pf: file_mode_lte (m, w) | c: char, f: &FILE m): void
</pre>

In case of failure, <i>fputs_exn</i> raises an exception.

<H4>An Example: Concatenating Files</H4>

The following function <i>filecopy_exn</i> copies a file into another one:

<PRE><span class="dynexp"><span class="keyword">#define</span> <span class="neuexp">i2c char_of_int1</span>

<span class="keyword">fn</span> filecopy_exn <span class="staexp"><span class="keyword">{</span>m1<span class="keyword">,</span>m2<span class="keyword">:</span>file_mode<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m1<span class="keyword">,</span> r<span class="keyword">)</span></span></span>
  <span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m2<span class="keyword">,</span> w<span class="keyword">)</span></span></span>
  <span class="keyword">|</span> fil_s<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m1</span><span class="keyword">,</span> fil_d<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m2</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop
    <span class="keyword">(</span>fil_s<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m1</span><span class="keyword">,</span> fil_d<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> c <span class="keyword">=</span> fgetc_err <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> fil_s<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> c &gt;= 0 <span class="keyword">then</span> <span class="keyword">begin</span>
      fputc_exn <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> i2c c<span class="keyword">,</span> fil_d<span class="keyword">)</span><span class="keyword">;</span> loop <span class="keyword">(</span>fil_s<span class="keyword">,</span> fil_d<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">end</span> <span class="comment">// end of [loop]
</span><span class="keyword">in</span>
  loop <span class="keyword">(</span>fil_s<span class="keyword">,</span> fil_d<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [filecopy_exn]
</span></span></PRE>

In case of error, <i>filecopy_exn</i> raises an exception.


The following function <i>filecopy_err</i> is a variant of
<i>filecopy_exn</i>. Instead of raising an exception in case of error,
<i>filecopy_err</i> returns EOF.

<PRE><span class="dynexp"><span class="keyword">fn</span> filecopy_err <span class="staexp"><span class="keyword">{</span>m1<span class="keyword">,</span>m2<span class="keyword">:</span>file_mode<span class="keyword">}</span></span> <span class="keyword">(</span>
    <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m1<span class="keyword">,</span> r<span class="keyword">)</span></span></span>
  <span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp">file_mode_lte <span class="keyword">(</span>m2<span class="keyword">,</span> w<span class="keyword">)</span></span></span>
  <span class="keyword">|</span> fil_s<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m1</span><span class="keyword">,</span> fil_d<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m2</span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">fun</span> loop
    <span class="keyword">(</span>fil_s<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m1</span><span class="keyword">,</span> fil_d<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>FILE m2</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> c <span class="keyword">=</span> fgetc_err <span class="keyword">(</span><span class="prfexp">pf1</span> <span class="keyword">|</span> fil_s<span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">if</span> c &gt;= 0 <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">val</span> err <span class="keyword">=</span> fputc_err <span class="keyword">(</span><span class="prfexp">pf2</span> <span class="keyword">|</span> i2c c<span class="keyword">,</span> fil_d<span class="keyword">)</span>
    <span class="keyword">in</span>
      loop <span class="keyword">(</span>fil_s<span class="keyword">,</span> fil_d<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [if]
</span>  <span class="keyword">end</span> <span class="comment">// end of [loop]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>fil_s<span class="keyword">,</span> fil_d<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> ferror <span class="keyword">(</span>fil_d<span class="keyword">)</span> <span class="keyword">=</span> 0 <span class="keyword">then</span> ~1 <span class="keyword">else</span> 0
<span class="keyword">end</span> <span class="comment">// end of [filecopy_err]
</span></span></PRE>

We now use <i>filecopy_err</i> to implement as follows the functionality of
concatenating a list of files into a single one:

<PRE><span class="dynexp"><span class="comment">// concatenation of a list of files
</span><span class="keyword">implement</span> main <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">case+</span> argc <span class="keyword">of</span>
  <span class="keyword">|</span> 1 <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdin</span> <span class="keyword">|</span> p_stdin<span class="keyword">)</span> <span class="keyword">=</span> stdin_get <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> p_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
      <span class="keyword">val</span> _<span class="comment">(*err*)</span> <span class="keyword">=</span> filecopy_err
        <span class="keyword">(</span><span class="prfexp">file_mode_lte_r_r</span><span class="keyword">,</span> <span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>p_stdin<span class="keyword">,</span> <span class="keyword">!</span>p_stdout<span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
      <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stdin_view_set <span class="keyword">(</span><span class="prfexp">pf_stdin</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="comment">// empty
</span>    <span class="keyword">end</span> <span class="comment">// end of [1]
</span>  <span class="keyword">|</span> _ <span class="comment">(*argc &gt;= 2*)</span> <span class="keyword">=&gt;</span> loop <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">,</span> 1<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
      <span class="keyword">fun</span> loop <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
        <span class="keyword">(</span>argc<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span>string<span class="keyword">]</span><span class="keyword">[</span>n<span class="keyword">]</span><span class="keyword">)</span></span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span>
        <span class="keyword">if</span> i <span class="keyword">&lt;</span> argc <span class="keyword">then</span> <span class="keyword">let</span>
          <span class="keyword">val</span> name <span class="keyword">=</span> argv<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">i</span><span class="keyword">]</span>
          <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfopt</span> <span class="keyword">|</span> p_ifp<span class="keyword">)</span> <span class="keyword">=</span> fopen_err <span class="keyword">(</span>name<span class="keyword">,</span> file_mode_r<span class="keyword">)</span>
        <span class="keyword">in</span>
          <span class="keyword">if</span> p_ifp &lt;&gt; null <span class="keyword">then</span> <span class="keyword">let</span>
            <span class="keyword">prval</span> <span class="prfexp">Some_v <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">=</span> pfopt</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> p_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
            <span class="keyword">val</span> _<span class="comment">(*err*)</span> <span class="keyword">=</span> filecopy_err
              <span class="keyword">(</span><span class="prfexp">file_mode_lte_r_r</span><span class="keyword">,</span> <span class="prfexp">file_mode_lte_w_w</span> <span class="keyword">|</span> <span class="keyword">!</span>p_ifp<span class="keyword">,</span> <span class="keyword">!</span>p_stdout<span class="keyword">)</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fclose_exn <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> p_ifp<span class="keyword">)</span>
          <span class="keyword">in</span>
            loop <span class="keyword">(</span>argc<span class="keyword">,</span> argv<span class="keyword">,</span> i+1<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
            <span class="keyword">prval</span> <span class="prfexp">None_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pfopt</span>
            <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> prerrf <span class="keyword">(</span>"%s: can't open [%s]\n"<span class="keyword">,</span> <span class="keyword">@(</span>argv<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span><span class="keyword">,</span> name<span class="keyword">)</span><span class="keyword">)</span>
          <span class="keyword">in</span>
            exit <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span>1<span class="keyword">)</span>
          <span class="keyword">end</span> <span class="comment">// end of [if]
</span>        <span class="keyword">end</span> <span class="comment">// end of [if]
</span>    <span class="keyword">}</span> <span class="comment">// end of [_]
</span>  <span class="comment">// end of [val]
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> p_stdout<span class="keyword">)</span> <span class="keyword">=</span> stdout_get <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">val</span> err <span class="keyword">=</span> ferror <span class="keyword">(</span><span class="keyword">!</span>p_stdout<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stdout_view_set <span class="keyword">(</span><span class="prfexp">pf_stdout</span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> <span class="keyword">(</span>err &lt;&gt; 0<span class="keyword">)</span> <span class="keyword">then</span> <span class="keyword">begin</span>
    prerrf <span class="keyword">(</span>"%s: error writing stdout\n"<span class="keyword">,</span> <span class="keyword">@(</span>argv<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">;</span> exit <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span>2<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    exit <span class="staexp"><span class="keyword">{</span>void<span class="keyword">}</span></span> <span class="keyword">(</span>0<span class="keyword">)</span> <span class="comment">// exit normally
</span>  <span class="keyword">end</span> <span class="comment">// end of [if]
</span><span class="keyword">end</span> <span class="comment">// end of [main]
</span></span></PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available
<a href="input-and-output.dats">here</a>.

<!-- end of [input-and-output.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [ATS-and-C.html] -->

<H2><A id="ats-and-c" name="ats-and-c">Combining ATS and C</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

When programming in ATS, a programmer may need to write C code
occassionally. This is particularly common when the programmer does systems
programming.  Given that both ATS and C use the same data representation,
it is largely straightforward for ATS and C to interact with each other.
In particular, there is no need to write "wrappers" that are used in
languages like
<a href="http://www.ocaml.org">Objective Caml</a> or
<a href="http://www.haskell.org">Haskell</a>.

In ATS, the syntax for enclosing C code is

<pre>
%{ (some C code) %}
</pre>

The symbol <i>%{</i> can be replaced with either <i>%{^</i> or
<i>%{$</i>. The former and the latter mean that the enclosed C code needs
to be put at the top and the bottom of the generated C code, respectively.
<P>
For a function to be called in C, we need to assign a global name to this
function. For instance, the following syntax declares a function <i>foo</i>
that takes a pair of integers and returns a boolean. This function is
given a global name "ats_foo", which can be used in C code to refer to
<i>foo</i>.

<pre>
fun foo : (int, int) -> bool = "ats_foo"
</pre>
We may implement <i>foo</i> either in ATS as follows:
<pre>
implement foo (x, y) = ...
</pre>
or in C as follows:
<pre>
%{

ats_bool_type ats_foo (ats_int_type x, ats_int_type y) { ... }

%}
</pre>

Note that the C types <i>ats_int_type</i> and <i>ats_bool_type</i> are
defined in the file
<a href="../../IMPLEMENTATION/Anairiats/ATS/ccomp/runtime/ats_types.h">ccomp/runtime/ats_types.h</a>
<P>
The following example involves a call in ATS to a function that is
implemented in C:

<pre>
// This function computes Fibonacci numbers
extern fun fibonacci (n: Nat): Nat = "fibonacci"

%{

ats_int_type fibonacci (ats_int_type n) {
  int res1, res2, tmp ;

  if (n < 1) return 0 ;
 
  res1 = 0 ; res2 = 1 ;
  while (n > 1) {
    --n ; tmp = res2 ; res2 += res1 ; res1 = tmp ;
  }

  return res2 ;
}

%}

fn fibonacci_usage (cmd: string): void =
  prerrf ("Usage: %s [integer]\n", @(cmd)) // print an error message

implement main (argc, argv) =
  if argc >= 2 then let
    val n = int1_of argv.[1] // turning string into integer
    val () = assert_errmsg
      (n >= 0, "The integer argument needs to be nonnegative.\n")
    val res = fibonacci n
  in
    printf ("fibonacci (%i) = %i\n", @(n, res))
  end else begin
    fibonacci_usage argv.[0]; exit {void} (1)
  end

</pre>

It is also possible to assign names to types and values in ATS, and such
names can be used in extenal C code.  As an example, the type <i>Tree</i>
in the following code is given a name <i>exTree</i>, which can be used in C
code to refer to the type <i>Tree</i>.

<pre>

dataviewtype tree (int) =
  Nil(0) | {n1,n2:two} Node(1) of (tree n1, int, tree n2)

viewtypedef Tree = [n:two] tree n

// assigning an external name to [Tree]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
extern typedef "exTree" = Tree
extern fun ref_tree : Tree -> ref Tree = "ref_tree"

%{

ats_ref_type ref_tree (ats_ptr_type t) {
  exTree* r ;
  r = ats_malloc_gc (sizeof(exTree)) ;
  *r = (exTree)t ;
  return r ;
}

%}

</pre>

The syntax for assigning a name to a value in ATS is given as follow:

<pre>
<u>extern</u> <u>val</u> $name <u>=</u> $exp
</pre>

where <i>$name</i> is a string literal (representing a valid identifier in
C) and <i>$exp</i> ranges over dynamic expressions in ATS. When used in
external C code, the string
<i>$name</i> refers to the value of the expression <i>$exp</i>.
<P>

In the other direction, we can use
<i><u>$extype</u> "SomeType"</i> in ATS to refer to a type of the name
<i>SomeType</i> in C.  Similarly, we can use <i><u>$extval</u> ($typ,
"SomeValue")</i> for a value of the name <i>SomeValue</i> in C, where
<i>$typ</i> is the supposed type of this value in ATS.
For instance, <i>stdout</i> in ATS is defined as
follows: 

<pre>
<u>#define</u> stdout <u>$exval</u> (<u>$extype</u> "ats_ptr_type", "stdout")
</pre>

where <i>ats_ptr_type</i> is an alias for the type <i>void*</i> in C.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="ATS-and-C.dats">here</a>.

<!-- end of [ATS-and-C.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [programming-with-theorem-proving.html] -->

<H2><A id="PwTP" name="PwTP">Programming with Theorem Proving</H2></A>

<HR SIZE=1 ALIGN=LEFT><P>

The paradigm of programming with theorem proving is rich and broad, and it
is probably the most innovative feature in ATS.  We give an introduction to
this paradigm by presenting a few examples, explaining some motivations
behind programming with theorem proving as well as demonstrating a means to
achieve it in ATS.
<P>

The following code implements a function that computes factorials:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// non-tail-recursive
</FONT><FONT COLOR="#000000">fun</FONT> fact <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">if</FONT> n <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> n nmul fact <FONT COLOR="#000000">(</FONT>n-1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> 1
</FONT></PRE>

The type assigned to <i>fact</i> is

<pre>
{n:nat} int (n) -> Nat
</pre>

That is, the function <i>fact</i> takes a nature number as its argument
and, if it terminates, returns a natural number as its result.
<P>

Now suppose we want to be more accurate. We want to verify that the code
indeed implements the factorial functions.  One possibility is to specify
the factorial function in the statics of ATS, and then try to assign the
following type to <i>fact</i>:

<pre>
{n:nat} int (n) -> int (fact(n))
</pre>

Note that the name <i>fact</i> is overloaded here to also refer to the
factorial function in the statics of ATS. There is, however, a serious
problem with this approach: If functions as complex as the factorial
function could be specified in the statics of ATS, then it would no longer
be possible to support fully automatic constraint-solving.
We take a different approach instead.
<P>

With standard mathematical notation, the factorial function can be
specified as follows:

<pre>
fact (0) = 1 ;
fact (n) = n * fact (n-1) ; if n > 0
</pre>

In ATS, we can declare a dataprop to encode this specification:

<PRE><FONT COLORE="#E80000"><FONT COLOR="#787878">// [FACT (n, x)] is inhabited if and only if [fact (n) = x]
</FONT><FONT COLOR="#000000">dataprop</FONT> <FONT COLOR="#009000"><FONT COLOR="#0000FF">FACT <FONT COLOR="#000000">(</FONT>int<FONT COLOR="#000000">,</FONT> int<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">|</FONT> FACTbas <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>0<FONT COLOR="#000000">,</FONT> 1<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">|</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">n<FONT COLOR="#000000">:</FONT>int</FONT> <FONT COLOR="#000000">|</FONT> <FONT COLOR="#0000FF">n <FONT COLOR="#000000">&gt;</FONT> 0</FONT><FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">{</FONT><FONT COLOR="#0000FF">r<FONT COLOR="#000000">,</FONT>r1<FONT COLOR="#000000">:</FONT>int</FONT><FONT COLOR="#000000">}</FONT>
    FACTind <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">of</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">(</FONT>FACT <FONT COLOR="#000000">(</FONT>n-1<FONT COLOR="#000000">,</FONT> r1<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> MUL <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> r1<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT></FONT></FONT>
</FONT></PRE>

The prop constructor <i>MUL</i> is already defined: Given integers
<i>p</i>, <i>q</i>, and <i>pq</i>, <i>MUL(p, q, pq)</i> is inhabited if and
only if the product of <i>p</i> and <i>q</i> is <i>pq</i>.

The constructors <i>FACTbas</i> (base case) and <i>FACTind</i> (inductive
case) correspond to the first and the second clauses in the above
specification, respectively. 

Given integers <i>n</i> and <i>r</i>, the
prop <i>FACT(n, r)</i> is inhabited if and only if the factorial of <i>n</i>
equals <i>r</i>. Clearly, if a <em>terminating</em> function
can be assgined the following type:

<pre>
{n:nat} int n -> [r:int] (FACT (n, r) | int r)
</pre>

then this function must compute factorials. The code below implements such
a function <i>fact1</i>:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [fact1] implements the factorial function in a non-tail-recursive manner
</FONT><FONT COLOR="#000000">fun</FONT> fact1 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> n <FONT COLOR="#000000">&gt;.</FONT></FONT>
  <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">[</FONT>r<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">(</FONT>FACT <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> int r<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">if</FONT> n <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT>
    <FONT COLOR="#000000">let</FONT>
       <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fac_n1_r1</FONT> <FONT COLOR="#000000">|</FONT> r1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> fact1 <FONT COLOR="#000000">(</FONT>n-1<FONT COLOR="#000000">)</FONT>
       <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mul_n_r1_r</FONT> <FONT COLOR="#000000">|</FONT> r<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> n imul2 r1
    <FONT COLOR="#000000">in</FONT>
       <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">FACTind <FONT COLOR="#000000">(</FONT>pf_fac_n1_r1<FONT COLOR="#000000">,</FONT> pf_mul_n_r1_r<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">|</FONT> r<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">end</FONT>
  <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">FACTbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">|</FONT> 1<FONT COLOR="#000000">)</FONT>
</FONT></PRE>

When applied to a natural number <i>n</i>, <i>fact1</i> is guaranteed to
return a pair <i>(pf, r)</i>, where <i>pf</i> is a proof stating that the
factorial of <i>n</i> is <i>r</i>.  A crucial property of ATS is the
irrelevance of proofs to program evaluation: The dynamic semantics of a
program cannot be altered by erasing the proofs in it.  So proofs are all
erased after compilation and thus are not constructed at run-time.
<P>

This example clearly gives some impression of code duplication as the
specification (<i>FACT</i>) and the implementation (<i>fact1</i>) are of
great similarity to each other. We now present another example, where the
specification and the implementation are far different from each other.
<P>

The following code gives another implementation of the factorial function,
where only tail-recursion is involved:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// tail-recursive
</FONT><FONT COLOR="#000000">fn</FONT> fact <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT> <FONT COLOR="#000000">=</FONT>
      <FONT COLOR="#000000">if</FONT> n <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> loop <FONT COLOR="#000000">(</FONT>n-1<FONT COLOR="#000000">,</FONT> n nmul res<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> res
  <FONT COLOR="#000000">in</FONT>
    loop <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> 1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

Base on this tail-recursive implementation, we implement as follows a
function <i>fact2</i> that is verified to compute factorials.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// Some lemmas on multiplication are stated (without proofs)
</FONT><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULlem00</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>x<FONT COLOR="#000000">,</FONT>y<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>prf<FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">[</FONT>xy<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">]</FONT> MUL <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">,</FONT> xy<FONT COLOR="#000000">)</FONT></FONT>

<FONT COLOR="#787878">// 1 * x = x
</FONT><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULlem10</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>x<FONT COLOR="#000000">,</FONT>y<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT> MUL <FONT COLOR="#000000">(</FONT>1<FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>prf<FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">[</FONT>x==y<FONT COLOR="#000000">]</FONT> void</FONT>
<FONT COLOR="#787878">// x * 1 = x
</FONT><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULlem11</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>x<FONT COLOR="#000000">,</FONT>y<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT> MUL <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> 1<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>prf<FONT COLOR="#000000">&gt;</FONT> <FONT COLOR="#000000">[</FONT>x==y<FONT COLOR="#000000">]</FONT> void</FONT>

<FONT COLOR="#787878">// multiplication is associative: (xy)z = x(yz)
</FONT><FONT COLOR="#000000">extern</FONT> <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">MULlem20</FONT> <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>x<FONT COLOR="#000000">,</FONT>y<FONT COLOR="#000000">,</FONT>z<FONT COLOR="#000000">,</FONT>xy<FONT COLOR="#000000">,</FONT>yz<FONT COLOR="#000000">,</FONT>xyz<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT>
  <FONT COLOR="#000000">(</FONT>MUL <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> y<FONT COLOR="#000000">,</FONT> xy<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> MUL <FONT COLOR="#000000">(</FONT>y<FONT COLOR="#000000">,</FONT> z<FONT COLOR="#000000">,</FONT> yz<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> MUL <FONT COLOR="#000000">(</FONT>xy<FONT COLOR="#000000">,</FONT> z<FONT COLOR="#000000">,</FONT> xyz<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">-&lt;</FONT>prf<FONT COLOR="#000000">&gt;</FONT> MUL <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> yz<FONT COLOR="#000000">,</FONT> xyz<FONT COLOR="#000000">)</FONT></FONT>

<FONT COLOR="#787878">// [fact2] implements the factorial function in a tail-recursive style
</FONT><FONT COLOR="#000000">fn</FONT> fact2 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">[</FONT>r0<FONT COLOR="#000000">:</FONT> int<FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">(</FONT>FACT <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> r0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> int r0<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#787878">// [loop] is tail-recusive
</FONT>    <FONT COLOR="#000000">fun</FONT> loop <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">;</FONT> x<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">.&lt;</FONT> n <FONT COLOR="#000000">&gt;.</FONT></FONT> <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">,</FONT> x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int x</FONT><FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">[</FONT>r<FONT COLOR="#000000">,</FONT>r0<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">]</FONT> <FONT COLOR="#000000">(</FONT>FACT <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">,</FONT> MUL <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">,</FONT> r<FONT COLOR="#000000">,</FONT> r0<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">|</FONT> int r0<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#000000">=</FONT>
      <FONT COLOR="#000000">if</FONT> n <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_mul_x_n_xn</FONT> <FONT COLOR="#000000">|</FONT> xn<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> x imul2 n
        <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fac_n1_r1</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul_xn_r1_r0</FONT> <FONT COLOR="#000000">|</FONT> res<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>n-1<FONT COLOR="#000000">,</FONT> xn<FONT COLOR="#000000">)</FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_mul_n_r1_nr1 <FONT COLOR="#000000">=</FONT> MULlem00 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_mul_x_nr1_r0 <FONT COLOR="#000000">=</FONT> MULlem20 <FONT COLOR="#000000">(</FONT>pf_mul_x_n_xn<FONT COLOR="#000000">,</FONT> pf_mul_n_r1_nr1<FONT COLOR="#000000">,</FONT> pf_mul_xn_r1_r0<FONT COLOR="#000000">)</FONT></FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_fac_n_nr1 <FONT COLOR="#000000">=</FONT> FACTind <FONT COLOR="#000000">(</FONT>pf_fac_n1_r1<FONT COLOR="#000000">,</FONT> pf_mul_n_r1_nr1<FONT COLOR="#000000">)</FONT></FONT>
      <FONT COLOR="#000000">in</FONT>
        <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fac_n_nr1</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul_x_nr1_r0</FONT> <FONT COLOR="#000000">|</FONT> res<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">let</FONT>
        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000">pf_mul_x_1_y <FONT COLOR="#000000">=</FONT> MULlem00 <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#787878">// x * 1 = y
</FONT>        <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> MULlem11 <FONT COLOR="#000000">(</FONT>pf_mul_x_1_y<FONT COLOR="#000000">)</FONT></FONT> <FONT COLOR="#787878">// x = y
</FONT>      <FONT COLOR="#000000">in</FONT>
        <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">FACTbas <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT></FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul_x_1_y</FONT> <FONT COLOR="#000000">|</FONT> x<FONT COLOR="#000000">)</FONT>
      <FONT COLOR="#000000">end</FONT>

    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fac</FONT><FONT COLOR="#000000">,</FONT> <FONT COLOR="#009000">pf_mul</FONT> <FONT COLOR="#000000">|</FONT> res<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> loop <FONT COLOR="#000000">(</FONT>n<FONT COLOR="#000000">,</FONT> 1<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">prval</FONT> <FONT COLOR="#009000"><FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> MULlem10 <FONT COLOR="#000000">(</FONT>pf_mul<FONT COLOR="#000000">)</FONT></FONT>
  <FONT COLOR="#000000">in</FONT>
    <FONT COLOR="#000000">(</FONT><FONT COLOR="#009000">pf_fac</FONT> <FONT COLOR="#000000">|</FONT> res<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

In practice, programming with theorem proving is commonly employed to
capture program invariants that would otherwise not be possible in ATS.
For instance, aided by programming with theorem proving, we can program a
complex data structure like doubly-linked list or doubly-linked tree while
having no fear of misusing pointers. This is considered a great strength of
ATS.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="programming-with-theorem-proving.dats">here</a>.

<!-- end of [programming-with-theorem-proving.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [casting-functions.html] -->

<H2><A id="castingfun" name="castingfun">Casting Functions</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A casting function in ATS is equivalent to the identify function in terms
of dynamic semantics. A call to such a function is evaluated at
compile-time, and its argument is returned. For instance, we have the
following commonly used casting functions:

<PRE>
castfn int1_of_int (x: int):<> [n:nat] int n
castfn string1_of_string (x: string):<> [n:nat] string n
</PRE>

The keyword <i>castfn</i> is for introducing casting functions.

<P>

We now present a typical use of casting functions. The following declared
function <i>list_concat</i> is intended for concatenating a list of lists:

<PRE>
fun{a:t@ype} list_concat (xss: List (List a)): List a
</PRE>

Let us say that we would like to verify that the concatenation of a list of
lists yields a list whose length equals the sum of the lengths of the lists
in the given list of lists. This, for instance, can be done as follows by
introducting a datatype constructor <i>lstlst</i>.

<PRE><span class="dynexp"><span class="keyword">datatype</span> <span class="staexp">lstlst <span class="keyword">(</span>a<span class="keyword">:</span>t@ype+<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>t<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span>
    lstlst_cons <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> m+1<span class="keyword">,</span> t+n<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>list <span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">,</span> lstlst <span class="keyword">(</span>a<span class="keyword">,</span> m<span class="keyword">,</span> t<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> lstlst_nil <span class="staexp"><span class="keyword">(</span>a<span class="keyword">,</span> 0<span class="keyword">,</span> 0<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">)</span></span>

<span class="keyword">fun</span><span class="keyword">{</span><span class="staexp">a<span class="keyword">:</span>t@ype</span><span class="keyword">}</span> _concat <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>t<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>xss<span class="keyword">:</span> <span class="staexp">lstlst <span class="keyword">(</span>a<span class="keyword">,</span> m<span class="keyword">,</span> t<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>a<span class="keyword">,</span> t<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> xss <span class="keyword">of</span>
  <span class="keyword">|</span> lstlst_cons <span class="keyword">(</span>xs<span class="keyword">,</span> xss<span class="keyword">)</span> <span class="keyword">=&gt;</span> list_append <span class="keyword">(</span>xs<span class="keyword">,</span> _concat&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> xss<span class="keyword">)</span>
  <span class="keyword">|</span> lstlst_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [_concat]
</span></span></PRE>

Given a type <i>T</i> and integers <i>I</i> and <i>J</i>, the type
<i>lstlst (T, I, J)</i> is for a list of lists such that the length of the
list is <i>I</i> and each element in the list is a list of values of the
type <i>T</i> and the sum of the lengths of these elements equals <i>J</i>.
<P>

The function <i>list_concat</i> is the same as the function <i>_concat</i>
in terms of dynamic semantics, and it can be implemented as follows:

<PRE><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span> list_concat <span class="keyword">(</span>xss<span class="keyword">)</span> <span class="keyword">=</span>
  _concat&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>lstlst_of_listlist xss<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">castfn</span> lstlst_of_listlist
    <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>xss<span class="keyword">:</span> <span class="staexp">list <span class="keyword">(</span>List a<span class="keyword">,</span> m<span class="keyword">)</span></span><span class="keyword">)</span>
    <span class="keyword">:&lt;&gt;</span> <span class="staexp"><span class="keyword">[</span>t<span class="keyword">:</span>nat<span class="keyword">]</span> lstlst <span class="keyword">(</span>a<span class="keyword">,</span> m<span class="keyword">,</span> t<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">case+</span> xss <span class="keyword">of</span>
    <span class="keyword">|</span> list_cons <span class="keyword">(</span>xs<span class="keyword">,</span> xss<span class="keyword">)</span> <span class="keyword">=&gt;</span> lstlst_cons <span class="keyword">(</span>xs<span class="keyword">,</span> lstlst_of_listlist xss<span class="keyword">)</span>
    <span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> lstlst_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">}</span> <span class="comment">// end of [list_concat]
</span></span></PRE>

Given that <i>lstlst_of_listlist</i> being implemented as a casting
function, the implementation of <i>list_concat</i> is equivalent to
the following one in terms of dynamic semantics:
<PRE>
implement{a} list_concat (xss) = _concat<a> (xss) // this one does not typecheck
</PRE>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="casting-functions.dats">here</a>.

<!-- end of [casting-functions.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [stack-allocation.html] -->

<H2><A id="stackalloc" name="castingfun">Allocation in Stack Frames</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

ATS supports memory allocation in the stack frame of a calling function,
and it is guaranteed by the type system of ATS that memory thus allocated
cannot be accessed once the calling function returns.

<H4>Storing Arrays in Stack Frames</H4>

In the following contrived example, the implemented function
<i>name_of_month_1</i> allocates in its stack frame a string array of size
<i>12</i> that is initialized with the names of 12 months, and then returns
the name of the <i>i</i>th month.

<PRE><span class="dynexp"><span class="keyword">fn</span> name_of_month_1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 1 &lt;= i<span class="keyword">;</span> i &lt;= 12<span class="keyword">}</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> <span class="keyword">!</span>p_arr <span class="keyword">with</span> <span class="prfexp">pf_arr</span> <span class="keyword">=</span> <span class="keyword">@[</span><span class="staexp">string</span><span class="keyword">]</span><span class="keyword">(</span>
    "Jan"<span class="keyword">,</span> "Feb"<span class="keyword">,</span> "Mar"<span class="keyword">,</span> "Apr"<span class="keyword">,</span> "May"<span class="keyword">,</span> "Jun"<span class="keyword">,</span> "Jul"<span class="keyword">,</span> "Aug"<span class="keyword">,</span> "Sep"<span class="keyword">,</span> "Oct"<span class="keyword">,</span> "Nov"<span class="keyword">,</span> "Dec"
  <span class="keyword">)</span>
<span class="keyword">in</span>
  p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">i-1</span><span class="keyword">]</span>
<span class="keyword">end</span> <span class="comment">// end of [name_of_month_1]
</span></span></PRE>

The following syntax indicates that the starting address of the allocated
array is stored in <i>p_arr</i> while the view of the array is stored in
<i>pf_arr</i>:
<PRE>
  var !p_arr with pf_arr = @[string](
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  )
</PRE>
This allocated array is initialized with the strings representing the names of the 12 months: "Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec".
<P>

A variant of the function <i>name_of_month_1</i> is implemeneted as follows:
<PRE><span class="dynexp"><span class="keyword">fn</span> name_of_month_2 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> 1 &lt;= i<span class="keyword">;</span> i <span class="keyword">&lt;</span> 12<span class="keyword">}</span></span> <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">string</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> <span class="keyword">!</span>p_arr <span class="keyword">with</span> <span class="prfexp">pf_arr</span> <span class="keyword">=</span> <span class="keyword">@[</span><span class="staexp">string</span><span class="keyword">]</span><span class="keyword">[</span>12<span class="keyword">]</span><span class="keyword">(</span>""<span class="keyword">)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">0</span><span class="keyword">]</span> := "Jan"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">1</span><span class="keyword">]</span> := "Feb"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">2</span><span class="keyword">]</span> := "Mar"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">3</span><span class="keyword">]</span> := "Apr"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">4</span><span class="keyword">]</span> := "May"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">5</span><span class="keyword">]</span> := "Jun"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">6</span><span class="keyword">]</span> := "Jul"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">7</span><span class="keyword">]</span> := "Aug"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">8</span><span class="keyword">]</span> := "Sep"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">9</span><span class="keyword">]</span> := "Oct"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">10</span><span class="keyword">]</span> := "Nov"
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">11</span><span class="keyword">]</span> := "Dec"
<span class="keyword">in</span>
  p_arr<span class="keyword">-&gt;</span><span class="keyword">[</span><span class="prfexp">i-1</span><span class="keyword">]</span>
<span class="keyword">end</span> <span class="comment">// end of [name_of_month_2]
</span></span></PRE>

The following syntax means that the function <i>name_of_month_2</i>
allocates a string array of size 12 in its stack frame and initializes the
array with the empty string:
<PRE>var !p_arr with pf_arr = @[string][12]("")</PRE>

The starting address and the view of the allocated array are stored in
<i>p_arr</i> and <i>pf_arr</i>, respectively. If the following syntax is
used:

<PRE>var !p_arr with pf_arr = @[string][12]()</PRE>

then the allocated array is uninitialized, that is, the view of the proof
<i>pf_arr</i> is <i>[string?][12] @ p_arr</i> (instead of
<i>[string][12] @ p_arr</i>).

<H4>Storing Closures in Stack Frames</H4>
When higher-order functions are employed in systems programming, it is often
desirable to form closures in the stack frame of the calling function so as
to avoid the need for memory allocation on heap.
<P>

In the following example, the implemented function <i>print_month_name</i>
forms a closure in its stack frame, which is then passed to a higher-order
function <i>iforeach_array_ptr_clo</i>:

<PRE><span class="dynexp"><span class="keyword">fn</span> print_month_names <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> <span class="keyword">!</span>p_arr <span class="keyword">with</span> <span class="prfexp">pf_arr</span> <span class="keyword">=</span> <span class="keyword">@[</span><span class="staexp">string</span><span class="keyword">]</span><span class="keyword">(</span>
    "Jan"<span class="keyword">,</span> "Feb"<span class="keyword">,</span> "Mar"<span class="keyword">,</span> "Apr"<span class="keyword">,</span> "May"<span class="keyword">,</span> "Jun"<span class="keyword">,</span> "Jul"<span class="keyword">,</span> "Aug"<span class="keyword">,</span> "Sep"<span class="keyword">,</span> "Oct"<span class="keyword">,</span> "Nov"<span class="keyword">,</span> "Dec"
  <span class="keyword">)</span>
  <span class="keyword">var</span> <span class="keyword">!</span>p_clo <span class="keyword">with</span> <span class="prfexp">pf_clo</span> <span class="keyword">=</span> @lam <span class="comment">// this closure is allocated in the stack frame
</span>    <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span>unit_v</span></span> <span class="keyword">|</span> i<span class="keyword">:</span> <span class="staexp">sizeLt 12</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span>string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=&lt;</span><span class="staexp">clo1</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">if</span> i <span class="keyword">&gt;</span> 0 <span class="keyword">then</span> print ", "<span class="keyword">;</span> print x<span class="keyword">)</span>
  <span class="comment">// end of [var]
</span>  <span class="keyword">prval</span> <span class="prfexp">pf <span class="keyword">=</span> unit_v <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> iforeach_array_ptr_clo_tsz <span class="staexp"><span class="keyword">{</span>string<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>unit_v<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> <span class="keyword">!</span>p_clo<span class="keyword">,</span> <span class="keyword">!</span>p_arr<span class="keyword">,</span> 12<span class="keyword">,</span> sizeof&lt;<span class="staexp">string</span><span class="keyword">&gt;</span><span class="keyword">)</span>
  <span class="keyword">prval</span> <span class="prfexp">unit_v <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> print_newline <span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="comment">// empty
</span><span class="keyword">end</span> <span class="comment">// end of [print_month_names]
</span></span></PRE>

Note that the keyword <i>@lam</i> (instead of <i>lam</i>) is used here to
indicate that the closure is constructed in the stack frame of the function
<i>print_month_names</i>.

<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a
href="stack-allocation.dats">here</a>.

<!-- end of [stack-allocation.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [statetypes.html] -->

<H2><A id="statetypes" name="statetypes">State Types</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

A state type is a mapping that associates variables with viewtypes.
Intuitively, if a program point can be assigned a state type <EM>ST</EM>,
then each variable in the domain of <EM>ST</EM> must have the type with
which <EM>ST</EM> associates the variable when program execution reaches
that point. In ATS, a state type is represented as follows:

<pre>
(x_1 : VT_1, ..., x_n : VT_n)
</pre>

where for <EM>1 &lt= i &lt= n</EM>, each variable <EM>x_i</EM> is
assiciated with the viewtype <EM>VT_i</EM>.

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="statetypes.dats">here</a>.

<!-- end of [statetypes.html] -->

<HR SIZE=2 ALIGH=LEFT COLOR="000000">
<!-- beg of [loopcon.html] -->

<H2><A id="loopcon" name="loopcon">Loop Constructs</A></H2>

<HR SIZE=1 ALIGN=LEFT><P>

In ATS, there are also constructs for forming for-loops and while-loops
directly. While it is tempting for someone familiar with imperative
programming to implement loops with these constructs (instead of using
tail-recursion), it should be emphasized that the amount of effort involved
in constructing loop invariants (if needed) often makes this style of
programming difficult for beginners and, sometimes, for experts as well.

<H4>Simple Loops</H4>

The following code gives an implementation of the factorial function,
where a <EM>while-loop</EM> is constructed:

<PRE><span class="dynexp"><span class="keyword">fn</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> n
  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">while</span> <span class="keyword">(</span>x <span class="keyword">&gt;</span> 0<span class="keyword">)</span> <span class="keyword">(</span>res := res * x<span class="keyword">;</span> x := x - 1<span class="keyword">)</span>
<span class="keyword">in</span>
  res <span class="comment">// res = n!
</span><span class="keyword">end</span> <span class="comment">// end of [fact]
</span></span></PRE>

The syntax for a while-expression is given as follows:

<PRE><u>while</u> $test $body</PRE>

where <i>$test</i> is an expression of the type <i>bool</i> and
<i>$body</i> is an expression of the type <i>void</i>. Usually,
<i>$body</i> consists of a sequence of expressions of the type <i>void</i>.
<P>

In the following, another implementation of the factorial function is given,
where a <EM>for-loop</EM> is constructed:

<PRE><span class="dynexp"><span class="comment">// a simple for-loop 
</span><span class="keyword">fn</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">for</span> <span class="keyword">(</span>x := 1 <span class="keyword">;</span> x &lt;= n <span class="keyword">;</span> x := x+1<span class="keyword">)</span> res := res * x
<span class="keyword">in</span>
  res <span class="comment">// res = n!
</span><span class="keyword">end</span> <span class="comment">// end of [fact]
</span></span></PRE>

The syntax for a for-expression is given as follows:

<PRE><u>for</u> ($init ; $test ; $post) $body</PRE>
where
<i>$init</i> is an expression of the type <i>void</i>,
<i>$test</i> is an expression of the type <i>bool</i>,
<i>$post</i> is an expression of the type <i>void</i>, and
<i>$body</i> is an expression of the type <i>void</i>. Usually,
<i>$body</i> consists of a sequence of expressions of the type <i>void</i>.

Note that each of <i>$init</i>, <i>$test</i>, and <i>$post</i> can be
omitted. The meaning of each omission should be evident. The following code
gives yet another implemenation of the factorial function:

<PRE><span class="dynexp"><span class="comment">// a simple for-loop with omissions involving [break]
</span><span class="keyword">fn</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">for</span> <span class="keyword">(</span> <span class="keyword">;</span> <span class="keyword">;</span> <span class="keyword">)</span> <span class="comment">// infinite loop
</span>    <span class="keyword">if</span> x &lt;= n <span class="keyword">then</span> <span class="keyword">(</span>res := res * x<span class="keyword">;</span> x := x+1<span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="comment">// end of [val]
</span><span class="keyword">in</span>
  res <span class="comment">// res = n!
</span><span class="keyword">end</span> <span class="comment">// end of [fact]
</span></span></PRE>

Note that <i>break</i> in ATS is equivalent to its counterpart in C. Also,
<i>continue</i> is supported in ATS as shown in the following
implementation of the factorial function:

<PRE><span class="dynexp"><span class="comment">// a simple for-loop with omissions involving [break] and [continue]
</span><span class="keyword">fn</span> fact <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1 <span class="comment">// initialized
</span>  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">for</span> <span class="keyword">(</span> <span class="keyword">;</span> <span class="keyword">;</span> x := x+1<span class="keyword">)</span> <span class="comment">// no loop test
</span><span class="comment">(*
** note that [continue] means to loop again *after* post increment!
*)</span>
    <span class="keyword">if</span> x &lt;= n <span class="keyword">then</span> <span class="keyword">(</span>res := res * x<span class="keyword">;</span> <span class="keyword">continue</span><span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="comment">// end of [val]
</span><span class="keyword">in</span>
  res <span class="comment">// res = n!
</span><span class="keyword">end</span> <span class="comment">// end of [fact]
</span></span></PRE>

<H4>Loops with Annotated Invariants</H4>

It is also possible to annotate loops with invariants expressed in
terms of state types. For such loops, the keywords <u>while*</u>
and <u>for*</u> are used in place of <u>while</u> and <u>for</u>,
respectively.

As an example, the following code implements the standard binary search on
an array of doubles:

<PRE><span class="dynexp"><span class="keyword">fn</span> bsearch <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>
    A<span class="keyword">:</span> <span class="staexp"><span class="keyword">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span>double<span class="keyword">]</span><span class="keyword">[</span>n<span class="keyword">]</span><span class="keyword">)</span></span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">,</span> key<span class="keyword">:</span> <span class="staexp">double</span>
  <span class="keyword">)</span> <span class="keyword">:&lt;&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> l<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 0 <span class="keyword">and</span> u<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> n-1<span class="keyword">;</span> <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> ~1
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">while*</span>
    <span class="keyword">{</span><span class="staexp">i<span class="keyword">,</span>j<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">0 &lt;= i</span><span class="keyword">;</span> <span class="staexp">i &lt;= j+1</span><span class="keyword">;</span> <span class="staexp">j <span class="keyword">&lt;</span> n</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">j+1-i</span><span class="keyword">&gt;.</span> <span class="keyword">(</span>l<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">,</span> u<span class="keyword">:</span> <span class="staexp">int j</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
    <span class="keyword">(</span>l &lt;= u<span class="keyword">)</span> <span class="keyword">let</span>
      <span class="keyword">val</span> m <span class="keyword">=</span> l + <span class="keyword">(</span>u-l<span class="keyword">)</span> / 2
      <span class="keyword">val</span> sgn <span class="keyword">=</span> compare <span class="keyword">(</span>key<span class="keyword">,</span> A<span class="keyword">.</span><span class="keyword">[</span><span class="prfexp">m</span><span class="keyword">]</span><span class="keyword">)</span>
    <span class="keyword">in</span>
      <span class="keyword">case+</span> 0 <span class="keyword">of</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&lt;</span> 0 <span class="keyword">=&gt;</span> <span class="keyword">(</span>u := m-1<span class="keyword">;</span> <span class="keyword">continue</span><span class="keyword">)</span>
      <span class="keyword">|</span> _ <span class="keyword">when</span> sgn <span class="keyword">&gt;</span> 0 <span class="keyword">=&gt;</span> <span class="keyword">(</span>l := m+1<span class="keyword">;</span> <span class="keyword">continue</span><span class="keyword">)</span>
      <span class="keyword">|</span> _ <span class="keyword">=&gt;</span> <span class="keyword">(</span>res := m<span class="keyword">;</span> <span class="keyword">break</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [val]
</span><span class="keyword">in</span>
  res <span class="comment">// 0 &lt;= res &lt; n if [key] is found; or res = ~1 if not
</span><span class="keyword">end</span> <span class="comment">// end of [bsearch]
</span></span></PRE>

The annotated invariant for the loop follows the keyword <u>while*</u>, and
it is separated from the rest of the loop by the symbol <i>=&gt;</i>. The
invariant states that there are integers <i>i</i> and <i>j</i> satisfying
<i>0 &lt;= i</i>,
<i>i &lt;= j+1</i> and
<i>j &lt n</i>
such that the variables <i>l</i> and <i>u</i> are of
the types <i>int(i)</i> and <i>int(j)</i>, respectively, at the entry
point of the loop, that is, the point immediately before the loop test.
A termination metric <i>.&lt;j+1-i&gt;.</i> is provided to verify that
the loop terminates: the metric must decrease whenever the loop goes back
to its entry point.
<P>

As another example, an implementation of the factorial function is
presented as follows that involves the use of an annotated for-loop:

<PRE><span class="dynexp"><span class="keyword">fn</span> fact <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int n</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> x<span class="keyword">:</span> <span class="staexp">int</span>
  <span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> 1
<span class="comment">(*
  // the loop invariant indicates that
  // the value of [x] is [n+1] at the point where the loop exits
*)</span>
  <span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">for*</span> <span class="keyword">{</span><span class="staexp">i<span class="keyword">:</span>nat</span> <span class="keyword">|</span> <span class="staexp">i &lt;= n+1</span><span class="keyword">}</span> <span class="keyword">.&lt;</span><span class="staexp">n+1-i</span><span class="keyword">&gt;.</span>
    <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">int <span class="keyword">(</span>n+1<span class="keyword">)</span></span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>x := 0<span class="keyword">;</span> x &lt;= n <span class="keyword">;</span> x := x+1<span class="keyword">)</span> res := res * x
  <span class="comment">// end of [val]
</span><span class="keyword">in</span>
  res
<span class="keyword">end</span> <span class="comment">// end of [fact]
</span></span></PRE>

The annotated invariant for the for-loop follows the keyword <u>for*</u>,
and it is separated from the rest of the loop by the symbol <i>=&gt;</i>.
This invariant consists of two parts, separated by the colon symbol
(<i>:</i>).  The part before the colon symbol essentially means that there is a
natural number <i>i</i> satisfying <i>i &lt;= n+1</i> such that the variable
<i>x</i> is of the type <i>int(i)</i> at the entry point of the for-loop,
that is, at the point immediately after the loop initialization and before
the loop test.  There is also a termination metric in this part whose
meaning should be evident.  The part after the colon symbol essentially
means that the variable <i>x</i> is of the type <i>int(n+1)</i> at the exit
point of the loop.
<P>

Annotating loops with invariants correctly can be difficult, sometimes. If
complex loop invariants are needed, we recommend that the programmer avoid
constructing loops directly. Instead, the programmer can implement
tail-recursive functions in place of loops. Note that each tail-recursive
function in ATS is guaranteed to be compiled into a loop.
<P>

<HR SIZE=1 ALIGN=LEFT><P>
The code used for illustration is available <a href="loopcon.dats">here</a>.

<!-- end of [loopcon.html] -->

</BODY>
</HTML>
