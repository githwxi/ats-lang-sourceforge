
<!DOCTYPE html>
<html>
<head>
<title>ATSLIB/prelude/list_vt</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntaxkeyword {color:#000000;font-weight:bold;}
  .patsyntaxcomment {color:#787878;font-style:italic;}
  .patsyntaxextcode {color:#A52A2A;}
  .patsyntaxneuexp  {color:#800080;}
  .patsyntaxstaexp  {color:#0000F0;}
  .patsyntaxprfexp  {color:#603030;}
  .patsyntaxdynexp  {color:#F00000;}
  .patsyntaxstalab  {color:#0000F0;font-style:italic}
  .patsyntaxdynlab  {color:#F00000;font-style:italic}
  .patsyntaxdynstr  {color:#008000;font-style:normal}
  .patsyntaxstacstdec  {text-decoration:none;}
  .patsyntaxstacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntaxdyncstdec  {text-decoration:none;}
  .patsyntaxdyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntaxdyncst_implement  {color:#B80000;text-decoration:underline;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<script
type="text/javascript"
src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
></script>

<script
type="text/javascript"
src="http://www.ats-lang.org/scripts/patscode_tryit_bind_all.js"
></script>

</head>
<body>

<h1>ATSLIB/prelude/list_vt</h1>


<p>
This package contains a variety of common functions for creating/freeing
and manipulating linear lists.  </p>

<p>
The type for a singly-linked linear list containing N elements of type T is
denoted by <span class="patsyntaxstaexp">list_vt(T, N)</span>, where T can be linear. The suffix
"vt" in the name list_vt stands for viewtype, which is the formal name
for linear type in ATS.  Note that the type constructor <span class="patsyntaxstaexp">list_vt</span>
is co-variant in its first argument, that is, <span class="patsyntaxstaexp">list_vt(T1, N)</span> is
a subtype of <span class="patsyntaxstaexp">list_vt(T2, N)</span> if T1 is a subtype of T2. The
low-level representation for list_vt is the same as that for a standard
singly-linked list in C, and it is fairly straightforward to implement
functions in C that can directly manipulate linear lists in ATS and vice
versa.
</p>

<p>
Please see
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/SATS/list_vt.sats">list_vt.sats</a> and
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/list_vt.dats">list_vt.dats</a>
(plus
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/list_vt_mergesort.dats">list_vt_mergesort.dats</a>,
<a href="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/DATS/list_vt_quicksort.dats">list_vt_quicksort.dats</a>)
for the SATS file and DATS files in ATSLIB where the functions in this
package are declared and implemented.
</p>



<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<menu>
<li><a href="#list_vt">list_vt</a></li>
<li><a href="#List_vt">List_vt</a></li>
<li><a href="#List0_vt">List0_vt</a></li>
<li><a href="#List1_vt">List1_vt</a></li>
<li><a href="#listLt_vt">listLt_vt</a></li>
<li><a href="#listLte_vt">listLte_vt</a></li>
<li><a href="#listGt_vt">listGt_vt</a></li>
<li><a href="#listGte_vt">listGte_vt</a></li>
<li><a href="#listBtw_vt">listBtw_vt</a></li>
<li><a href="#listBtwe_vt">listBtwe_vt</a></li>
<li><a href="#lemma_list_vt_param">lemma_list_vt_param</a></li>
<li><a href="#list_vt_cast">list_vt_cast</a></li>
<li><a href="#list_vt_make_sing">list_vt_make_sing</a></li>
<li><a href="#list_vt_make_pair">list_vt_make_pair</a></li>
<li><a href="#fprint_list_vt">fprint_list_vt</a></li>
<li><a href="#fprint_list_vt$sep">fprint_list_vt$sep</a></li>
<li><a href="#list_vt_is_nil">list_vt_is_nil</a></li>
<li><a href="#list_vt_is_cons">list_vt_is_cons</a></li>
<li><a href="#list_vt_is_sing">list_vt_is_sing</a></li>
<li><a href="#list_vt_is_pair">list_vt_is_pair</a></li>
<li><a href="#list_vt_unnil">list_vt_unnil</a></li>
<li><a href="#list_vt_uncons">list_vt_uncons</a></li>
<li><a href="#fprint_list_vt_sep">fprint_list_vt_sep</a></li>
<li><a href="#list_vt_length">list_vt_length</a></li>
<li><a href="#list_vt_getref_at">list_vt_getref_at</a></li>
<li><a href="#list_vt_get_at">list_vt_get_at</a></li>
<li><a href="#list_vt_set_at">list_vt_set_at</a></li>
<li><a href="#list_vt_exch_at">list_vt_exch_at</a></li>
<li><a href="#list_vt_insert_at">list_vt_insert_at</a></li>
<li><a href="#list_vt_takeout_at">list_vt_takeout_at</a></li>
<li><a href="#list_vt_copy">list_vt_copy</a></li>
<li><a href="#list_vt_copylin">list_vt_copylin</a></li>
<li><a href="#list_vt_free">list_vt_free</a></li>
<li><a href="#list_vt_freelin">list_vt_freelin</a></li>
<li><a href="#list_vt_freelin$clear">list_vt_freelin$clear</a></li>
<li><a href="#list_vt_uninitize">list_vt_uninitize</a></li>
<li><a href="#list_vt_uninitize_fun">list_vt_uninitize_fun</a></li>
<li><a href="#list_vt_uninitize$clear">list_vt_uninitize$clear</a></li>
<li><a href="#list_vt_append">list_vt_append</a></li>
<li><a href="#list_vt_extend">list_vt_extend</a></li>
<li><a href="#list_vt_snoc">list_vt_snoc</a></li>
<li><a href="#list_vt_reverse">list_vt_reverse</a></li>
<li><a href="#list_vt_reverse_append">list_vt_reverse_append</a></li>
<li><a href="#list_vt_concat">list_vt_concat</a></li>
<li><a href="#list_vt_split_at">list_vt_split_at</a></li>
<li><a href="#list_vt_separate">list_vt_separate</a></li>
<li><a href="#list_vt_separate$pred">list_vt_separate$pred</a></li>
<li><a href="#list_vt_filter">list_vt_filter</a></li>
<li><a href="#list_vt_filter$pred">list_vt_filter$pred</a></li>
<li><a href="#list_vt_filterlin">list_vt_filterlin</a></li>
<li><a href="#list_vt_filterlin$pred">list_vt_filterlin$pred</a></li>
<li><a href="#list_vt_filterlin$clear">list_vt_filterlin$clear</a></li>
<li><a href="#list_vt_app">list_vt_app</a></li>
<li><a href="#list_vt_appfree">list_vt_appfree</a></li>
<li><a href="#list_vt_app$fwork">list_vt_app$fwork</a></li>
<li><a href="#list_vt_appfree$fwork">list_vt_appfree$fwork</a></li>
<li><a href="#list_vt_map">list_vt_map</a></li>
<li><a href="#list_vt_map$fopr">list_vt_map$fopr</a></li>
<li><a href="#list_vt_mapfree">list_vt_mapfree</a></li>
<li><a href="#list_vt_mapfree$fopr">list_vt_mapfree$fopr</a></li>
<li><a href="#list_vt_foreach">list_vt_foreach</a></li>
<li><a href="#list_vt_foreach_env">list_vt_foreach_env</a></li>
<li><a href="#list_vt_foreach$cont">list_vt_foreach$cont</a></li>
<li><a href="#list_vt_foreach$fwork">list_vt_foreach$fwork</a></li>
<li><a href="#list_vt_iforeach">list_vt_iforeach</a></li>
<li><a href="#list_vt_iforeach_env">list_vt_iforeach_env</a></li>
<li><a href="#list_vt_iforeach$cont">list_vt_iforeach$cont</a></li>
<li><a href="#list_vt_iforeach$fwork">list_vt_iforeach$fwork</a></li>
<li><a href="#list_vt_mergesort">list_vt_mergesort</a></li>
<li><a href="#list_vt_mergesort$cmp">list_vt_mergesort$cmp</a></li>
<li><a href="#list_vt_mergesort_fun">list_vt_mergesort_fun</a></li>
<li><a href="#list_vt_quicksort">list_vt_quicksort</a></li>
<li><a href="#list_vt_quicksort$cmp">list_vt_quicksort$cmp</a></li>
<li><a href="#list_vt_quicksort_fun">list_vt_quicksort_fun</a></li>
<li><a href="#Overloaded Symbols">Overloaded Symbols</a></li>
<li><a href="#[]">[]</a></li>
<li><a href="#iseqz">iseqz</a></li>
<li><a href="#isneqz">isneqz</a></li>
<li><a href="#length">length</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#free">free</a></li>
<li><a href="#print">print</a></li>
<li><a href="#prerr">prerr</a></li>
<li><a href="#fprint">fprint</a></li>
</menu>

<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<h2><a id="list_vt">list_vt</a></h2>
<h3>Synopsis</h3>
<p>The full name for the list-type constructor <span class="patsyntaxstaexp">list_vt</span> is
<span class="patsyntaxstaexp">list_viewt0ype_int_viewtype</span>, which is given to the
linear datatype (dataviewtype) declared as follows:
<pre class="patsyntax"><span class="keyword">dataviewtype</span> <span class="comment">// viewt@ype+: covariant</span>
<span class="staexp">list_viewt0ype_int_viewtype
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">viewt@ype+</span><span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">list_vt_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">}</span></span>
    list_vt_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">list_viewt0ype_int_viewtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [list_viewt0ype_int_viewtype]</span>
</pre>
</p>
<h3>Description</h3>

There are two data constructors <span class="patsyntaxdynexp">list_vt_nil</span> and
<span class="patsyntaxdynexp">list_vt_cons</span> associated with <span class="patsyntaxstaexp">list_vt</span>; the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List_vt">List_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span>
<span class="staexp">List_vt<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This type is for linear lists of unspecified length.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List0_vt">List0_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span>
<span class="staexp">List0_vt<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This type is for linear lists of unspecified length that is greater than or
equal to 0. Note that <span class="patsyntaxstaexp">List0_vt</span> is essentially equivalent to
<span class="patsyntaxstaexp">List_vt</span> since the length of a list can never be negative.  The
proof function <span class="patsyntaxprfexp">lemma_list_vt_param</span> can be called explicitly to
cast from <span class="patsyntaxstaexp">List_vt</span> to <span class="patsyntaxstaexp">List0_vt</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="List1_vt">List1_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span>
<span class="staexp">List1_vt<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 1<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This type is for linear lists of unspecified positive length.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listLt_vt">listLt_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listLt_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listLte_vt">listLte_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listLte_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>nat <span class="keyword">|</span> k &lt;= n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listGt_vt">listGt_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listGt_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> k <span class="keyword">&gt;</span> n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listGte_vt">listGte_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listGte_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> k &gt;= n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listBtw_vt">listBtw_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listBtw_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= k<span class="keyword">;</span> k <span class="keyword">&lt;</span> n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="listBtwe_vt">listBtwe_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="keyword">vtypedef</span> <span class="staexp">listBtwe_vt
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>int <span class="keyword">|</span> m &lt;= k<span class="keyword">;</span> k &lt;= n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">k</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="lemma_list_vt_param">lemma_list_vt_param</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="prfexp"><span class="keyword">prfun</span>
lemma_list_vt_param
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>
This proof function establishes that the integer n in any linear list type
<span class="patsyntaxstaexp">list_vt(T, n)</span> is a natural number, where T can be a linear type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_cast">list_vt_cast</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">castfn</span>
list_vt_cast
  <span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function can be employed to explicitly cast a linear list containing
elements of type T1 into another linear list containing elements of type T2
whenever T1 is a subtype of T2.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_make_sing">list_vt_make_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_make_sing <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns a linear list consisting of a given value.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_make_pair">list_vt_make_pair</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_make_pair <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns a linear list consisting of two given values.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list_vt">fprint_list_vt</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_list_vt
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function prints the elements in a given linear list to the output
channel provided as its first argument, and it calls the function
<span class="patsyntaxdynexp">fprint_list_vt$sep</span> before printing an element as long as the
element is not the first one.  Note that printing each list element is
handled by calling the function <span class="patsyntaxdynexp">fprint_ref</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list_vt$sep">fprint_list_vt$sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span> fprint_list_vt$sep <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_is_nil">list_vt_is_nil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_is_nil
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its argument is a linear list of
length 0.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_is_cons">list_vt_is_cons</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_is_cons
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its argument is a linear list of
some positive length.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_is_sing">list_vt_is_sing</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_is_sing
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its argument is a linear list of
length 1, that is, a singleton linear list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_is_pair">list_vt_is_pair</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_is_pair
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">2</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>
This function returns true if and only if its argument is a linear list of
length 2.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_unnil">list_vt_unnil</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
list_vt_unnil<span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_uncons">list_vt_uncons</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_uncons<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">x</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint_list_vt_sep">fprint_list_vt_sep</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_list_vt_sep
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_list_vt_sep]</span></pre>
<h3>Description</h3>

This function prints the elements in a given linear list to the output
channel provided as its first argument, interspersing the string
<span class="patsyntaxdynexp">sep</span> between the printed list elements. Note that printing each
list element is handled by calling the function <span class="patsyntaxdynexp">fprint_ref</span>.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_length">list_vt_length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_length<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="staexp">n</span></span></pre>
<h3>Description</h3>
This function returns the length of a given linear list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_getref_at">list_vt_getref_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_getref_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span> <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs of length n and a natural number i <= n, this
function returns a pointer that points to the suffix of xs of length n-i.
While this function itself is safe, any subsequent use of the returned
pointer requires great caution. <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_get_at">list_vt_get_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_get_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">x</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_set_at">list_vt_set_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_set_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_exch_at">list_vt_exch_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_exch_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_insert_at">list_vt_insert_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_insert_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLte</span> <span class="staexp">n</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">x</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [list_vt_insert_at]</span></pre>
<h3>Description</h3>

Given a linear list xs of length n, a natural number i <= n, and an element
x, this inserts x into xs immediately after the first i elements so that x
becomes element i+1 in the returned list.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_takeout_at">list_vt_takeout_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_takeout_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">x</span></span></pre>
<h3>Description</h3>

Given a linear list xs of length n and a natural number i < n, this function
takes out element i from xs.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_copy">list_vt_copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_copy<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs, this function returns a copy of xs.
Note that the elements of xs are required to be of a linear type.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_copylin">list_vt_copylin</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_copylin<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs, this function returns a copy of xs.
Note that the elements of xs are copied by callig the function
<span class="patsyntaxdynexp">list_vt_copylin$copy</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_free">list_vt_free</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_free <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function frees the memory occupied by a given linear list.
Note that the elements contained in the list must be nonlinear.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_freelin">list_vt_freelin</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_freelin
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function frees the memory occupied by a given linear list.
Note that the elements contained in the list are freed by calling the
function <span class="patsyntaxdynexp">list_vt_freelin$clear</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_freelin$clear">list_vt_freelin$clear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_freelin$clear <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_uninitize">list_vt_uninitize</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_uninitize
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [list_vt_uninitize]</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_uninitize_fun">list_vt_uninitize_fun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_uninitize_fun
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>fe<span class="keyword">:</span>eff<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">&amp;</span><span class="staexp">x</span><span class="staexp">&gt;&gt;</span><span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">,</span><span class="staexp">fe</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [list_vt_uninitize_fun]</span></pre>
<h3>Description</h3>
This function frees the elements in a given linear list (but keeps
the list itself).
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_uninitize$clear">list_vt_uninitize$clear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_uninitize$clear <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_append">list_vt_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_append
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span> <span class="comment">// endfun</span></pre>
<h3>Description</h3>

This functions appends its first list argument to its second list argument.
Note that the two list arguments are consumed in the construction of the
resulting list and thus no longer available after the function returns.
There is no memory allocation/deallocation involved.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_extend">list_vt_extend</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_extend<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs1<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">x</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a list xs and an element x, this function extends xs with x at the
end.  Note that the time-complexity of this is function is O(n), where n is
the length of xs.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_snoc">list_vt_snoc</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">macdef</span> list_vt_snoc <span class="keyword">=</span> list_vt_extend</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_reverse">list_vt_reverse</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_reverse<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_reverse_append">list_vt_reverse_append</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_reverse_append<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_concat">list_vt_concat</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_concat
  <span class="keyword">(</span>xss<span class="keyword">:</span> <span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xss, this function builds a concatenation of xss[0],
xss[1], ..., and xss[n-1], where n is the length of xss and each xss[i]
refers to element i in xss.  Note that xss is freed and all of its elements
are consumed in the construction of the returned list. In particular, there
is no memory allocation involved in a call to <span class="patsyntaxdynexp">list_vt_concat</span>.
<h3>Example</h3>

The following code makes a simple use of <span class="patsyntaxdynexp">list_vt_concat</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_0.dats"><span class="dynexp"><span class="keyword">implement</span>
main0 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">2</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs3 <span class="keyword">=</span> <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">3</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xss <span class="keyword">=</span> <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">T</span><span class="keyword">)</span><span class="keyword">}</span><span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">,</span> xs3<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs123 <span class="keyword">=</span> list_vt_concat <span class="keyword">(</span>xss<span class="keyword">)</span></span> <span class="comment">// xs123 = [1, 2, 3]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list_vt&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> xs123<span class="keyword">)</span></span> <span class="comment">// printing out 1, 2, 3</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs123<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_split_at">list_vt_split_at</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_split_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs of length n and an integer i between 0 and n,
inclusive, the function returns a prefix and a suffix of xs of length
i and n-i, respectively.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_separate">list_vt_separate</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_separate<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>n1<span class="keyword">:</span>nat<span class="keyword">|</span>n1 &lt;= n<span class="keyword">]</span></span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">n1</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function splits a given linear list xs into two according to the
predicate implemented by <span class="patsyntaxdynexp">list_vt_separate$pred</span>: the elements
left in xs satisfy the predicate while those in the returned list do not.

<h3>Example</h3>

The following code implements the standard quicksort on linear lists:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_1.dats"><span class="comment">//</span>
<span class="keyword">staload</span> UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_qsort
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">n</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> <span class="keyword">@</span>list_vt_cons
    <span class="keyword">(</span>x0<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> p_x0 <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>x0<span class="keyword">)</span></span>
<span class="comment">//</span>
    <span class="dynexp"><span class="keyword">implement</span>
    list_vt_separate$pred&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
        <span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">fpf</span> <span class="keyword">|</span> p_x0
      <span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr_vtake<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>p_x0<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> cmp <span class="keyword">(</span>x<span class="keyword">,</span> <span class="keyword">!</span>p_x0<span class="keyword">)</span> &lt;= <span class="dynexp">0</span></span> <span class="comment">// ascending order</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      ans
    <span class="keyword">end</span></span> <span class="comment">// end of [list_vt_separate$pred]</span>
<span class="comment">//</span>
    <span class="keyword">var</span> xs11 <span class="keyword">=</span> xs1
    <span class="comment">// HX: xs11/xs12: &lt;= x0 / &gt; x0</span>
    <span class="dynexp"><span class="keyword">val</span> xs12 <span class="keyword">=</span>
      list_vt_separate&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs11<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs11 <span class="keyword">=</span> list_vt_qsort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs11<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> xs12 <span class="keyword">=</span> list_vt_qsort&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs12<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs1 := xs12</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    list_vt_append <span class="keyword">(</span>xs11<span class="keyword">,</span> xs<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list_vt_cons]</span>
<span class="keyword">|</span> <span class="keyword">~</span>list_vt_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list_vt_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list_vt_qsort]</span>
</pre>


Note that there is no memory allocation/deallocation involved in this
implementation. It is formally verified in the type system of ATS that the
list returned by <span class="patsyntaxdynexp">list_vt_qsort</span> is of the same length as its input.  On
a meta-level, it is evident that the returned list must be a permutation of
the input as linear elements cannot be either discarded or duplicated.

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_separate$pred">list_vt_separate$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_separate$pred <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_filter">list_vt_filter</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_filter<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">listLte_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_filter$pred">list_vt_filter$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
list_vt_filter$pred <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_filterlin">list_vt_filterlin</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_filterlin
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">listLte_vt</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_filterlin$pred">list_vt_filterlin$pred</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_filterlin$pred <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_filterlin$clear">list_vt_filterlin$clear</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_filterlin$clear <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_app">list_vt_app</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_app <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_appfree">list_vt_appfree</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_appfree
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

This function is similar to <span class="patsyntaxdynexp">list_vt_app</span>. However, it frees each
list node after applying to the node the function implemented by
<span class="patsyntaxdynexp">list_vt_appfree$fwork</span>.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_app$fwork">list_vt_app$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_app$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_appfree$fwork">list_vt_appfree$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
list_vt_appfree$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_map">list_vt_map</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_map<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs of length n, this function returns a linear list
consisting f(xs[i]), where i ranges from 0 until n-1, xs[i] refers to
element i in xs and f is the function implemented by
<span class="patsyntaxdynexp">list_map_vt$fopr</span>. Note that the given list xs is kept after the
function returns.  The implementation of this function in ATSLIB is
tail-recursive.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_map$fopr">list_vt_map$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_map$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_mapfree">list_vt_mapfree</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_mapfree<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">y</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

This function is similar to <span class="patsyntaxdynexp">list_vt_map</span>. However, it frees each
list node after applying to the node the function implemented by
<span class="patsyntaxdynexp">list_vt_mapfree$fopr</span>.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_mapfree$fopr">list_vt_mapfree$fopr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>y<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_mapfree$fopr<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">x</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">y</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_foreach">list_vt_foreach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_foreach <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<h3>Description</h3>

Given a list xs of length n, this function traverses xs, applying to xs[i]
the function implemented by <span class="patsyntaxdynexp">list_vt_foreach$fwork</span>, where i
ranges from 0 until n-1, inclusive, and xs[i], treated as a left-value,
refers to element i in xs.  The traversal stops if the function implemented
by <span class="patsyntaxdynexp">list_vt_foreach$cont</span> returns false.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_foreach_env">list_vt_foreach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_foreach_env <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">List_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_foreach$cont">list_vt_foreach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_foreach$cont <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_foreach$fwork">list_vt_foreach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_foreach$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_iforeach">list_vt_iforeach</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_iforeach
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Given a linear list xs of length n, this function traverses xs, applying to
(i, xs[i]) the function implemented by <span class="patsyntaxdynexp">list_vt_iforeach$fwork</span>,
where i ranges from 0 until n-1, inclusive, and xs[i], treated as a
left-value, refers to element i in xs.  The traversal stops if the function
implemented by <span class="patsyntaxdynexp">list_vt_foreach$cont</span> returns false.  <hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_iforeach_env">list_vt_iforeach_env</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_iforeach_env
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">x</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_iforeach$cont">list_vt_iforeach$cont</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_iforeach$cont
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span></pre>
<h3>Description</h3>
The default implementation of this function always returns true.<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_iforeach$fwork">list_vt_iforeach$fwork</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
x<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_iforeach$fwork
  <span class="keyword">(</span>i<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">x</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_mergesort">list_vt_mergesort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_mergesort
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its list argument according to the
ordering implemented by <span class="patsyntaxdynexp">list_vt_mergesort$cmp</span>. Note that the
list argument is consumed in the construction of the resulting sorted list
and thus no longer available after the function returns.  There is no
memory allocation/deallocation involved in the implementation of
<span class="patsyntaxdynexp">list_vt_mergesort</span>.

<h3>Example</h3>

The following code mergesorts a list of integers into a list of ascending
integers:
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_2.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">10</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list_vt_sep&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">"; "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_vt_mergesort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span>
  list_vt_mergesort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list_vt&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> ys<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_mergesort$cmp">list_vt_mergesort$cmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_mergesort$cmp <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span><span class="comment">(*sgn*)</span></pre>
<h3>Description</h3>

This function is called in the implementation of
<span class="patsyntaxdynexp">list_vt_mergesort</span> to perform comparison test on list elements,
and its default implementation is based on <span class="patsyntaxdynexp">gcompare_ref</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_3.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list_vt_mergesort$cmp <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gcompare_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_mergesort_fun">list_vt_mergesort_fun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_mergesort_fun
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [list_vt_mergesort_fun]</span></pre>
<h3>Description</h3>
This function does essentially the same as <span class="patsyntaxdynexp">list_vt_mergesort</span>
except for allowing the comparison function to be provided as an argument.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_quicksort">list_vt_quicksort</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_quicksort
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span></pre>
<h3>Description</h3>

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its list argument according to the ordering implemented
by <span class="patsyntaxdynexp">list_vt_quicksort$cmp</span>. Note that the list argument is
consumed in the construction of the resulting sorted list and thus no
longer available after the function returns. An implementation of this
function may copy the list into an array, sort the array, copy the array
back into the list, and then free the array.

<h3>Example</h3>

The following code quicksorts a list of integers into a list of ascending
integers:
<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_4.dats"><span class="dynexp"><span class="keyword">implement</span>
main <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> N <span class="keyword">=</span> <span class="dynexp">10</span></span>
<span class="dynexp"><span class="keyword">val</span> out <span class="keyword">=</span> stdout_ref</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">T <span class="keyword">=</span> <span class="staexp">int</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  <span class="keyword">$list_vt</span><span class="keyword">{</span><span class="staexp">T</span><span class="keyword">}</span><span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">,</span> <span class="dynexp">9</span><span class="keyword">,</span> <span class="dynexp">2</span><span class="keyword">,</span> <span class="dynexp">7</span><span class="keyword">,</span> <span class="dynexp">4</span><span class="keyword">,</span> <span class="dynexp">5</span><span class="keyword">,</span> <span class="dynexp">6</span><span class="keyword">,</span> <span class="dynexp">3</span><span class="keyword">,</span> <span class="dynexp">8</span><span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list_vt_sep&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">,</span> <span class="dynstr">"; "</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
list_quicksort$cmp&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span> <span class="keyword">=</span> compare <span class="keyword">(</span>x1<span class="keyword">,</span> x2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> ys <span class="keyword">=</span>
  list_vt_quicksort&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_list_vt&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> ys<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_newline <span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> list_vt_free&lt;<span class="staexp">T</span><span class="keyword">&gt;</span> <span class="keyword">(</span>ys<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="dynexp">0</span><span class="comment">(*normal*)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [main]</span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_quicksort$cmp">list_vt_quicksort$cmp</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_quicksort$cmp <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span><span class="comment">(*sgn*)</span></pre>
<h3>Description</h3>

This function is called in the implementation of
<span class="patsyntaxdynexp">list_vt_quicksort</span> to perform comparison test on list elements,
and its default implementation is based on <span class="patsyntaxdynexp">gcompare_ref</span>:

<pre class="patsyntax patscode_tryit" name="TRYIT/prelude_list_vt_5.dats"><span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
list_vt_quicksort$cmp <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span> <span class="keyword">=</span> gcompare_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span></span>
</pre>

<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="list_vt_quicksort_fun">list_vt_quicksort_fun</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> list_vt_quicksort_fun
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="comment">// end of [list_vt_quicksort_fun]</span></pre>
<h3>Description</h3>
This function does essentially the same as <span class="patsyntaxdynexp">list_vt_quicksort</span>
except for allowing the comparison function to be provided as an argument.
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="Overloaded Symbols">Overloaded Symbols</a></h2>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="[]">[]</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> list_vt_get_at</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> list_vt_set_at</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="iseqz">iseqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> list_vt_is_nil</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="isneqz">isneqz</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> list_vt_is_cons</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="length">length</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> list_vt_length</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="copy">copy</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> copy <span class="keyword">with</span> list_vt_free</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="free">free</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> free <span class="keyword">with</span> list_vt_free</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="print">print</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> print <span class="keyword">with</span> print_list_vt</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="prerr">prerr</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> prerr <span class="keyword">with</span> prerr_list_vt</span></pre>
<hr style="background-color: #E0E0E0; height: 1px;"></hr>
<h2><a id="fprint">fprint</a></h2>
<h3>Synopsis</h3>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list_vt</span></pre>
<pre class="patsyntax">
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_list_vt_sep</span></pre>


<hr style="background-color: #E0E0E0; height: 2px;"></hr>

<table>
<tr>
<td style="width: 100%;">
This page is created with
<a href="http://www.ats-lang.org">ATS</a>
by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
and also maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</td>
<td style="width: 0%;"><!--pushed to the right-->
<a href="http://sourceforge.net">
<img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2"
width="120"
height="36"
alt="SourceForge.net Logo"
/>
</a>
</td>
</tr>
</table>


</body>
</html>

